# Desarrollo de un CRUD

## Introducción a CRUD

<p style="float: left; margin-left: 1rem;">
  <img src="../../img/laravelactividad.png"
       alt="Actividad en el aula virtual"
       width="150">
</p>
El término **CRUD** corresponde a las operaciones básicas que se realizan en la mayoría de las aplicaciones que gestionan datos:

* **C**reate (Crear): Insertar nuevos datos.
* **R**ead (Leer): Consultar y visualizar datos.
* **U**pdate (Actualizar): Modificar datos existentes.
* **D**elete (Eliminar): Borrar datos.

En Laravel, la implementación de un CRUD completo nos permite comprender cómo los **Modelos**, **Controladores** y **Vistas** interactúan entre sí para ofrecer una experiencia de usuario completa.

Desarrollo de CRUDs

Dominar el desarrollo de CRUDs es básico para cualquier programador web, ya que casi todas las aplicaciones web tienen que manejar datos de algún tipo, y estas son las acciones fundamentales que se realizan sobre esos datos.

Además, este tema nos va a servir para aprender el funcionamiento de los formularios en Laravel.

## Rutas Dinámicas y Controladores

### Crear un circuito MVC rápido para rutas dinámicas


???+examplelaravel "Utilizar la tabla `notes` con los campos:"

    * `id` (entero, autoincremental)
    * `title` (string)
    * `description` (text)
    * `date` (date)
    * `done` (boolean)

???+examplelaravel "Crear la migración de la nota y el controador:"
    
    Crear Migración y Modelo
    
    ```
    php artisan make:migration create_notes_table
    php artisan make:model Note
    ```
    
    Podemos crear la migración y la nota con un solo comando:
    
    Crear Modelo y Migración
    
    ```
    php artisan make:model Note -m
    ```

???+examplelaravel "Archivo de migración `database/migrations/xxxx_xx_xx_create_notes_table.php` y añadimos los campos:"
    Migración

    ``` 
      public function up() {     
         Schema::create('notes', function (Blueprint $table) {         
            $table->id();         
            $table->string('title');         
            $table->text('description');         
            $table->date('date');         
            $table->boolean('done')->default(false);         
            $table->timestamps();     
         }); 
      } 
      
      public function down() {     
         Schema::dropIfExists('notes'); 
      } 
    ```

Por último, ejecutamos la migración:

???+examplelaravel "Ejecutar Migración"
    
    ```
    php artisan migrate
    ```



???+examplelaravel "Resetear Migraciones"
    Si tenemos algún problema porque no hemos creado la base de datos desde 0, podemos eliminar las migraciones anteiores con:

    ```
    php artisan migrate:reset
    ```

**Modelo Note:**

Ahora vamos a implementar el modelo `Note`. Vamos a definir los campos que se pueden asignar en masa y los que no:

???+examplelaravel "Modelo"

    ``` 
    namespace App\Models; 

    use Illuminate\Database\Eloquent\Model;  

    class Note extends Model {     
      protected $fillable = ['title', 'description', 'date', 'done'];     
      protected $guarded = ['id']; 
    } 
    ```
    
    * `$fillable`: Define qué campos se pueden asignar en masa.
    * `$guarded`: Define qué campos **no** se pueden asignar.

**Controlador NoteController:**

???+examplelaravel "Crear Controlador"
   
    ```
    php artisan make:controller NoteController
    ```

Ahora codificamos el controlador `app/Http/Controllers/NoteController.php`:

???+examplelaravel "método show, para mostrar un ID"
    
    ```
    public function show($id)
    {
        return view('notes.show', compact('id'));
    }
    ```

**Ruta asociada:**

Ahora que ya tenemos el controlador y el método que manejará la ruta, y el modelo que se conectará con la base de datos, vamos a definir la ruta en `routes/web.php`:

???+examplelaravel "Ruta con Parámetro Dinámico y Controlador"
    
    ``` 
    use App\Http\Controllers\NoteController;  
    
    Route::get('/note/{id}', [NoteController::class, 'show'])->name('note.show'); 
    ```

**Vista `resources/views/notes/show.blade.php`:**

Por último nos queda crear la vista que mostrará la información de la nota con el ID recibido:

???+examplelaravel "Vista show.blade.php"
    
    ``` 
    <h1>Detalle de Nota</h1> 
    <p>El ID de la nota es: {{ $id }}</p> 
    ```

Con esto, accediendo a `/note/5` veremos "El ID de la nota es: 5".

???+examplelaravel "imagen /note/5"
    
    ![imagen /note/5](../img/img01.png)

???+examplelaravel "función compact()"
    
    La función `compact('variable')` crea un array asociativo `['variable' => $variable]` que puede ser pasado a la vista. Es una forma rápida y limpia de pasar datos. Sólo la puedo utilizar si el valor de la clave es el mismo que el nombre de la variable.

### Parámetros opcionales y valores por defecto

Podemos definir parámetros **opcionales** añadiendo un signo de interrogación `?`:

???+examplelaravel "Ruta con Parámetro Opcional"
    
    ``` 
    Route::get('/saludo/{nombre?}', function ($nombre = 'Invitado') {
        return "Hola, $nombre"; 
    }); 
    ```
    
    * Si accedemos a `/saludo/Laura`, veremos "Hola, Laura".
    * Si accedemos a `/saludo`, veremos "Hola, Invitado".

!!!warning "Reglas para Parámetros Opcionales"
    
    * El parámetro opcional debe ser el último de la URL.
    * Hay que asignar un **valor por defecto** en la función.

### Importancia del orden de las rutas

Laravel evalúa las rutas en el **orden en que se definen**.

**Ejemplo de conflicto:**

``` 
Route::get('/nota/nueva', function() { return 'Crear nueva nota'; }); 
Route::get('/nota/{id}', function($id) { return "Nota ID: $id"; }); 
```

* Primero debe definirse `/nota/nueva` porque si no, Laravel intentará interpretar `nueva` como un `id`.
* El orden correcto es siempre de **rutas más específicas a más generales**.

!!!warning "Consejo"
    
    Primero define todas las rutas fijas y luego las rutas con parámetros dinámicos.

## Desarrollo del CRUD para notas

### Listar todas las notas

Primero creamos la ruta y el método para listar todas las notas.

**Ruta:**

???+examplelaravel "Ruta para Listar Notas"
    
    ``` 
    use App\Http\Controllers\NoteController;  
    Route::get('/', [NoteController::class, 'index'])->name('note.index'); 
    ```

**Controlador:**

???+examplelaravel "método index, para listar todas las notas"
    
    ```
    use App\Models\Note;
    public function index()
    {
        $notes = Note::all();
        return view('notes.index', compact('notes'));
    }
    ```

**Explicación de @forelse vs @foreach:**

* `@foreach` se utiliza para recorrer elementos, pero no gestiona si el array está vacío.
* `@forelse` permite recorrer elementos y además definir qué hacer si no hay elementos.

Ejemplo:

``` 
@forelse ($notes as $note)     
   <p>{{ $note->title }}</p>
@empty     
   <p>No hay notas disponibles.</p> 
@endforelse 
```

En el ejemplo anterior, si `$notes` está vacío, se mostrará "No hay notas disponibles."

**Crear layout base en `resources/views/layouts/app.blade.php`:**

???+examplelaravel "Layout"
    
    ``` 
    <!DOCTYPE html> 
    <html lang="es"> 
        <head>     
            <meta charset="UTF-8">     
            <title>
                @yield('title')
            </title> 
        </head> 
    <body>     
        <header>         
            <h1>Mi Aplicación de Notas</h1>         
            <nav>             
                <a href="{{ route('note.index') }}">Inicio</a> |             
                <a href="{{ route('note.create') }}">Crear Nota</a>         
            </nav>     
        </header>     
        <main>         
            @yield('content')     
        </main>
    </body> 
    </html> 
    ```

**Vista de Listado `resources/views/notes/index.blade.php`:**

En este formulario vamos a adelantar algunas cosas que ampliaremos más adelante. Para poner el enlace a leminar una nota, vamos a utilizar un formulario con el método `POST` y la directiva `@method('DELETE')`. Esta directiva simula el método HTTP DELETE en formularios HTML (que solo permiten GET y POST). Más adelante explicaremos esto con más detalle. Hasta aquí nada especialmente llmativo. Pero también veréis que está la directiva `@csrf`. Esta directiva genera un campo oculto con un token que protege el formulario contra ataques CSRF (Cross-Site Request Forgery). Más adelante también explicaremos esto con más detalle. En `laravel` esta prtección es automática, pero hay que incluir la directiva `@csrf` en los formularios para que funcione correctamente.

???+examplelaravel "Listado de Notas"
    
    ``` 
    @extends('layouts.app')  
    
    @section('title', 'Listado de Notas')  
    
    @section('content')     
        
        <h2>Listado de Notas</h2>      
        
        @forelse ($notes as $note)         
            <div>             
                <h3><a href="{{ route('note.show', $note->id) }}">{{ $note->title }}</a></h3>             
                <p>{{ $note->description }}</p>             
                <small>{{ $note->date }}</small>             
                <div>                 
                    <a href="{{ route('note.edit', $note->id) }}">Editar</a>                 
                    <form action="{{ route('note.destroy', $note->id) }}" method="POST" style="display:inline">                     
                    @csrf                     
                    @method('DELETE')                     
                        <button type="submit">Eliminar</button>                 
                    </form>             
                </div>         
            </div>     
        @empty         
            <p>No hay notas disponibles.</p>    
        @endforelse 
    @endsection 
    ```

---

### Crear una Nueva Nota

Para poder crear una nota necesitamos tres cosas:

1. Una ruta que muestre el formulario de creación, `/note/create`.
2. Un método en el controlador que maneje esa ruta y muestre la vista con el formulario: `function create()`.
3. Una vista que contenga el formulario de creación: `resources/views/notes/create.blade.php`.

**Ruta para formulario de creación:**

???+examplelaravel "Ruta para Crear Nota"
    
    ```
    Route::get('/note/create', [NoteController::class, 'create'])->name('note.create');
    ```

**Controlador:**

???+examplelaravel "método create, para mostrar el formulario de creación"
    
    ``` 
    public function create() {     
        return view('notes.create'); 
    } 
    ```

**Vista `resources/views/notes/create.blade.php`:**

???+examplelaravel "Formulario de Crear Nota"
    
    ``` 
    @extends('layouts.app')  
    
    @section('title', 'Crear Nueva Nota')  
    
    @section('content')
        <h2>Crear Nota</h2>
        <form action="{{ route('note.store') }}" method="POST">
        @csrf
            <label>Título:</label>         
            <input type="text" name="title" required>          
            
            <label>Descripción:</label>         
            <textarea name="description" required></textarea>          
            
            <label>Fecha:</label>         
            <input type="date" name="date" required>          
            
            <label>Completada:</label>         
            <input type="checkbox" name="done">          
            
            <button type="submit">Guardar</button>         
            
            <a href="{{ route('note.index') }}">Cancelar</a>     
        </form> 
    @endsection 
    ```

---

### Guardar la Nueva Nota

Al igual que en el caso anterior, para guardar la nota necesitamos dos cosas. Una ruta que maneje el envío del formulario y un método en el controlador que procese los datos y guarde la nota en la base de datos. Al final, redirigiremos a la lista de notas.

**Ruta para guardar:**

???+examplelaravel "Ruta para Guardar Nota"
    
    ``` 
    Route::post('/note/store', [NoteController::class, 'store'])->name('note.store'); 
    ```

**Controlador:**

Para guardar la nota, podemos usar diferentes métodos. Aquí mostramos dos formas:

???+examplelaravel "Guardar Nota"
    
    ``` 
    public function store(Request $request) {     
        $note = new Note();     
        $note->title = $request->input('title');     
        $note->description = $request->input('description');     
        $note->date = $request->input('date');     
        $note->done = $request->input('done') ? 1 : 0;     
        $note->save();     // Redirigir a la lista de notas     
        return redirect()->route('note.index'); 
    } 
    ```
    
    O usando el método `create`:
        
    ``` 
    public function store(Request $request) {     
        Note::create($request->all());     
        return redirect()->route('note.index'); 
    } 
    ```

**Explicaciones Adicionales:**

* `@csrf` protege contra ataques CSRF (Cross-Site Request Forgery).
* `$request->all()` devuelve todos los datos enviados en el formulario.
* Laravel valida automáticamente que el token CSRF esté presente. Si no lo está, lanzará un error.

¿Cómo funciona CSRF?

* Laravel genera un token único para cada sesión de usuario.
* Este token se incluye en cada formulario generado por Laravel.
* Cuando se envía el formulario, Laravel verifica que el token enviado coincida con el de la sesión.
* Si no coinciden, Laravel lanza un error 419 (Page Expired).
* Esto previene que un atacante envíe formularios en nombre del usuario sin su consentimiento.

---

### Editar una Nota

**Ruta para formulario de edición:**

???+examplelaravel "Ruta para Editar Nota"
    
    ```
    Route::get('/note/edit/{note}', [NoteController::class, 'edit'])->name('note.edit');
    ```

**Controlador:**

Tenemos varias formas de recibir el parámetro `note`. En esta primer recibimos el ID y buscamos la nota, para poder pasarla a la vista:

???+examplelaravel "método edit, para mostrar el formulario de edición"
    
    ``` 
    public function edit($id) {     
        $note = Note::findOrFail($id);     
        return view('notes.edit', compact('note')); 
    } 
    ```

En esta segunda forma, recibimos el modelo `Note`. De esta manera es Laravel el que se encarga de buscar la nota. Cuando trabajamos con modelos, esta es la forma recomendada:

???+examplelaravel "método edit, con inyección de modelo"
    
    ``` 
    public function edit(Note $note) {     
        return view('notes.edit', compact('note')); 
    } 
    ```

**Vista `resources/views/notes/edit.blade.php`:**

En este caso la ruta la hemos definido con el método `PUT`. Este método es el que se utiliza para actualizar los datos de un recurso existente. Pero ¿cómo hacerlo si las opciones de `form` solo permiten `GET` y `POST`?. Laravel nos ofrece una solución sencilla: la directiva `@method('PUT')`. Esta directiva simula el método PUT en formularios HTML. Esta directiva debe estar dentro del formulario y antes de los inputs.

???+examplelaravel "Editar Nota"
    
    ``` 
    <form id="sample-form" action="somepage.php" method="POST">     
    @csrf     
    @method('PUT')
        <!-- Otros campos del formulario --> 
    </form> 
    ```

Con este formato el formulario se enviará como un PUT, aunque el método del formulario sea POST.

???+examplelaravel "Formulario de Editar Nota"
    
    ``` 
    @extends('layouts.app')  
    
    @section('title', 'Editar Nota')  
    
    @section('content')     
        <h2>Editar Nota</h2>     
        <form action="{{ route('note.update', $note->id) }}" method="POST">         
        @csrf         
        @method('PUT')   
            
            <label>Título:</label>         
            <input type="text" name="title" value="{{ $note->title }}" required>          
            
            <label>Descripción:</label>         
            <textarea name="description" required>{{ $note->description }}</textarea>          
    
            <label>Fecha:</label>         
            <input type="date" name="date" value="{{ $note->date }}" required>          
        
            <label>Completada:</label>         
            <input type="checkbox" name="done" {{ $note->done ? 'checked' : '' }}>          
            
            <button type="submit">Actualizar</button>         
            <a href="{{ route('note.index') }}">Cancelar</a>     
        </form> 
    @endsection
    ```
    
    - `@method('PUT')` simula el método HTTP PUT en formularios HTML (que solo permiten GET y POST).

---

### Actualizar la Nota

**Ruta para actualizar:**

???+examplelaravel "Ruta para Actualizar Nota"
    
    ``` 
    Route::put('/note/update/{note}', [NoteController::class, 'update'])->name('note.update'); 
    ```

**Controlador:**

En este caso también tenemos dos formas de recibir el parámetro `Note $note`. En esta primer caso recibimos la *nota* y `laravel` por inyección de modelo la busca por nosotros y en el segundo caso recibimos el *ID* y buscamos la nota nosotros.

???+examplelaravel "método update, con inyección de modelo"
    
    ``` 
    public function update(Request $request, Note $note) {     
        $note->update($request->all());     
        return redirect()->route('note.index'); 
    } 
    ```

???+examplelaravel "método update, buscando por ID"
    
    ``` 
    public function update(Request $request, $id) {     
        $note = Note::findOrFail($id);     
        $note->update($request->all());     
        return redirect()->route('note.index'); 
    } 
    ```

---

### Mostrar una Nota Individual

**Ruta para mostrar:**

???+examplelaravel "Ruta para Mostrar Nota"
    
    ```
    Route::get('/note/show/{note}', [NoteController::class, 'show'])->name('note.show');
    ```

**Controlador:**

En este caso también tenemos dos formas de recibir el parámetro `Note $note`. En esta primer caso recibimos la *nota* y `laravel` por inyección de modelo la busca por nosotros y en el segundo caso recibimos el *ID* y buscamos la nota nosotros.

???+examplelaravel "método show, buscando por ID"
    
    ``` 
    public function show($id) {     
        $note = Note::findOrFail($id);     
        return view('notes.show', compact('note')); 
    } 
    ```

???+examplelaravel "método show, para mostrar una nota individual"
    
    ``` 
    public function show(Note $note) {     
        return view('notes.show', compact('note')); 
    } 
    ```

**Vista `resources/views/notes/show.blade.php` actualizada:**

???+examplelaravel "Mostrar Nota"
    
    ``` 
    @extends('layouts.app')  
    
    @section('title', 'Detalle de Nota')  
    
    @section('content')     
        <h2>{{ $note->title }}</h2>     
        
        <p>{{ $note->description }}</p>     
        <p>Fecha: {{ $note->date }}</p>     
        <p>Estado: {{ $note->done ? 'Completada' : 'Pendiente' }}</p>     
        <a href="{{ route('note.index') }}">Volver</a> 
    @endsection 
    ```

---

### Eliminar una Nota

**Ruta para eliminar:**

???+examplelaravel "Ruta para Eliminar Nota"
    
    ```
    Route::delete('/note/destroy/{note}', [NoteController::class, 'destroy'])->name('note.destroy');
    ```

**Controlador:**

Como en los casos anteriores, tenemos dos formas de recibir el parámetro `Note $note`. En esta primer caso recibimos la *nota* y `laravel` por inyección de modelo la busca por nosotros y en el segundo caso recibimos el *ID* y buscamos la nota nosotros.

???+examplelaravel "método destroy, buscando por ID"
    
    ``` 
    public function destroy($id) {     
        $note = Note::findOrFail($id);     
        $note->delete();     
        return redirect()->route('note.index'); 
    } 
    ```

???+examplelaravel "método destroy, para eliminar una nota"

    ``` 
    public function destroy(Note $note) {     
        $note->delete();     
        return redirect()->route('note.index'); 
    } 
    ```

  * El método `delete()` elimina el registro de la base de datos.

### Prueba completa del CRUD

Ahora vamos probar todas las funcionalidades del CRUD:

???+examplelaravel "Aspecto del ejemplo"
    
    Al no utilizar nada de CSS, el aspecto es muy básico. En un proyecto real, se debería aplicar estilos CSS para mejorar la apariencia y usabilidad.

1. **Listar Notas:** Accede a la ruta `/` para ver el listado de notas.

???+examplelaravel "imagen /"
    
    ![imagen /](../img/img02.png)
2. **Crear Nota:** Haz clic en "Crear Nota", rellena el formulario y envíalo.

Al hacer click en "Crear Nota" se accede a `/note/create`:

???+examplelaravel "imagen /note/create"
    
    ![imagen /](../img/img03.png)

   Una vez rellenado el formulario lo enviamos al servidor (ruta `/note/store`) y volvemos al listado de notas.

???+examplelaravel "imagen /"
    
    ![imagen /](../img/img04.png)

   Podemos ver la nota creada y como aparecen los enlaces para editar y eliminar.
3. **Editar Nota:** Haz clic en "Editar" junto a una nota, modifica los datos y envía el formulario.

   Al hacer click en "Editar" se accede a `/note/edit/{id}`:

???+examplelaravel "imagen /note/edit/1"
    
    ![imagen /](../img/img06.png)

   Una vez modificado el formulario lo enviamos al servidor (ruta `/note/update/{id}`) que actualiza la nota y nos redirecciona al listado de notas.

???+examplelaravel "imagen /"
    
    ![imagen /](../img/img07.png)
4. **Mostrar Nota:** Haz clic en el título de una nota para ver sus detalles.

   Al hacer click en el título de una nota se accede a `/note/show/{id}`:

???+examplelaravel "imagen /"
    
    ![imagen /](../img/img09.png)

???+examplelaravel "imagen /note/show/1"
    
    ![imagen /](../img/img10.png)

   Una vez vista pulsamos volver y nos redirecciona al listado de notas.
5. **Eliminar Nota:** Haz clic en "Eliminar" junto a una nota.
   Al hacer click en "Eliminar" se envía un formulario con método `DELETE` a la ruta `/note/destroy/{id}` que elimina la nota y nos redirecciona al listado de notas.

!!!warning "Confirmación de Eliminación"
    
    En un proyecto real, es recomendable añadir una confirmación antes de eliminar una nota para evitar eliminaciones accidentales.

???+examplelaravel "imagen /"
    
    ![imagen /](../img/img08.png)

### Tipado en los métodos del controlador

**Ejemplo de tipado correcto:**

``` 
public function update(Request $request, Note $note): RedirectResponse {     
   $note->update($request->all());     
   return redirect()->route('note.index'); 
} 
```

* Tipar los parámetros mejora la legibilidad y control de errores.
* Tipar el tipo de retorno ayuda a Laravel a validar internamente las respuestas.

???+tip "Tipos comunes de retorno"
       
    * `View` para devolver vistas. `use Illuminate\View\View`
    * `RedirectResponse` para redirecciones. `use Illuminate\Http\RedirectResponse`
    * `JsonResponse` para APIs. `use Illuminate\Http\JsonResponse`


---
???questionlaravel "Práctica a Entregar: Desarrollo de un CRUD de Productos en Laravel"
    
    ### Objetivo de la actividad
    
    <p style="float: left; margin-left: 1rem;">
        <img src="../../img/laravelactividad.png"
             alt="Actividad en el aula virtual"
             width="150">
    </p>
    
    El objetivo de esta práctica es aprender a **aplicar formularios, rutas, controladores y vistas** en Laravel para desarrollar un **CRUD completo para el recurso `Product`**.
    
    Con esta actividad, aprenderás a trabajar con el patrón **MVC (Modelo-Vista-Controlador)**, a gestionar datos con formularios y a usar las herramientas de Eloquent para crear, leer, actualizar y eliminar productos en la base de datos. Además, practicarás la implementación de vistas con **Blade** y el uso de rutas dinámicas.
    
    Al finalizar, deberás ser capaz de:
    
    * Crear y ejecutar migraciones para definir la estructura de una base de datos.
    * Implementar un controlador con todos los métodos CRUD.
    * Crear vistas Blade para presentar datos y manejar formularios.
    * Gestionar datos de entrada y salida mediante formularios, con las directivas `@csrf` y `@method`.
    
    ---
    
    ### Instrucciones
    
    Sigue los pasos a continuación. Verifica que todo funciona correctamente antes de pasar al siguiente paso.
    
    Si alguna parte del proceso no está clara, consulta la documentación oficial o busca ejemplos dentro del proyecto que has trabajado anteriormente.
    
    ---
    
    ### 1. Preparar el entorno
    
    1) **Accede a tu proyecto Laravel.**
    Si no tienes un proyecto en marcha, puedes usar el que creaste en la prueba anterior o crear uno nuevo con `composer create-project laravel/laravel nombre_del_proyecto` (por ejemplo nombre del proyecto `testear`).

    2) **Inicia el servidor.**
    Asegúrate de que tu servidor esté funcionando, inicia `docker compose up -d` (o si usas Laragon, arranca los servicios correspondientes a Ngingx y Mysql).

    3) **Crea una nueva migración y modelo para el recurso `Product`.**
    Utiliza el comando de Artisan para crear un modelo `Product` junto con su migración. Esto generará un archivo para crear la tabla de productos en la base de datos.

    > **Datos de prueba**: 
    > 
    > En los recursos de esta actividad hay un fichero [`products.sql`](../sources/products.sql){:target="blank"} con 15 productos ficticios para importar en la tabla `products`.
    
    ---
    
    ### 2. Crear la tabla y el modelo
    
    4) **Edita la migración de productos.**
    Abre el archivo de migración generado y define los siguientes campos para la tabla `products`. Estos campos incluyen el nombre del producto, una descripción, precio, stock y las fechas de creación/actualización automáticas.
    
    La estructura de la tabla deberá ser:
    
    | Campo | Tipo de dato | Restricciones / Descripción |
    | --- | --- | --- |
    | `id` | `bigIncrements` | Clave primaria, autoincremental |
    | `name` | `string(255)` | Nombre del producto, no nulo |
    | `description` | `text` | Descripción del producto |
    | `price` | `decimal(8,2)` | Precio del producto, no nulo |
    | `stock` | `integer` | Cantidad en stock, no nulo |
    | `created_at` | `timestamp` | Fecha de creación (automático) |
    | `updated_at` | `timestamp` | Fecha de actualización (automático) |
    
    5) **Ejecuta la migración**.
    Una vez hayas definido los campos, ejecuta la migración para crear la tabla en la base de datos.
    
    Usa el comando:
        
    ```
    php artisan migrate
    ```
    
    Verifica que la tabla se haya creado correctamente en la base de datos.
    
    6) **Configura el modelo `Product`.**
    En el archivo del modelo `Product`, debes definir las propiedades que permiten la asignación masiva de los campos. Esto se hace con la propiedad `$fillable`:
    
    ```
    protected $fillable = ['name', 'description', 'price', 'stock'];
    ```
    
    ---
    
    ### 3. Crear el controlador *resource*
    
    7) **Genera el controlador de recursos.**
    Utiliza Artisan para crear un controlador de recursos. Esto generará automáticamente los métodos necesarios para manejar las operaciones CRUD. Los métodos a implementar serán: `index`, `create`, `store`, `show`, `edit`, `update` y `destroy`.
    
    El comando es:
    
    ```
    php artisan make:controller ProductController --resource
    ```
    
    8) **Configura el controlador.**
    En el archivo generado `ProductController.php`, implementa la lógica necesaria para gestionar los productos. Recuerda que Laravel ya genera los métodos básicos (`index`, `create`, `store`, etc.), pero tendrás que completar la lógica específica de cada uno.
    
    - **`index`**: Muestra todos los productos.
    - **`create`**: Muestra el formulario para crear un nuevo producto.
    - **`store`**: Guarda el nuevo producto en la base de datos.
    - **`show`**: Muestra los detalles de un producto específico.
    - **`edit`**: Muestra el formulario para editar un producto.
    - **`update`**: Actualiza un producto existente en la base de datos.
    - **`destroy`**: Elimina un producto de la base de datos.
    
    ---
    
    ## 4. Definir las rutas
    
    9) **Declara las rutas necesarias para el CRUD.**
    En `routes/web.php`, añade la ruta de tipo *resource* para el controlador `ProductController`. Laravel generará automáticamente todas las rutas necesarias.
    
    Agrega esta línea:
    
    ```
    Route::resource('product', ProductController::class);
    ```
    
    Esto creará las rutas necesarias para manejar las operaciones CRUD para el recurso `Product`.
    
    10) **Verifica que las rutas se han registrado correctamente.**
    Usa el comando `php artisan route:list --path=product` para asegurarte de que las rutas están definidas correctamente.
    
    ---
    
    ## 5. Crear las vistas
    
    11) **Crea la carpeta para las vistas.**
    En `resources/views`, crea una nueva carpeta llamada `products`. En esta carpeta crearás las vistas para las operaciones CRUD.
    12) **Vistas necesarias**:
    Crea las siguientes vistas dentro de la carpeta `products/`:
    13) **`index.blade.php`**: Muestra todos los productos en una tabla. Esta vista debe listar todos los productos y permitir enlaces para crear, editar y eliminar productos.
    14) **`create.blade.php`**: Formulario para crear un nuevo producto.
    15) **`edit.blade.php`**: Formulario para editar un producto existente.
    16) **`show.blade.php`**: Muestra los detalles de un producto.
    
    ---
    
    ## 6. Probar el CRUD completo
    
    17) Accede a `/product` para ver el listado de productos.
    18) Crea un nuevo producto y verifica que aparece en el listado.
    19) Edita un producto y confirma que se actualiza correctamente.
    20) Muestra los detalles de un producto desde el enlace.
    21) Elimina un producto y asegúrate de que desaparezca del listado.
    
    ---
    
    ## 7. CSS (opcional)
    
    Puedes mejorar la apariencia de tu aplicación utilizando CSS (ejemplo de estilos: [`style1.css`](../sources/style1.css){:target="blank"}). Puedes crear un archivo CSS para la vista `index.blade.php` y otro para los formularios `create.blade.php`, `edit.blade.php` y `show.blade.php`. 

    > Recuerda:
    > 
    > Para mostrar archivos que tengamos en la carpeta `public`, crea (es conveniente) una carpeta dentro de nombre `assets/css` y aloja tu css allí mismo.
    > 
    > Además, en Laravel, podrás acceder a estos con la cláusula `asset{'assets/css/style1.css'}`.
    
    **Asegúrate de enlazar estos archivos CSS en las vistas correspondientes.**
    
    ---
    
    ## Entrega
    
    Sube a la plataforma de Aules:
    
    * **Código del controlador `ProductController`**.
    * **Vistas** completas para cada operación (index, create, edit, show).
    * **Capturas de pantalla** mostrando cada operación CRUD funcionando:
    
        + Listado de productos.
        + Formulario de creación de producto.
        + Formulario de edición de producto.
        + Vista de detalles del producto.
    
    * **Evidencia de que las operaciones CRUD funcionan correctamente**.