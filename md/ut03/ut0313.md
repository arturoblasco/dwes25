Desde PHP 5.3 y también conocidos como *Namespaces*, permiten organizar las clases, interfaces, funciones y constantes en un ámbito separado. Esto evita colisiones o conflictos de nombres entre distintos elementos, como ocurre en otros lenguajes (por ejemplo, los paquetes en Java).

## 1. Por qué usar `namespaces`

???+example "Ejemplo de por qué usar `namespaces`"
    Imagínate que tenemos el siguiente código:
    ```php
    <?php
        class Producto {
            public $nombre;
        }
    	
    	class Producto {
            public $nombre;
        }
    ```
    
    Este código daría error porque existen dos clases con el mismo nombre. Esto provoca un conflicto y PHP no sabe cuál de las dos clases utilizar.<br/><br/>
    Con `namespaces` el ejemplo anterior podría quedar:
    
    ```php
    <?php
        namespace Tienda\Alimentos;
        class Producto {
            public $nombre;
        }
    
        namespace Tienda\Electronica;
        class Producto {
            public $nombre;
        }
    ```
    Aquí, al estar en diferentes *namespaces*, ambas clases `Producto` pueden coexistir sin problemas.


Los *namespaces* permiten:

- Evitar conflictos de nombre al reutilizar librerías o frameworks.
- Mejorar la estructura y organización de tu código.
- Facilitar la colaboración en proyectos grandes.

!!! note "Recomendación"
	Mantén un solo *namespace* por archivo y organiza los archivos en una estructura de carpetas que refleje los diferentes niveles de los namespaces, similar a cómo se organizan los paquetes en Java.

## 2. Declaración de un namespace

Un *namespace* se declara en la primera línea del archivo usando la palabra clave `namespace` seguida del nombre del espacio de nombres. Los niveles de un *namespace* se separan con barras invertidas `\`.

???+example "Ejemplo `namespace`"
    En el siguiente ejemplo, la clase `Producto` y la constante `IVA` pertenecen al *namespace* `Dwes\Ejemplos`.

    ```php
    <?php
        namespace Dwes\Ejemplos;
        
        const IVA = 0.21;
    
        class Producto {
            public $nombre;
    
            public function muestra(): void {
                echo "<p>Producto: " . $this->nombre . "</p>";
            }
        }
    ```

## 3. Tipos de acceso a los recursos en namespaces

Para acceder a recursos dentro de un *namespace*, es necesario incluirlos primero en el archivo, usando `include` o `require`. Dependiendo de la ubicación del recurso, hay tres tipos de acceso:

- **Sin cualificar**: Se refiere directamente al recurso si está en el mismo *namespace*.

???+example "Ejemplo acceso sin cualificar"
	
    ```php
    <?php
    namespace MiNamespace;
    
    class MiClase {
        public function mostrar() {
            echo "Esto es MiClase";
        }
    }
    
    // Como MiClase está en el mismo namespace (MiNamespace),
    // puedo crear una instancia sin especificar el namespace completo.
    $miObjeto = new MiClase();  // Acceso sin cualificar
    $miObjeto->mostrar();
    ```

- **Cualificado**: Usa una ruta relativa dentro del mismo namespace o subnamespace (`rutaRelativa\recurso`)→ no hace falta poner el *namespace* completo.
???+example "Ejemplo acceso cualificado"
	
    ```php
    <?php
    namespace MiNamespace\SubNamespace;
  
    class ClaseSecundaria {
        public function mostrar() {
            echo "Esto es ClaseSecundaria en SubNamespace";
        }
    }
	
    namespace MiNamespace;
	
    class MiClase {
        public function mostrar() {
            echo "Esto es MiClase en MiNamespace";
        }
    }
	
    // Como ClaseSecundaria está en un subnamespace de MiNamespace,
    // puedo usar el nombre cualificado sin poner la barra inicial.
    $secundaria = new SubNamespace\ClaseSecundaria();  // Acceso cualificado
    $secundaria->mostrar();
    ```

- **Totalmente cualificado**: Usa la ruta completa desde la raíz del *namespace* ( `\rutaAbsoluta\recurso`)
	???+example "Ejemplo acceso totalmente cualificado"
	```php
    <?php
    namespace OtroNamespace;
	
    class ClaseExterna {
        public function mostrar() {
            echo "Esto es ClaseExterna en OtroNamespace";
        }
    }
	
    namespace MiNamespace;
	
    class MiClase {
        public function mostrar() {
            echo "Esto es MiClase en MiNamespace";
        }
    }
	
    // Como ClaseExterna está en un namespace completamente diferente,
    // necesitamos usar el namespace completo y comenzar con una barra invertida.
    $externa = new \OtroNamespace\ClaseExterna();  // Acceso totalmente cualificado
    $externa->mostrar();
	```

???example "Ejemplo de acceso"
	```php
    <?php
    namespace Dwes\Ejemplos;

    include_once("Producto.php");
    
    // acceso sin cualificar (está en el mismo namespace)
    echo IVA;   // imprime 0,21
    
    // acceso cualificado (error si Utilidades no existe)
    echo Utilidades\IVA;	   // Error, Utilidades no está definido
    
    // acceso totalmente cualificado
    echo \Dwes\Ejemplos\IVA; // Correcto
    
    $p1 = new Producto();
    // busca la clase en el mismo namespace y
    // encuentra \Dwes\Ejemplos\Producto
    
    $p2 = new Model\Producto();
    // daría error, no existe el namespace Model.
    // Está buscando \Dwes\Ejemplos\Model\Producto
    
    $p3 = new \Dwes\Ejemplos\Producto();
    // \Dwes\Ejemplos\Producto
    ```

### 3.1. Resumen de los Tipos de Acceso

| Tipo de Acceso             | Ejemplo de Uso                        | Descripción                                                  |
| -------------------------- | ------------------------------------- | ------------------------------------------------------------ |
| **Sin cualificar**         | `new MiClase();`                      | Se usa cuando el recurso está en el mismo *namespace*.       |
| **Cualificado**            | `new SubNamespace\ClaseSecundaria();` | Se usa una ruta **relativa** si el recurso está en un subnamespace o en el mismo *namespace*. |
| **Totalmente cualificado** | `new \OtroNamespace\ClaseExterna();`  | Se usa la **ruta completa** desde la raíz del *namespace*, con una barra inicial `\`. |



!!! note "Puedes echar un vistazo"
    [video](https://www.youtube.com/watch?v=zhSmZyMXYLk&list=PLZ2ovOgdI-kUSqWuyoGJMZL6xldXw6hIg&index=32){:target="_blank"}.



### 3.2. `use`

Para evitar la necesidad de escribir *rutas cualificadas* o *totalmente cualificadas* constantemente, PHP permite declarar el uso de recursos de otros *namespaces* mediante la palabra clave `use`, similar al `import` en Java.

### 3.3. Formas de utilizar `use`

- **Usar constantes**: `use const nombreCualificadoConstante`
- **Usar funciones**: `use function nombreCualificadoFuncion`
- **Usar clases**: `use nombreCualificadoClase`
- **Alias de la clase**: `use nombreCualificadoClase as NuevoNombre` (renombrar para evitar conflictos).

???+example "Ejemplo de `use`"
    Si queremos utilizar la clase `\Dwes\Ejemplos\Producto` en un archivo en la raíz, por ejemplo `inicio.php`, lo haríamos así:

    ```php
    <?php
        include_once("Dwes\Ejemplo\Producto.php");
    
        use const Dwes\Ejemplos\IVA;  // uso de constante
        use \Dwes\Ejemplos\Producto;  // uso de clase
    
        echo IVA;  // imprime 0,21
        $p1 = new Producto();  // no se necesita la ruta completa, gracias a `use`
    ```

???+example "Ejemplo de alias"
    ```php
    <?php
        use App\Modelos\Producto as ProductoAlimentos;
        use Tienda\Electronica\Producto as ProductoElectronico;

        $p1 = new ProductoAlimentos();
        $p2 = new ProductoElectronico();
    ```

!!! note "Uso de `use`"
    El uso de `use` solo es necesario para acceder a recursos que están en un *namespace* diferente. Si estás trabajando dentro del mismo *namespace*, no es necesario.

!!! note "Puedes echar un vistazo"
    [video](https://www.youtube.com/watch?v=lP1hbkNA2uc&list=PLZ2ovOgdI-kUSqWuyoGJMZL6xldXw6hIg&index=34){:target="_blank"}



## 4. Organización de proyectos con namespaces

A medida que un proyecto crece, es fundamental organizar el código fuente de forma estructurada. Una recomendación común es colocar los archivos que interactúan con el navegador en la raíz del proyecto y organizar las clases dentro de un namespace en una carpeta específica, como `src` o `app`.

<div style="text-align: center;"><img src="../../img/ut03/img02.png" style="max-width:100%;" /></div>

**Reglas de organización**:

1. **Un recurso por archivo**: Cada clase, función o constante debe estar en su propio archivo.
2. **Incluir namespaces**: Declara el namespace en la primera línea del archivo (si no está en el directorio raíz).
3. **Usar `include_once`**: Para cargar los recursos necesarios (clases, interfaces, etc.).
4. **Declarar dependencias**: Cada recurso debe incluir las dependencias que necesita, como clases base o interfaces.
5. **Uso de `use`**: Si el recurso está en un namespace diferente, utiliza `use` para facilitar el acceso sin cualificar.

???+example "Ejemplo de organización de archivos"
    ```sh
    /index.php
    /app/Modelos/Usuario.php
    /app/Modelos/Producto.php
    ```

Cada archivo debe incluir su *namespace* correspondiente:

???+example "Ejemplo de estructura"
	
    ```php
        <?php
        // /app/Modelos/Usuario.php			
        namespace App\Modelos;
    
        class Usuario {
            public $nombre;
        }
    ```
    
    ```php
        <?php
        // /app/Modelos/Producto.php
        namespace App\Modelos;
    
        class Producto {
            public $nombre
        }
    ```

???+example "Ejemplo de acceso a clases"
    ```php
    <?php
        include_once "app/Modelos/Usuario.php";
        include_once "app/Modelos/Producto.php";

        use App\Modelos\Usuario;
        use App\Modelos\Producto;
    
        $usuario = new Usuario();
        $producto = new Producto();
    ```



## 5. Autoload: carga automática de clases

Para evitar la necesidad de usar `include_once` o `require` en cada archivo, PHP ofrece el autoload, que permite cargar clases automáticamente cuando son necesarias. Esto se hace mediante la función `spl_autoload_register`.

???+example "Ejemplo de autoload"
    ```php
    <?php
        spl_autoload_register(function($nombreClase) {
            include_once $nombreClase . '.php';
        });

        $producto = new App\Modelos\Producto();  // Autocarga Producto.php
    ```

### 5.1. Organización con autoload

Y ¿cómo organizamos ahora nuestro código aprovechando el autoload?

<div style="text-align: center;"><figure><img src="../../img/ut03/img03.png" alt="img03" style="zoom:75%;" /><figcaption style="font-size: 13px; color: #bd8f04;">Ordenar clases en una carpeta (app).</figcaption></figure></div>

Una buena práctica es organizar todas las clases dentro de una carpeta como `app`. Luego, el autoload se configura para buscar clases dentro de esta carpeta:

???+example "Ejemplo de estructura de directorios"
    ```sh
    /index.php
    /app/Modelos/Usuario.php
    /app/Modelos/Producto.php
    /autoload.php
    ```
???+example "Ejemplo de autoload en el archivo  `autoload.php`"
    ```php
    <?php
        spl_autoload_register(function($nombreClase) {
            $ruta = __DIR__ . "/" . $nombreClase . '.php';
            $ruta = str_replace("\\", "/", $ruta);
            
            // Verifica si el archivo existe antes de incluirlo
            if (file_exists($ruta)) {
                include_once $ruta;
            } else {
                die("No se pudo cargar la clase: $nombreClase");
            }
        });
    ```


???+example "Ejemplo de uso de autoload en el archivo principal"
    ```php
    <?php
        // /index.php
        include_once "autoload.php";

        use App\Modelos\Producto;
        use App\Modelos\Usuario;
    
        $usuario = new Usuario();
        $producto = new Producto();
    ```


!!! note "Puedes echar un vistazo"
    Aquí encontramos un pequeño video en el que [https://www.youtube.com/watch?v=lP1hbkNA2uc](https://www.youtube.com/watch?v=lP1hbkNA2uc){:target="_blank"}.

