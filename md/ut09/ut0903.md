Las migraciones son un mecanismo de definición de datos ofrecido por *Laravel* para, a través de ciertas clases y opciones de configuración, generar la estructura completa de una base de datos. A su vez, suponen una especie de *control de versiones para una base de datos*, y permiten crear y modificar el esquema de la misma fácilmente.

## 3.1. Estructura de las migraciones

Por defecto, *Laravel* trae unas migraciones predefinidas, que se hallan en la carpeta **`database/migrations`**. Cada una tiene un nombre de archivo que comienza por la fecha en que se hizo, seguida de una breve descripción de lo que contiene (creación de la tabla de usuarios, reseteo de contraseñas…). Puede que algunas de estas migraciones no nos vayan a ser necesarias, con lo que podemos borrarlas directamente, y puede que otras (en especial la creación de la tabla de usuarios) sí nos sirva, pero con otros campos, con lo que deberemos editarla, como veremos a continuación.

Si examinamos el contenido de una migración, todas deben tener dos métodos:

- **`up`**: permite agregar tablas, columnas o índices a la base de datos.
- **`down`**: revierte lo hecho por el método anterior.

Si observamos el contenido de un método **`up`** de los que vienen predefinidos para crear una tabla, vemos que se utilizan distintos métodos para definir los tipos de datos de cada campo de la tabla, como por ejemplo **`id()`** para campos que puedan contener enteros autoincrementales, o **`string()`** para campos de tipo texto. Además, existen otros métodos modificadores para agregar propiedades adicionales, como por ejemplo **`unique()`** para indicar valores únicos (claves alternativas), o **`nullable()`** para indicar que un campo admite nulos.

???+ examplelaravel "Ejemplo de método `up`"
    ```php
    public function up()
    {
      Schema::create('usuarios', function(BluePrint $table) {
         $table->id();
         $table->string('nombre');
         $table->string('email')->unique();
         // ...
         $table->timestamps();
      });
    }
    ```

	Por defecto, como vemos en los ejemplos que se proporcionan, los esquemas se crean con un **id** autonumérico, y unos **timestamps** para indicar la fecha de creación y de modificación de cada registro, y que *Laravel* gestiona de forma automática cuando insertamos o actualizamos contenidos, lo cual resulta muy útil.

Sobre esta base, podemos añadir o quitar los campos que queramos. Para ver los tipos disponibles para las columnas de la tabla, podemos visitar la [documentación de Laravel sobre migraciones](https://laravel.com/docs/migrations){:target="_blank"}, en concreto buscaremos el subapartado *Available Column Types*. Conviene tener presente, por ejemplo, que el tipo `string` que hemos utilizado en el ejemplo anterior tiene una limitación de 255 caracteres. Para textos más grandes, se puede emplear el tipo `text` (20.000 caracteres aproximadamente) o `longText`.

Podemos especificar una clave primaria con el método `primary`, al que le podemos pasar o bien el nombre del campo clave, o un array de campos clave, en el caso de que ésta sea compuesta. Por defecto, los campos de tipo `id` se auto-establecen como claves primarias.

```bash
$table->primary(['campo1', 'campo2']);
```

## 3.2. Creación de migraciones

**a) Crear tablas**

Creamos migraciones con el comando:

```bash
php artisan make:migration nombre_migracion
```

Por ejemplo:

```bash
php artisan make:migration create_pruebas_table
```

Podemos observar que, en el nombre que se genera en la creación de la migración, *Laravel* ya asigna automáticamente la fecha de la migración, y "*solo*" debemos especificar el nombre descriptivo de la misma. Además, si *Laravel* detecta la palabra **`create`** en el nombre de la migración, finalizada en **`table`**, intuye que es para ==crear una tabla nueva==. En cambio, si detecta la palabra **`to`** (*entre otras*), y al final la palabra **`table`**, intuye que se va a ==alterar o modificar una tabla existente==. Esto es gracias a la clase **`TableGuesser`** incorporada en *Laravel*, que detecta ciertos patrones en los nombres de migraciones. La diferencia entre la creación y la modificación es que en el método `up` de la migración se utilizará `Schema::create` o `Schema::table` sobre la tabla en cuestión, respectivamente.

!!!note "nombre  de la migración para la creación de una tabla"
	Además del prefijo `create` y del sufijo `table`, el nombre "*central*" que deberá tomar la migración será el nombre de la tabla en PLURAL y, a ser posible, en inglés.<br /><br />
	Ejemplo:
	```bash
	php artisan make:migration create_products_table
	```

**Tipos de columnas y opciones comunes**

Para  definir los tipos de columnas y sus atributos *Laravel* proporciona un **(Fluent) constructor de esquemas**. Algunos más usados son:

- `id()`: es un alias del método `bigIncrements`. Por defecto, el método creará una columna `id`; sin embargo, se puede pasar un nombre de columna si se desea asignar un nombre diferente a la columna (  `$table->id('campo')` ).
- `string('titulo', 255)`: crea un `VARCHAR(255)`.
- `text('descripcion')`: crea un `TEXT`.
- `integer('stock')`: crea un `INT`.
- `boolean('is_published')`: crea un `TINYINT(1)`.
- `date('published_date')`: crea un `DATE`.
- `foreignId('usuario_id')->constrained()`: crea una columna `usuario_id` como llave foránea apuntando a la tabla `usuarios`.

Aquí podemos consultar el restos, [documentación oficial](https://laravel.com/docs/migrations#columns) (debemos tener en cuenta que en Laravel 11 se mantienen estos métodos con las mismas convenciones).

Además, se puede añadir atributos como:

- `nullable()`: permite valores `NULL`.
- `default('texto por defecto')`: asigna un valor por defecto.
- `unique()`: crea un índice único.
- `index()`: crea un índice básico.
- `after('campo')`: crea un campo después del indicado.

```php
<?php
	// ...
    Schema::create('posts', function (Blueprint $table) {
        $table->id();
        $table->string('titulo')->unique();
        $table->string('slug')->nullable()->index();
        $table->text('descripcion')->nullable();
        $table->integer('stock')->default(0);
        $table->timestamp('published_at')->nullable();
        $table->foreignId('user_id')->constrained()->onDelete('cascade');
        $table->timestamps();
    });
```

```bash
$table->string('isbn')->unique()->after('id');
```

**b) Añadir columnas en una tabla**

Para añadir una columna a una tabla existente en *Laravel* se debe hacer uso de migraciones. Para ello, primero se debe crear una nueva migración usando el comando `make:migration`.

```bash
php artisan make:migration add_estado_column_on_libros_table --table=libros
```

El comando anterior habrá creado un nuevo archivo de migración en el directorio `database/migrations `de nuestro proyecto:

```php
<?php

    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;

    return new class extends Migration
    {
        public function up(): void
        {
            Schema::table('libros', function (Blueprint $table) {
				$table->string('estado')->after('descripcion')->default('muy bueno');
            });
        }

        public function down(): void
        {
            Schema::table('libros', function (Blueprint $table) {
				$table->dropColumn('status');
            });
        }
    };
```

- El método `up `añadirá la columna `estado` de tipo `varchar `a la tabla *libros* después de la columna estado utilizando por defecto el valor *muy bueno*.
- El método `down `eliminará la columna cuando hagamos un *rollback*.

**c) Modificar columna en una tabla**

Para modificar una columna existente en una tabla en *Laravel* usando migraciones:

```bash
php artisan make:migration modify_estado_column_on_libros_table --table=users
```

Una vez creada la migración, podemos modificar la columna *estdo* haciendo que su longitud sea de *15*, en lugar de *255* que es el valor por defecto en *MySQL* utilizando el método `change`:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;


return new class extends Migration
{
    public function up(): void
    {
        Schema::table('libros', function (Blueprint $table) {
            $table->string('estado', 15)->change();
        });
    }


    public function down(): void
    {
        Schema::table('libros', function (Blueprint $table) {
            $table->string('estado')->change();
        });
    }
};
```

- El método `up` cambia la longitud a *15*.
- El método `down` volverá a dejar la longitud en *255*.

**d) Eliminar columna en una tabla**

El proceso para eliminar columnas utilizando migraciones en Laravel es el mismo, primero debemos crear una nueva migración usando el comando `make:migration`.

```bash
php artisan make:migration drop_status_column_on_users_table --table=users
```

Una vez tenemos nuestra migración, debemos definir los método up y down, veamos:

```php
<?php


use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;


return new class extends Migration
{
    public function up(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropColumn('status');
        });
    }


    public function down(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->string('status')->after('email')->default('active');
        });
    }
};
```



- El método `up` elimina la columna status.
- El método `down` vuelve a crear la columna status, es súper importante que la columna quede en el último estado que tenía.



!!!note "Crear la migración sin patrones"
	En cualquier caso, también podemos especificar un parámetro adicional en el comando de migración para indicar si queremos *crear* o *modificar* una tabla, y de este modo podemos definir el nombre de la migración en el idioma que queramos, y sin restricciones de patrones. Estas dos migraciones crean una tabla (*pedidos*) y modifican otra (*usuarios*), respectivamente:

    ```bash
    php artisan make:migration crear_tabla_pedidos --create=pedidos
    php artisan make:migration nuevo_campo_usuario --table=usuarios
    ```




### 3.2.1. Ejecución y borrado de migraciones

Para **ejecutar las migraciones** (el método `up` de cada una), lanzamos el siguiente comando desde la carpeta de nuestro proyecto (habiendo creado la base de datos ya previamente, y modificado las credenciales de acceso en el archivo `.env`):

```bash
php artisan migrate
```

Adicionalmente a las tablas afectadas, se tendrá otra tabla ==migrations== en la base de datos con un histórico de las migraciones realizadas. Para cada una, se almacena su *id* (autonumérico), el nombre de la migración, y el número de proceso por lotes en que se hizo (aquellas que compartan el mismo número se hicieron a la vez en el mismo lote). De este modo, aquellas que ya se hayan hecho no se volverán a realizar.

Para **deshacer las migraciones** realizadas (ejecutar el método `down` de las mismas), ejecutamos:

```bash
php artisan migrate:rollback
```

Esto eliminará TODAS las migraciones **del último lote** existente en la tabla `migrations`. Si no queremos deshacerlo todo, sino retroceder un número determinado de migraciones dentro de ese lote, ejecutamos el comando anterior con un parámetro `--step`, indicando el número de pasos o migraciones a deshacer (en orden cronológico de más reciente a más antigua):

```bash
php artisan migrate:rollback --step=2
```

Si volvemos a hacer la migración, se restablecerán las migraciones deshechas de ese lote.

Otro comando también muy utilizado es **`migrate:fresh`**. Lo que hace es **eliminar todas las migraciones realizadas y volverlas a lanzar**. Es útil cuando, estando en desarrollo, añadimos campos nuevos a alguna tabla y queremos rehacer las tablas completamente.

```bash
php artisan migrate:fresh
```

!!!warning "Ejecutar comando `migrate:fresh`"
	El comando `migrate:fresh` es DESTRUCTIVO, elimina los contenidos de las tablas, y sólo debe utilizarse en entornos de desarrollo, no de producción.

???+questionlaravel " Aplicando las migraciones a nuestro ejemplo biblioteca"
    Vamos a poner en práctica todo lo visto en este apartado sobre nuestro proyecto `biblioteca`:

    1. Anteriormente ya hemos comentado cómo modificar el archivo `.env` del proyecto para darle los parámetros de conexión correctos a la base de datos, y 
    
    2. cómo crear la base de datos “*biblioteca*” desde *phpMyAdmin*. Revisa ese apartado para hacer estos pasos, si no los has hecho ya.
    
    3. A continuación, vamos a eliminar las migraciones que no nos van a ser necesarias de la carpeta `database/migrations`. En concreto, borramos todas salvo la de creación de la tabla de usuarios `create_users_table`.
    
    4. Después, editamos la migración para la tabla de usuarios (`create_users_table`), ya que la utilizaremos en sesiones posteriores. Podemos renombrar el archivo a `crear_tabla_usuarios`. La clase interna en versiones recientes de Laravel no tiene nombre, se crea simplemente un subtipo de la clase *Migration*:
    
       ```bash
       // ...
    
       return new class extends Migration
       {
         // ...
       }
       ```
    
    !!!note " "
        En versiones anteriores donde sí tenga nombre, podemos reemplazar el nombre viejo (*CreateUsersTable*) por *CrearTablaUsuarios*, por ejemplo.
    
    La tabla a la que se alude en los métodos `up` y `down` también la renombramos a `usuarios`, para dejarlo en nuestro idioma (respetando la fecha de creación en el nombre del archivo), y después editamos el método `up` para dejarlo así:
    
    ```bash
    public function up()
    {
      Schema::create('usuarios', function(Blueprint $table) {
         $table->id();
         $table->string('login')->unique();
         $table->string('password');
         $table->timestamps();
      });
    }
    ```
    
    Ahora vamos a crear una nueva migración para definir la estructura de los libros:
    
    ```bash
    php artisan make:migration crear_tabla_libros --create=libros
    ```
    
    Editamos después el contenido de esta migración, en concreto el método `up` para definir estos campos en los libros:
    
    ```bash
    bpublic function up()
    {
      Schema::create('libros', function(Blueprint $table) {
         $table->id();
         $table->string('titulo');
         $table->string('editorial')->nullable();
         $table->float('precio');
         $table->timestamps();
      });
    }
    ```
    
    Cargamos las migraciones con el comando:
    
    ```bash
    php artisan migrate
    ```
    
    Tras esto, ya deberíamos ver en nuestra base de datos “*biblioteca*” las dos tablas creadas (*usuarios* y *libros*), junto con la tabla *migrations* que crea Laravel para gestionar las migraciones realizadas.

### 3.2.2. Aparación de la tabla personal_access_tokens
Si, además de las tablas anteriores, aparece una tabla de **personal_access_tokens** (ésta la crea automáticamente el paquete *Sanctum*) incorporada por defecto en *Laravel*.<br/>Esta tabla no molesta para lo que vamos a hacer durante estas unidades, pero si se quiere quitar, hay que editar el archivo `app\Providers\AppServiceProvider.php` y añadir esta línea en el método `register` (junto con el correspondiente `use` para la clase `Sanctum`):

```bash
// ...
use Laravel\Sanctum\Sanctum;

class AppServiceProvider ...
{
  // ...
  public function register()
  {
      Sanctum::ignoreMigrations();
  }
  // ...
}
```
Después, lanzamos `php artisan migrate:fresh` para ejecutar desde cero las migraciones, y esa tabla habrá desaparecido.

??? questionlaravel "Ejercicios a realizar"
	-  `Ejercicio 1`.<br />
	-  `Ejercicio 2`.
