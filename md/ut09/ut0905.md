En esta sesión veremos qué tipos de relaciones se pueden establecer entre los modelos de la aplicación, y cómo se reflejan automáticamente en la base de datos. Para ello, Eloquent permite definir relaciones de varios tipos entre tablas. Éstas se definen a través de los distintos modelos involucrados en la relación, como veremos a continuación.

## 5.1. Relaciones uno a uno ( *one to one* )

Supongamos que tenemos dos modelos `Usuario` y `Telefono`, de modo que podemos establecer una relación *uno a uno* entre ellos: un *usuario* tiene un *teléfono*, y un *teléfono* pertenece a un *usuario*.

Para reflejar esta relación en tablas, una de las dos debería tener una referencia a la otra. En este caso, podríamos tener un campo `telefono_id` en la tabla de `usuarios` que indique el teléfono que pertenece a dicho usuario, o viceversa (un campo `usuario_id` en la tabla `telefonos` que indique a qué usuario pertenece un teléfono). Conceptualmente es más correcta la primera opción (el usuario *tiene* el teléfono), así que seguiremos ese primer ejemplo. Es importante que el campo nuevo en la tabla `usuarios` se llame `telefono_id`, como veremos a continuación.

Para indicar que *un usuario tiene un teléfono*, añadimos un nuevo método en el modelo de `Usuario`, que se llame igual que el modelo con el que queremos conectar (`telefono`, en este caso). Dentro, usaremos el método **`hasOne`** del modelo de usuario para indicar que un objeto de este tipo *tiene un* objeto del otro modelo (teléfono):

```bash
class Usuario extends Model
{
  public function telefono()
  {
     return $this->hasOne(Telefono::class);
  }
}
```

Ahora, si queremos obtener el teléfono de un usuario, basta con que hagamos esto:

```bash
$telefono = Usuario::findOrFail($id)->telefono;
```

Hemos empleado una característica de *Eloquent* denominada **propiedades dinámicas**, por la cual podemos referenciar un método de relación como si fuera una propiedad (==en lugar de usar *telefono()*, hemos empleado *telefono*==).

La instrucción anterior obtiene el objeto `Telefono` asociado con el usuario buscado (a través del `$id` del teléfono). Para que esta asociación tenga efecto, es preciso que en la tabla `usuarios` exista un campo `telefono_id` y que se corresponda con un campo `id` de la tabla de `telefonos`, de modo que *Eloquent* establece la conexión entre una y otra tabla. Deberemos definir una nueva migración de modificación sobre la tabla *usuarios* para añadir ese nuevo campo, o refrescar la migración original con él y borrar los contenidos previos.

Si queremos utilizar otros campos distintos en una y otra tabla para conectarlas, debemos indicar dos parámetros más al llamar a `hasOne`. Por ejemplo, así relacionaríamos las dos tablas anteriores, indicando que la clave ajena de `usuarios` a `telefonos` es `idTelefono`, y que la clave primaria de `telefonos` a la que se referencia es `codigo`:

```bash
return $this->hasOne(Telefono::class, 'idTelefono', 'codigo');
```

También es posible obtener la **relación inversa**, es decir, a partir de un teléfono, obtener el usuario al que pertenece. Para ello, añadimos un método `usuario` en el modelo `Telefono` y empleamos el método **`belongsTo`** para indicar a qué modelo se asocia:

```bash
class Telefono extends Model
{
  public function usuario()
  {
     return $this->belongsTo(Usuario::class);
  }
}
```

Nuevamente, podemos especificar otros nombres de clave pasando parámetros adicionales a `belongsTo`, igual que se hace para `hasOne`.

De este modo, si queremos obtener el usuario a partir del teléfono, podemos hacerlo así:

```bash
$usuario = Telefono::findOrFail($idTelefono)->usuario;
```

### 5.1.1. Guardar datos relacionados

Supongamos que queremos guardar un usuario con su teléfono asociado. Podemos simplemente guardar el *id* del teléfono como un campo más del usuario:

```bash
// Buscamos el teléfono que queremos asociar
// (suponiendo que existe previamente)
$telefono = Telefono::findOrFail($idTelefono);
$usuario = new Usuario();
$usuario->nombre = "Pepe";
$usuario->email = "pepe@gmail.com";
$usuario->telefono_id = $telefono->id;
$usuario->save();
```

Pero, además, podemos vincular ambos objetos en la relación, usando el método **`associate`**, de este modo:

```bash
// Buscamos el teléfono que queremos asociar
// (suponiendo que existe previamente)
$telefono = Telefono::findOrFail($idTelefono);
$usuario = new Usuario();
$usuario->nombre = "Pepe";
$usuario->email = "pepe@gmail.com";
$usuario->telefono()->associate($telefono);
$usuario->save();
```

## 5.2. Relaciones uno a muchos ( *one to many* )

Para ilustrar esta relación veamos otro ejemplo: supongamos que tenemos los modelos `Autor` y `Libro`, de modo que un autor puede tener varios libros, y un libro está asociado a un autor.

La forma de establecer la relación entre ambos consistirá en añadir en la tabla de `libros` una clave ajena al autor al que pertenece. A la hora de plasmar esta relación en los modelos, se hace de forma similar al caso anterior, sólo que en lugar de utilizar el método `hasOne` en la clase `Autor` usaríamos el método **`hasMany`**:

```bash
class Autor extends Model
{
  public function libros()
  {
     return $this->hasMany(Libro::class);
  }
}
```

Igual que ocurría antes, se asume que la tabla de libros tiene una clave primaria `id`, y que la clave ajena correspondiente hacia la tabla de autores es `autor_id`. De lo contrario, se pueden especificar otros pasando más parámetros a `hasMany`.

De este modo obtenemos los libros asociados a un autor:

```bash
$libros = Autor::findOrFail($id)->libros
```

Finalmente, también podemos establecer la **relación inversa**, y recuperar el autor al que pertenece un determinado libro, definiendo un método en la clase `Libro` que emplee **`belongsTo`**, como en las relaciones uno a uno:

```bash
class Libro extends Model
{
  public function autor()
  {
     return $this->belongsTo(Autor::class);
  }
}
```

Y obtener, por ejemplo, el nombre del autor a partir del libro:

```bash
$nombreAutor = Libro::findOrFail($id)->autor->nombre;
```

???+ "Aplicando esta relación en nuestro ejemplo"
    Esta relación la podemos dejar plasmada en nuestro ejemplo de la *biblioteca*, definiendo un nuevo modelo `Autor` con su correspondiente migración, y relacionando los modelos. Para ello, seguiremos estos pasos:

    &nbsp;&nbsp;&nbsp;&nbsp;1. Creamos una nueva migración de modificación sobre la tabla de *libros*, para añadir un nuevo campo `autor_id`.
    
    ```bash
    php artisan make:migration nuevo_campo_autor_libros --table=libros
    ```
    
    ```bash
    class NuevoCampoAutorLibros extends Migration
    {
      public function up()
      {
         Schema::table('libros', function(Blueprint $table) {
             $table->integer('autor_id');
         });
      }
    
      public function down()
      {
         Schema::table('libros', function(Blueprint $table) {
             $table->dropColumn('autor_id');
         });
      }
    }
    ```
    
    ```bash
    php artisan migrate
    ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;2. Creamos de golpe el modelo, la migración y el controlador de autores (aunque el controlador no lo vamos a utilizar, al menos por el momento). El modelo `Autor` debe quedar en la carpeta `app\Models`, junto con el de usuarios y el de libros.
    
    ```bash
    php artisan make:model Autor -mcr
    ```
    
    !!!warning " "
        En este punto, deberás renombrar a mano la migración, ya que el plural que asignará *Laravel* por defecto será *autors*, y no *autores*. Recuerda cambiar tanto el nombre del fichero de la migración, como el nombre de la tabla a la que se referencia en los métodos `up` y `down`.
    
        - Editamos la migración para definir los campos que tendrá la nueva tabla de autores, en su método `up`: un nombre y un año de nacimiento (opcional):
    
        ```bash
        return new class extends Migration
        {
          public function up()
          {
             Schema::create('autores', function(Blueprint $table) {
                 $table->id();
                 $table->string('nombre');
                 $table->integer('nacimiento')->nullable();
                 $table->timestamps();
             });
          }
        }
        ```
    	```bash
    	php artisan migrate
    	```
        - Añadimos en el modelo `Autor` que la tabla asociada será `autores` (de lo contrario, considera que será *autors*. Además, definimos una relación de uno a muchos con los libros, añadiendo el método siguiente:
    
        ```bash
        class Autor extends Model
        {
          protected $table = 'autores';
          // ...
    
          public function libros()
          {
             return $this->hasMany(Libro::class);
          }
        }
        ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;3. Recíprocamente, añadimos al modelo `Libro` este otro método, para poder recuperar un autor a partir de uno de sus libros:
    
    ```bash
    class Libro extends Model
    {
      // ...
    
      public function autor()
      {
         return $this->belongsTo(Autor::class);
      }
    }
    ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;4. Utilizando *phpMyAdmin*, creamos a mano un par de autores en la tabla de autores, y los relacionamos con algunos de los libros que haya en la tabla de libros, añadiendo también a mano el *id* de cada autor en la clave ajena correspondiente de los libros. Por ejemplo:
    
    <div style="text-align: center;"><figure><img src="../../img/ut09/tabla_autores.png" alt="tabla autores" style="zoom:70%; border: 2px solid #fff2c9;" /><figcaption style="font-size: 13px; color: #bd8f04;">Tuplas de la tabla autores (modelo Autor).</figcaption></figure></div>
    
    <div style="text-align: center;"><figure><img src="../../img/ut09/tabla_libros.png" alt="tabla libros" style="zoom:70%; border: 2px solid #fff2c9;" /><figcaption style="font-size: 13px; color: #bd8f04;">Tuplas de la tabla libros (modelo Libro).</figcaption></figure></div>
    
    &nbsp;&nbsp;&nbsp;&nbsp;5. Para probar cómo funcionan las relaciones, vamos primero a crear un nuevo libro asociado al autor 1. Definimos una ruta de prueba en el archivo `routes/web.php` con este código (deberemos incorporar con `use` los modelos de `Autor` y `Libro`):
    
    ```bash
    Route::get('relacionPrueba', function() {
        $autor = Autor::findOrFail(1);
        $libro = new Libro();
        $libro->titulo = "Libro de prueba " . rand();
        $libro->editorial = "Editorial de prueba";
        $libro->precio = 5;
        $libro->autor()->associate($autor);
        $libro->save();
    
        return redirect()->route('libros.index');
    });
    ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;6. Ahora, modificamos la vista `libros/index.blade.php` para que, en el listado, utilice las relaciones entre tablas para mostrar el nombre del autor entre paréntesis junto al título de cada libro:
    
    ```bash
    @forelse($libros as $libro)
        <li><a href="{{ route('libros.show', $libro) }}">
            {{ $libro->titulo }} ({{ $libro->autor->nombre }})
        </a></li>
    @empty
        <li>No se encontraron libros</li>
    @endforelse
    ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;7. Podemos probar las dos cosas accediendo respectivamente a estas dos URLs (suponiendo que el servidor está escuchando en *localhost* por el puerto 8000):
    
    ```bash
    http://localhost:8000/relacionPrueba
    http://localhost:8000/libros
    ```

### 5.2.2. Acceso eficiente a datos relacionados. *Eager loading*

En el ejemplo anterior, hemos visto cómo, dado un libro, podemos obtener el nombre del autor de este modo en una vista *Blade*:

```bash
{{ $libro->autor->nombre }}
```

Sin embargo, este código provoca una nueva consulta en la base de datos para buscar los datos del autor asociado al libro, con lo que, para un listado de 100 libros, estaremos haciendo 100 consultas adicionales para extraer la información de los respectivos autores.

Para evitar esta sobrecarga, podemos emplear una técnica llamada **eager loading** (que en español podríamos traducir como *carga apresurada* o *impaciente*). Consiste en emplear el método `with` para indicar qué relación queremos dejar precargada en el resultado. Por ejemplo, si indicamos algo así en la función `index` del controlador de libros:

```bash
public function index()
{
    $libros = Libro::with('autor')->get();
    return view('libros.index', compact('libros'));
}
```

## 5.3. Relaciones muchos a muchos ( *many to many* )

Estas relaciones son más difíciles de plasmar, ya que es necesario contar con una tercera tabla que relacione las dos tablas afectadas. Pero vayamos por partes…

Para ilustrar este caso, supongamos los modelos `Usuario` y `Rol`, de modo que un usuario puede tener varios roles, y un rol puede ser asignado a varios usuarios. Nuevamente, definimos un método en el modelo `Usuario` que utilice el método **`belongsToMany`** para indicar con qué otro modelo se relaciona:

```bash
class Usuario extends Model
{
  public function roles()
  {
     return $this->belongsToMany(Rol::class);
  }
}
```

Así ya podremos acceder a los roles de un usuario:

```bash
$roles = Usuario::findOrFail($id)->roles;
```

En este caso, al otro lado de la relación hacemos lo mismo: definimos un método en el modelo `Rol` que indique con `belongsToMany` que puede pertenecer a varios usuarios:

```bash
class Rol extends Model
{
  public function usuarios()
  {
     return $this->belongsToMany(Usuario::class);
  }
}
```

A efectos de automatización, es decir, para que *Eloquent* establezca los nexos de forma automática, si queremos establecer una relación muchos a muchos entre un modelo `A` y otro `B`, se asume que existirá otra tabla `a_b` (el orden en que se colocan los nombres de las tablas es alfabético), con los campos `a_id` y `b_id`, que relacionen los dos modelos. En nuetro caso, se asumirá que existe una tabla `rol_usuario` con un campo `rol_id` y otro llamado `usuario_id`, que enlacen con los correspondientes `id` de las tablas de usuarios y roles. Si esto no fuera así, podemos pasar más parámetros a `belongsToMany` para indicarlo.

En el caso de las relaciones muchos a muchos, es posible que nos interese acceder a algún dato de esa tabla intermedia que los relaciona. En ese caso, hacemos uso del atributo **`pivot`**, predefinido, y que apunta a la tabla o modelo intermedio entre los dos relacionados. Por ejemplo, si quisiéramos obtener la fecha de creación de la relación entre un usuario y un rol, podríamos hacer esto:

```bash
$roles = Usuario::findOrFail($id)->roles;

for($roles as $rol)
{
  echo $rol->pivot->created_at;
}
```

???questionlaravel "Ejemplo `usuarios`-`roles`"
    ### 1. Migraciones
​    Se necesitan tres tablas:<br />
    - `usuarios`<br />
        - `roles`<br />
        - `rol_usuario` (tabla intermedia para la relación muchos a muchos)<br /><br />
        **Migración para la tabla `usuarios`**<br />
        ```bash
        use Illuminate\Database\Migrations\Migration;
        use Illuminate\Database\Schema\Blueprint;
        use Illuminate\Support\Facades\Schema;

        class CreateUsuariosTable extends Migration
        {
            public function up()
            {
                Schema::create('usuarios', function (Blueprint $table) {
                    $table->id();
                    $table->string('nombre');
                    $table->string('email')->unique();
                    $table->timestamps();
                });
            }
    
            public function down()
            {
                Schema::dropIfExists('usuarios');
            }
        }
        ```
    **Migración para la tabla `roles`**
    ```bash
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    class CreateRolesTable extends Migration
    {
        public function up()
        {
            Schema::create('roles', function (Blueprint $table) {
                $table->id();
                $table->string('nombre');
                $table->timestamps();
            });
        }
    
        public function down()
        {
            Schema::dropIfExists('roles');
        }
    }
    ```
    **Migración para la tabla `rol_usuario` (tabla intermedia)**
    ```bash
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    class CreateRolUsuarioTable extends Migration
    {
        public function up()
        {
            Schema::create('rol_usuario', function (Blueprint $table) {
                $table->id();
                $table->foreignId('usuario_id')->constrained('usuarios')->onDelete('cascade');
                $table->foreignId('rol_id')->constrained('roles')->onDelete('cascade');
                $table->timestamps();
            });
        }
    
        public function down()
        {
            Schema::dropIfExists('rol_usuario');
        }
    }
    ```
    ### 2. Modelos
    **Modelo `Usuario`**
    ```bash
    namespace App\Models;
    
    use Illuminate\Database\Eloquent\Model;
    
    class Usuario extends Model
    {
        protected $fillable = ['nombre', 'email'];
    
        public function roles()
        {
            return $this->belongsToMany(Rol::class, 'rol_usuario', 'usuario_id', 'rol_id')->withTimestamps();
        }
    }
    ```
    **Modelo `Rol`**
    ```bash
    namespace App\Models;
    
    use Illuminate\Database\Eloquent\Model;
    
    class Rol extends Model
    {
        protected $fillable = ['nombre'];
    
        public function usuarios()
        {
            return $this->belongsToMany(Usuario::class, 'rol_usuario', 'rol_id', 'usuario_id')->withTimestamps();
        }
    }
    ```
    ### 3. Uso en Controladores o Seeders
    **Insertar usuarios y roles y relacionarlos**
    ```bash
    use App\Models\Usuario;
    use App\Models\Rol;
    
    // Crear usuarios
    $usuario1 = Usuario::create(['nombre' => 'Juan', 'email' => 'juan@example.com']);
    $usuario2 = Usuario::create(['nombre' => 'Maria', 'email' => 'maria@example.com']);
    
    // Crear roles
    $admin = Rol::create(['nombre' => 'Administrador']);
    $editor = Rol::create(['nombre' => 'Editor']);
    
    // Asignar roles a usuarios (relación muchos a muchos)
    $usuario1->roles()->attach([$admin->id, $editor->id]); // Juan es Administrador y Editor
    $usuario2->roles()->attach([$editor->id]); // Maria es solo Editor
    ```
    **Consultar los roles de un usuario**
    ```bash
    $usuario = Usuario::find(1);
    
    foreach ($usuario->roles as $rol) {
        echo "El usuario {$usuario->nombre} tiene el rol: {$rol->nombre} <br>";
    }
    ```
    **Consultar los usuarios con un rol específico**
    ```bash
    $rol = Rol::where('nombre', 'Administrador')->first();
    
    foreach ($rol->usuarios as $usuario) {
        echo "El usuario {$usuario->nombre} es Administrador <br>";
    }
    ```
    **Eliminar una relación**
    ```bash
    $usuario = Usuario::find(1);
    $usuario->roles()->detach($admin->id); // Quita el rol de Administrador al usuario Juan
    ```
    ### 4. Acceder a Datos de la Tabla Pivot
    Si queremos obtener la fecha de asignación de un rol a un usuario:
    ```bash
    $usuario = Usuario::find(1);
    
    foreach ($usuario->roles as $rol) {
        echo "Rol: {$rol->nombre} - Asignado el: {$rol->pivot->created_at} <br>";
    }
    ```
    ### 5. Conclusión
    Esta implementación de relaciones muchos a muchos en Laravel permite asignar múltiples roles a un usuario y múltiples usuarios a un rol. La tabla intermedia rol_usuario maneja la relación sin necesidad de un modelo explícito, y pivot nos permite acceder a metadatos como la fecha de asignación.


## 5.4. Más información

Sobre estas relaciones existen algunas variantes, y formas de personalizar las tablas y campos afectados. Se puede consultar más información en la [documentación oficial de Eloquent](https://laravel.com/docs/eloquent-relationships#defining-relationships){:target="_blank"}.

??? questionlaravel "Ejercicios"
	Realizar `ejercicio 3`.