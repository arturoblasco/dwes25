# 3.2. Eloquent ORM

Una vez que se ha establecido la estructura de la base de datos con migraciones, el siguiente paso es interactuar con los datos almacenados. Aquí es donde entra en juego Eloquent ORM, el sistema de mapeo objeto-relacional (ORM) de Laravel.

## 2.1. ¿Qué es un ORM?

**ORM** (Object-Relational Mapping) es una técnica de programación que permite mapear objetos de un lenguaje de programación a tablas de una base de datos relacional. Facilita la interacción con la base de datos usando objetos en lugar de SQL directo.

## 2.2. ¿Qué es Eloquent?

**Eloquent** es el ORM incluido en Laravel que facilita la interacción con la base de datos usando modelos PHP. Cada modelo representa una tabla de la base de datos y permite realizar operaciones de manera intuitiva.

```php
// En lugar de escribir SQL:
// SELECT * FROM products WHERE category_id = 1

// Con Eloquent escribes:
$products = Product::where('category_id', 1)->get();
```

## 2.3. Creando modelos Eloquent

Para empezar a usar Eloquent, primero se crean modelos que representan las tablas de la base de datos.

Cada tabla tiene un modelo correspondiente, que es una clase PHP que extiende `Illuminate\Database\Eloquent\Model`. Este modelo contiene la lógica para interactuar con esa tabla específica.

> Las tablas pivote no tienen un modelo propio, sino que se manejan a través de las relaciones definidas en los modelos principales.

**Excepción: La Agregación**

Es posible definir una tabla pivote con un modelo propio si encuentras una agregación. La agregación se utiliza cuando la relación (la tabla pivote) necesita participar en otra relación con una tercera entidad.

Por ejemplo, si tienes una tabla pivote `product_user` para la relación muchos a muchos entre `products` y `users`, pero además supongamos que la plataforma necesita que un Agente de Soporte `agents` revise y verifique ciertos productos del usuario para sacar estadísticas o ofrecerle mejores recomendaciones.

El agente de soporte no está verificando al usuario por un lado y al producto por otro. Está verificando la relación que une al usuario y al producto (la tabla pivote), por lo que en este caso sí tendría sentido crear un modelo `ProductUser` para manejar esa lógica adicional.

### 2.3.1. Comando para crear modelos

```bash
# crear un modelo básico
sail artisan make:model Product
```

**Opciones útiles del comando**

Puedes combinar varias opciones al crear un modelo. 

-  `-m` (crea también la migración)
-  `-s` (crea también el seeder)
-  `-c` (crea también el controlador)

Puedes crear todo lo necesario para un modelo de una sola vez:

```bash
# crear modelo con migración, seeder y controlador
sail artisan make:model Product -msc
```

### 2.3.2. Estructura básica de un modelo

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Product extends Model
{
    use HasFactory;

    // El modelo está listo para usar
}
```

## 2.4. Configuración de modelos

Los modelos Eloquent pueden configurarse para adaptarse a las convenciones de la base de datos o a necesidades específicas del proyecto.

### 2.4.1. Propiedades básicas

Por defecto, Eloquent asume ciertas convenciones, pero estas pueden ser personalizadas:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Product extends Model
{
    use HasFactory;

    // Nombre de la tabla (opcional si sigue convenciones)
    protected $table = 'products';

    // Clave primaria (opcional si es 'id')
    protected $primaryKey = 'id';

    // Tipo de clave primaria
    protected $keyType = 'int';

    // Si la clave primaria es auto-incremental
    public $incrementing = true;

    // Campos que se pueden asignar masivamente
    protected $fillable = [
        'name',
        'description',
        'price',
        'category_id'
    ];

    // Campos que NO se pueden asignar masivamente
    protected $guarded = [
        'id',
        'created_at',
        'updated_at'
    ];

    // Campos que deben ser tratados como fechas
    protected $dates = [
        'created_at',
        'updated_at',
        'deleted_at'
    ];
}
```

### 2.4.2. Fillable vs Guarded

La asignación masiva (Mass Assignment) permite crear o actualizar modelos usando arrays de datos. Para proteger contra asignaciones no autorizadas, se usan las propiedades `$fillable` y `$guarded`.

La propiedad **`$fillable`** define qué campos pueden ser asignados masivamente, mientras que **`$guarded`** define qué campos no pueden ser asignados. **Solo se necesita usar una de las dos**.

```php
// Opción 1: Usar fillable (recomendado)
protected $fillable = [
    'name',
    'description',
    'price'
];

// Opción 2: Usar guarded
protected $guarded = [
    'id',
    'created_at',
    'updated_at'
];

// Opción 3: Guarded vacío (permite todo excepto id, timestamps)
protected $guarded = [];
```

**Seguridad con Mass Assignment**

**Siempre** define `$fillable` o `$guarded` para proteger contra asignación masiva no autorizada. Esto previene que usuarios maliciosos modifiquen campos sensibles.

## 2.5. Accessors y Mutators: transformando datos

Los **accessors** y **mutators** son características de Eloquent que permiten transformar datos automáticamente cuando se leen o escriben en el modelo, manteniendo la lógica de negocio dentro del modelo (principio "*Fat Models, Skinny Controller*s").


¡Los accessors y mutators son tus traductores automáticos que mantienen los datos limpios en la base de datos pero los presentan elegantemente al usuario!

### 2.5.1. Accessors: Transformar datos al leerlos

Un **accessor** es un método que transforma un atributo del modelo cuando se accede a él. Se utiliza para formatear, calcular o modificar datos antes de mostrarlos.

**Sintaxis en Laravel 11+:**

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Casts\Attribute;

class Product extends Model
{
    /**
     * Get the product's final price after applying discounts.
     */
    protected function finalPrice(): Attribute
    {
        return Attribute::make(
            get: function () {
                if ($this->offer && $this->offer->discount_percentage > 0) {
                    $discount = $this->price * ($this->offer->discount_percentage / 100);
                    return round($this->price - $discount, 2);
                }
                return $this->price;
            },
        );
    }
}
```

**Uso del Accessor:**

```php
// En el controlador
$product = Product::with('offer')->find(1);
echo $product->final_price;  // 799.99 (calculado automáticamente)
```

```php
// Base de datos: "1234567890"
echo $user->phone;  // Muestra: "+34 123 456 7890"
```

### 2.5.2. Mutators: Transformar datos al escribirlos

Un **mutator** es un método que transforma un atributo del modelo cuando se asigna un valor. Se utiliza para normalizar, limpiar o procesar datos antes de guardarlos en la base de datos.

**Sintaxis en Laravel 11+:**

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Support\Str;

class Product extends Model
{
    /**
     * Get/Set the product's name.
     */
    protected function name(): Attribute
    {
        return Attribute::make(
            get: fn ($value) => ucfirst($value),     // Capitalizar al leer
            set: fn ($value) => strtolower($value),  // Minúsculas al escribir
        );
    }
}
```

**Uso del Mutator:**

```php
// Al escribir
$product = new Product();
$product->name = 'iPHONE 15 PRO';  // Escribes en mayúsculas
$product->save();

// En la base de datos se guarda: "iphone 15 pro" (minúsculas)

// Al leer
echo $product->name;  // Muestra: "Iphone 15 pro" (primera letra mayúscula)
```


```php
$user->email = "GUILLERMO@EXAMPLE.COM";  // Escribes en mayúsculas
// Base de datos guarda: "guillermo@example.com" ✨
```


> **Nota sobre rendimiento**
> 
> Los accessors se ejecutan cada vez que accedes al atributo. Si tienes un accessor costoso y lo usas en un bucle con muchos registros, puede afectar el rendimiento. En esos casos, considera:
> 
> Los accessors y mutators son herramientas poderosas que mantienen tus modelos inteligentes y tus controladores simples, siguiendo las mejores prácticas de Laravel para un código limpio y mantenible.
