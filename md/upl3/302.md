# 3.2. Eloquent ORM

Una vez que se ha establecido la estructura de la base de datos con migraciones, el siguiente paso es interactuar con los datos almacenados. Aqu√≠ es donde entra en juego Eloquent ORM, el sistema de mapeo objeto-relacional (ORM) de Laravel.

## 2.1. ¬øQu√© es un ORM?

**ORM** (Object-Relational Mapping) es una t√©cnica de programaci√≥n que permite mapear objetos de un lenguaje de programaci√≥n a tablas de una base de datos relacional. Facilita la interacci√≥n con la base de datos usando objetos en lugar de SQL directo.

???examplelaravel "Analog√≠a: El Bibliotecario"

    Imagina que entras en una biblioteca inmensa donde los libros, en lugar de t√≠tulos, solo muestran un c√≥digo num√©rico en el lomo: "LIB-0001", "LIB-0432", etc. Quieres encontrar "todos los libros de ciencia ficci√≥n publicados despu√©s del a√±o 2000", pero te enfrentas a un problema: no entiendes el sistema de c√≥digos y no puedes ir abriendo miles de libros uno por uno para comprobar su contenido. Ser√≠a una tarea lenta, frustrante y propensa a errores.

    Aqu√≠ es donde entra en juego **el bibliotecario**.

    En lugar de aprender el complejo lenguaje de los c√≥digos (que ser√≠a como aprender SQL), simplemente te acercas al bibliotecario y le pides lo que necesitas en tu idioma natural (en este caso PHP).

    El bibliotecario, que domina a la perfecci√≥n el sistema de c√≥digos, traduce tu petici√≥n al instante. Sabe que "ciencia ficci√≥n" corresponde a los c√≥digos del 1200 al 1599 y que debe filtrar por a√±o.

    Todo este proceso ocurre en milisegundos sin que t√∫ necesites saber nada sobre el sistema de c√≥digos interno.

    **¬°Eloquent ORM es ese bibliotecario experto que traduce tus solicitudes en lenguaje natural (PHP) al complejo sistema de c√≥digos (SQL) de la base de datos, permiti√©ndote interactuar con los datos de manera sencilla y eficiente!**

## 2.2. ¬øQu√© es Eloquent?

**Eloquent** es el ORM incluido en Laravel que facilita la interacci√≥n con la base de datos usando modelos PHP. Cada modelo representa una tabla de la base de datos y permite realizar operaciones de manera intuitiva.

```php
// En lugar de escribir SQL:
// SELECT * FROM products WHERE category_id = 1

// Con Eloquent escribes:
$products = Product::where('category_id', 1)->get();
```

## 2.3. Creando modelos Eloquent

Para empezar a usar Eloquent, primero se crean modelos que representan las tablas de la base de datos.

Cada tabla tiene un modelo correspondiente, que es una clase PHP que extiende `Illuminate\Database\Eloquent\Model`. Este modelo contiene la l√≥gica para interactuar con esa tabla espec√≠fica.

> Las tablas pivote no tienen un modelo propio, sino que se manejan a trav√©s de las relaciones definidas en los modelos principales.

**Excepci√≥n: La Agregaci√≥n**

Es posible definir una tabla pivote con un modelo propio si encuentras una agregaci√≥n. La agregaci√≥n se utiliza cuando la relaci√≥n (la tabla pivote) necesita participar en otra relaci√≥n con una tercera entidad.

Por ejemplo, si tienes una tabla pivote `product_user` para la relaci√≥n muchos a muchos entre `products` y `users`, pero adem√°s supongamos que la plataforma necesita que un Agente de Soporte `agents` revise y verifique ciertos productos del usuario para sacar estad√≠sticas o ofrecerle mejores recomendaciones.

El agente de soporte no est√° verificando al usuario por un lado y al producto por otro. Est√° verificando la relaci√≥n que une al usuario y al producto (la tabla pivote), por lo que en este caso s√≠ tendr√≠a sentido crear un modelo `ProductUser` para manejar esa l√≥gica adicional.

### 2.3.1. Comando para crear modelos

```bash
# crear un modelo b√°sico
sail artisan make:model Product
```

**Opciones √∫tiles del comando**

Puedes combinar varias opciones al crear un modelo. 

-  `-m` (crea tambi√©n la migraci√≥n)
-  `-s` (crea tambi√©n el seeder)
-  `-c` (crea tambi√©n el controlador)

Puedes crear todo lo necesario para un modelo de una sola vez:

```bash
# crear modelo con migraci√≥n, seeder y controlador
sail artisan make:model Product -msc
```

### 2.3.2. Estructura b√°sica de un modelo

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Product extends Model
{
    use HasFactory;

    // El modelo est√° listo para usar
}
```

## 2.4. Configuraci√≥n de modelos

Los modelos Eloquent pueden configurarse para adaptarse a las convenciones de la base de datos o a necesidades espec√≠ficas del proyecto.

### 2.4.1. Propiedades b√°sicas

Por defecto, Eloquent asume ciertas convenciones, pero estas pueden ser personalizadas:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Product extends Model
{
    use HasFactory;

    // Nombre de la tabla (opcional si sigue convenciones)
    protected $table = 'products';

    // Clave primaria (opcional si es 'id')
    protected $primaryKey = 'id';

    // Tipo de clave primaria
    protected $keyType = 'int';

    // Si la clave primaria es auto-incremental
    public $incrementing = true;

    // Campos que se pueden asignar masivamente
    protected $fillable = [
        'name',
        'description',
        'price',
        'category_id'
    ];

    // Campos que NO se pueden asignar masivamente
    protected $guarded = [
        'id',
        'created_at',
        'updated_at'
    ];

    // Campos que deben ser tratados como fechas
    protected $dates = [
        'created_at',
        'updated_at',
        'deleted_at'
    ];
}
```

### 2.4.2. Fillable vs Guarded

La asignaci√≥n masiva (Mass Assignment) permite crear o actualizar modelos usando arrays de datos. Para proteger contra asignaciones no autorizadas, se usan las propiedades `$fillable` y `$guarded`.

La propiedad **`$fillable`** define qu√© campos pueden ser asignados masivamente, mientras que **`$guarded`** define qu√© campos no pueden ser asignados. **Solo se necesita usar una de las dos**.

```php
// Opci√≥n 1: Usar fillable (recomendado)
protected $fillable = [
    'name',
    'description',
    'price'
];

// Opci√≥n 2: Usar guarded
protected $guarded = [
    'id',
    'created_at',
    'updated_at'
];

// Opci√≥n 3: Guarded vac√≠o (permite todo excepto id, timestamps)
protected $guarded = [];
```

**Seguridad con Mass Assignment**

**Siempre** define `$fillable` o `$guarded` para proteger contra asignaci√≥n masiva no autorizada. Esto previene que usuarios maliciosos modifiquen campos sensibles.

## 2.5. Accessors y Mutators: transformando datos

Los **accessors** y **mutators** son caracter√≠sticas de Eloquent que permiten transformar datos autom√°ticamente cuando se leen o escriben en el modelo, manteniendo la l√≥gica de negocio dentro del modelo (principio "*Fat Models, Skinny Controller*s").

???examplelaravel "Analog√≠a: El Traductor Autom√°tico de la Biblioteca"

    **¬°Imagina que la biblioteca tiene un sistema de traducci√≥n autom√°tica en las estanter√≠as!**

    * üìñ **En la estanter√≠a**: El libro tiene un c√≥digo "0484" (sin formato)
    * üëÅÔ∏è **Cuando lo lees (Accessor)**: El bibliotecario te muestra "Estanter√≠a 4, secci√≥n 8, fila 4" (formateado autom√°ticamente)
    * ‚úçÔ∏è **Cuando lo escribes (Mutator)**: Escribes "CUATROCIENTOS OCHENTA Y CUATRO" y el sistema lo guarda como "0484" (normalizado)

¬°Los accessors y mutators son tus traductores autom√°ticos que mantienen los datos limpios en la base de datos pero los presentan elegantemente al usuario!

### 2.5.1. Accessors: Transformar datos al leerlos

Un **accessor** es un m√©todo que transforma un atributo del modelo cuando se accede a √©l. Se utiliza para formatear, calcular o modificar datos antes de mostrarlos.

**Sintaxis en Laravel 11+:**

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Casts\Attribute;

class Product extends Model
{
    /**
     * Get the product's final price after applying discounts.
     */
    protected function finalPrice(): Attribute
    {
        return Attribute::make(
            get: function () {
                if ($this->offer && $this->offer->discount_percentage > 0) {
                    $discount = $this->price * ($this->offer->discount_percentage / 100);
                    return round($this->price - $discount, 2);
                }
                return $this->price;
            },
        );
    }
}
```

**Uso del Accessor:**

```php
// En el controlador
$product = Product::with('offer')->find(1);
echo $product->final_price;  // 799.99 (calculado autom√°ticamente)
```

```php
// Base de datos: "1234567890"
echo $user->phone;  // Muestra: "+34 123 456 7890"
```

### 2.5.2. Mutators: Transformar datos al escribirlos

Un **mutator** es un m√©todo que transforma un atributo del modelo cuando se asigna un valor. Se utiliza para normalizar, limpiar o procesar datos antes de guardarlos en la base de datos.

**Sintaxis en Laravel 11+:**

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Support\Str;

class Product extends Model
{
    /**
     * Get/Set the product's name.
     */
    protected function name(): Attribute
    {
        return Attribute::make(
            get: fn ($value) => ucfirst($value),     // Capitalizar al leer
            set: fn ($value) => strtolower($value),  // Min√∫sculas al escribir
        );
    }
}
```

**Uso del Mutator:**

```php
// Al escribir
$product = new Product();
$product->name = 'iPHONE 15 PRO';  // Escribes en may√∫sculas
$product->save();

// En la base de datos se guarda: "iphone 15 pro" (min√∫sculas)

// Al leer
echo $product->name;  // Muestra: "Iphone 15 pro" (primera letra may√∫scula)
```


```php
$user->email = "GUILLERMO@EXAMPLE.COM";  // Escribes en may√∫sculas
// Base de datos guarda: "guillermo@example.com" ‚ú®
```


> **Nota sobre rendimiento**
> 
> Los accessors se ejecutan cada vez que accedes al atributo. Si tienes un accessor costoso y lo usas en un bucle con muchos registros, puede afectar el rendimiento. En esos casos, considera:
> 
> Los accessors y mutators son herramientas poderosas que mantienen tus modelos inteligentes y tus controladores simples, siguiendo las mejores pr√°cticas de Laravel para un c√≥digo limpio y mantenible.
