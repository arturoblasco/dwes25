# 3.1. Migraciones y Estructura

Ahora que se ha introducido Laravel y su arquitectura MVC, es momento de profundizar en c√≥mo gestionar la estructura de la base de datos utilizando migraciones y modelos Eloquent. En este apartado se exploran los conceptos fundamentales de las bases de datos relacionales y el sistema de migraciones de Laravel. Se aprende a dise√±ar, crear y modificar la estructura de las tablas, construyendo esquemas con relaciones definidas que garantizan la integridad de los datos.

## 1. Conceptos fundamentales de bases de datos relacionales

Para entender como se relacionan los datos en una aplicaci√≥n Laravel, es crucial comprender los principios b√°sicos de las bases de datos relacionales.

### 1.1. ¬øQu√© es una base de datos relacional?

Una **base de datos relacional** es un sistema de gesti√≥n de datos que organiza la informaci√≥n en tablas relacionadas entre s√≠. Cada tabla representa una entidad del mundo real y las relaciones entre tablas permiten navegar entre datos relacionados.

???examplelaravel "Analog√≠a: La Gran Biblioteca Central"

    **¬°Imagina la base de datos relacional como una biblioteca gigantesca con un sistema de catalogaci√≥n perfecto!**

    * üìö **Tablas = Secciones tem√°ticas de la biblioteca** Secci√≥n de Ciencia Ficci√≥n, Secci√≥n de Historia, Secci√≥n de Arte... Cada secci√≥n almacena un tipo espec√≠fico de informaci√≥n
    * üìñ **Registros = Libros individuales** Cada libro es un elemento concreto: "1984" de Orwell, "Sapiens" de Harari, "El Quijote" de Cervantes...
    * üè∑Ô∏è **Columnas = datos de la ficha catalogr√°fica** Todos los libros tienen las mismas fichas: t√≠tulo, autor, a√±o de publicaci√≥n, ISBN, n√∫mero de p√°ginas...
    * üîë **Clave primaria = C√≥digo √∫nico de catalogaci√≥n (ISBN)** Cada libro tiene un identificador √∫nico que nunca se repite: "978-3-16-148410-0"... ¬°Permite localizar cualquier libro de forma inequ√≠voca!
    * üîó **Clave for√°nea = Referencia a otra secci√≥n** "Este libro pertenece al Autor #42, b√∫scalo en la Secci√≥n de Autores" Es como una nota que te dice d√≥nde buscar informaci√≥n relacionada
    * ÔøΩ **Relaciones = Sistema de referencias cruzadas** "Para m√°s informaci√≥n sobre este tema, consulta tambi√©n estos libros relacionados" Permiten navegar entre libros y autores de forma natural
    * üìá **√çndice = Cat√°logo de b√∫squeda r√°pida** El bibliotecario tiene fichas ordenadas por autor, t√≠tulo o tema para encontrar libros en segundos

    **¬°Sin este sistema de catalogaci√≥n, buscar informaci√≥n en millones de libros ser√≠a imposible! La base de datos relacional es tu biblioteca perfectamente organizada donde todo tiene su lugar.**

### 1.2. Tipos de relaciones

#### Uno a Uno (1:1)

Una entidad se relaciona con exactamente una entidad de otra tabla. Un producto tiene una √∫nica oferta especial y esa oferta pertenece a un √∫nico producto.


```mermaid
erDiagram
    products {
        int id PK "Clave Primaria"
        string name
        string description
    }
    offers {
        int id PK "Clave Primaria"
        decimal discount_price
        date start_date
        int product_id FK "Clave For√°nea"
    }
    products ||--|| offers : "tiene"
```

#### Uno a Muchos (1:N)

Una entidad se relaciona con m√∫ltiples entidades de otra tabla. Una categor√≠a puede tener muchos productos, pero un producto pertenece a una sola categor√≠a.

```mermaid
erDiagram
    categories {
        int id PK "Clave Primaria"
        string name
        string slug
    }
    products {
        int id PK "Clave Primaria"
        string name
        decimal price
        int category_id FK "Clave For√°nea"
    }
    categories ||--o{ products : "tiene"
```
???+examplelaravel "Ejemplo"
    * Categor√≠a "Electr√≥nica" **‚Üí** Productos: "iPhone", "Samsung", "iPad"
    * Categor√≠a "Ropa" **‚Üí** Productos: "Camiseta", "Pantal√≥n", "Zapatos"

#### Muchos a Muchos (N:M)

M√∫ltiples entidades se relacionan con m√∫ltiples entidades de otra tabla, a trav√©s de una **tabla pivote** intermedia. Un producto puede estar en la lista de favoritos de muchos usuarios y un usuario puede tener muchos productos favoritos.

```mermaid
erDiagram
    products {
        int id PK "Clave Primaria"
        string name
        text description
    }
    users {
        int id PK "Clave Primaria"
        string name
        string email
    }
    product_user {
        int product_id PK, FK "Clave Primaria y For√°nea"
        int user_id PK, FK "Clave Primaria y For√°nea"
    }

    products ||--|{ product_user : "favorito de"
    users ||--|{ product_user : "tiene favorito"
```

???+examplelaravel "Ejemplo"
    * Usuario "Ana" ‚Üí Favoritos: "Port√°til", "Rat√≥n Inal√°mbrico"
    * Producto "Port√°til" ‚Üí En favoritos de: "Ana", "Luis", "Carla"

## 2. Sistema de migraciones de Laravel

### 2.1. ¬øQu√© son las migraciones?

Las **migraciones** son archivos que definen en primer lugar la estructura de la base de datos y posteriormente los cambios que se realizan en ella de manera versionada y reversible. De este modo, permiten gestionar la evoluci√≥n del esquema de la base de datos como c√≥digo.

???examplelaravel "Analog√≠a: El Manual de Montaje de BiblioTech S.A."

    **¬°Imagina que BiblioTech S.A. env√≠a sus estanter√≠as desmontadas con un manual de instrucciones ultrapreciso!**

    * üìñ **Cada migraci√≥n = Una p√°gina del manual de montaje** P√°gina 1: "Montar la estructura base de la estanter√≠a (tabla `users`)". P√°gina 2: "A√±adir un estante para biograf√≠as (columna `biography` en `users`)". P√°gina 3: "Instalar un sistema de catalogaci√≥n (tabla `books`)".
    * üî¢ **Versiones = Pasos numerados y fechados** Cada p√°gina del manual est√° marcada con una fecha y hora exactas (`2024_05_20_103000_create_users_table.php`). Esto asegura que todos los montadores sigan los pasos en el orden correcto, sin saltarse ninguno.
    * ‚è™ **Reversibilidad = Instrucciones de desmontaje** Cada p√°gina tiene dos partes claras:

    + `up()`: "C√≥mo montar el componente" (ej. "colocar el estante `biography`").
    + `down()`: "C√≥mo desmontar el componente de forma segura" (ej. "retirar el estante `biography` y guardar los tornillos"). Si te equivocas en un paso, solo tienes que seguir las instrucciones `down()` para volver al estado anterior sin romper nada.
    * üë• **Colaboraci√≥n = Todo el equipo de montaje usa el mismo manual** El manual se comparte a trav√©s de un sistema centralizado (Git). Si un ingeniero jefe a√±ade un nuevo paso (una nueva estanter√≠a o un refuerzo), todos los montadores reciben la actualizaci√≥n. Al ejecutar `php artisan migrate`, sus copias locales de la "biblioteca" se sincronizan con la √∫ltima versi√≥n del manual.

    **Sin este manual, cada montador construir√≠a las estanter√≠as a su manera, resultando en un caos de estructuras incompatibles. Las migraciones son el manual que garantiza que la base de datos (nuestra biblioteca) sea id√©ntica y funcional en todos los entornos de desarrollo.**

### 2.2. Estructura de una migraci√≥n

Las migraciones son clases PHP que extienden `Migration` y contienen dos m√©todos principales: **`up()`** y **`down()`**.

El m√©todo **`up()`** define los cambios a aplicar (crear tablas, a√±adir columnas, etc.), mientras que **`down()`** especifica c√≥mo revertir esos cambios (eliminar tablas, quitar columnas, etc.).

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Definir cambios a aplicar
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Definir c√≥mo deshacer los cambios
    }
};
```

## 3. Creando migraciones

### 3.1. Comando para crear migraciones

Para crear una nueva migraci√≥n, se utiliza el comando Artisan **`make:migration`**:

```bash
# crear una migraci√≥n b√°sica
sail artisan make:migration create_products_table
```

> **Recuerda**
> 
> Laravel est√° dise√±ado para trabajar en **ingl√©s**. Los nombres de tablas, columnas y modelos deben estar en ingl√©s, respetando:
> 
> * **Tablas**: plural en ingl√©s (`products`, `categories`, `users`)
> * **Modelos**: singular en ingl√©s (`Product`, `Category`, `User`)
> * **Columnas**: snake\_case en ingl√©s (`created_at`, `category_id`, `is_active`)
> 
> Esto permite que Laravel funcione autom√°ticamente sin configuraci√≥n adicional.

### 3.2. Migraci√≥n para crear tabla

Cuando se crea una migraci√≥n para una tabla, el archivo generado contendr√° un esquema b√°sico.

Aqu√≠ hay un ejemplo de una migraci√≥n para crear una tabla `products` con varios tipos de columnas y una relaci√≥n con la tabla `categories`.

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('products', function (Blueprint $table) {
            $table->id();                    // Clave primaria auto-incremental
            $table->string('name');          // Campo de texto
            $table->text('description');     // Campo de texto largo
            $table->decimal('price', 10, 2); // Campo decimal (10 d√≠gitos, 2 decimales)
            $table->foreignId('category_id') // Clave for√°nea
                  ->constrained()            // Referencia a tabla categories
                  ->onDelete('cascade');     // Eliminar en cascada
            $table->timestamps();            // created_at y updated_at
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('products');
    }
};
```

### 3.3. Tipos de columnas comunes

Esta es una tabla con los tipos de columnas m√°s comunes en migraciones:

| Tipo | Descripci√≥n | Ejemplo |
| --- | --- | --- |
| `id()` | Clave primaria auto-incremental | `$table->id()` |
| `string('name')` | Campo de texto (255 caracteres) | `$table->string('name')` |
| `text('description')` | Campo de texto largo | `$table->text('description')` |
| `integer('quantity')` | N√∫mero entero | `$table->integer('quantity')` |
| `decimal('price', 8, 2)` | N√∫mero decimal | `$table->decimal('price', 8, 2)` |
| `boolean('is_active')` | Valor booleano | `$table->boolean('is_active')` |
| `date('birth_date')` | Fecha | `$table->date('birth_date')` |
| `timestamp('deleted_at')` | Fecha y hora | `$table->timestamp('deleted_at')` |


> **Importante**
> 
> `id()` es un atajo para `$table->bigIncrements('id')`, que crea una columna de clave primaria auto-incremental de tipo BIGINT. Los BIGINT permiten un rango mucho mayor de valores que INT, lo cual es √∫til para tablas con muchos registros. Esto afecta a todas las claves primarias y for√°neas que uses en tus tablas.
> 
> Adem√°s, los tipos de columnas pueden tener modificadores adicionales como **`nullable()`**, **`default()`**, **`unique()`**, etc.
> 
> !!! example "Ejemplo"
>     ```php
>     $table->string('email')->unique(); // crea una columna de texto √∫nica.
>     ```


## 4. Relaciones en migraciones

Para definir relaciones entre tablas, se utilizan claves for√°neas y tablas pivote.

### 4.1. Claves for√°neas
Las claves for√°neas se definen usando **`foreignId()`** o **`foreign()`**. 

Aqu√≠ hay dos m√©todos para hacerlo:

- M√©todo 1: Usando `foreignId` (**recomendado**).
```php
<?php

$table->foreignId('category_id')
      ->constrained()           // Referencia a tabla categories
      ->onDelete('cascade');    // Eliminar en cascada
```
- M√©todo 2: Usando `foreign` (m√°s control).
```php
<?php
$table->unsignedBigInteger('category_id');
$table->foreign('category_id')
      ->references('id')
      ->on('categories')
      ->onDelete('cascade');
```

Es mejor usar **`foreignId()`** por su simplicidad y legibilidad. Pero si necesitas m√°s control (como referenciar una columna diferente o una tabla distinta), `foreign()` es la opci√≥n adecuada.

> **Importante**
> 
> Laravel busca autom√°ticamente la tabla relacionada asumiendo que el nombre de la columna for√°nea sigue la convenci√≥n `{tabla_singular}_id`. 
> 
> Por ejemplo, `category_id` se asume que referencia a la tabla `categories`. Si tu columna no sigue esta convenci√≥n, debes especificar la tabla y columna manualmente usando el m√©todo 2 `foreign()` con `references()` y `on()`.

### 4.2. Tabla pivote para relaciones Muchos a Muchos

Como se mencion√≥ antes, las relaciones muchos a muchos requieren una tabla pivote intermedia que contenga las claves for√°neas de ambas tablas relacionadas.

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('product_user', function (Blueprint $table) {
            $table->id();
            $table->foreignId('product_id')
                  ->constrained()
                  ->onDelete('cascade');
            $table->foreignId('user_id')
                  ->constrained()
                  ->onDelete('cascade');
            $table->timestamps();
            
            // Evitar duplicados
            $table->unique(['product_id', 'user_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('product_user');
    }
};
```

> **Importante**
> 
> La tabla pivote debe tener un nombre que combine ambas tablas **en orden alfab√©tico**, separadas por un guion bajo **`_`**. 
> 
> En este caso, `product_user` es correcto porque "product" viene antes que "user" alfab√©ticamente. Esto permite que Laravel reconozca autom√°ticamente la tabla pivote al definir las relaciones en los modelos.

## 5. Ejecutando migraciones

Para aplicar las migraciones y crear o modificar la estructura de la base de datos, se utilizan comandos Artisan espec√≠ficos.

### 5.1. Comandos de migraci√≥n

```bash
# Ejecutar todas las migraciones pendientes
sail artisan migrate
```
```bash
# Ver el estado de las migraciones
sail artisan migrate:status
```
```bash
# Revertir la √∫ltima migraci√≥n
sail artisan migrate:rollback
```
```bash
# Revertir todas las migraciones
sail artisan migrate:reset
```
```bash
# Revertir y volver a ejecutar
sail artisan migrate:refresh
```
```bash
# Revertir, ejecutar y poblar con seeders (‚òÖ MUY USADO EN DESARROLLO)
sail artisan migrate:refresh --seed
```

**migrate:refresh vs migrate:fresh**

**`migrate:refresh`** (recomendado para desarrollo):

* Ejecuta el m√©todo `down()` de todas las migraciones en orden inverso.
* Luego ejecuta el m√©todo `up()` de todas las migraciones.
* Respeta las definiciones de `down()` y `up()`.
* Preserva la l√≥gica de reversi√≥n.

**`migrate:fresh`** (m√°s dr√°stico):

* Elimina TODAS las tablas directamente (DROP).
* Crea todo desde cero.
* NO ejecuta los m√©todos `down()`.
* M√°s r√°pido pero menos preciso.

**`migrate:refresh --seed`** (‚òÖ el m√°s usado en desarrollo):

* Hace refresh de la base de datos.
* Ejecuta autom√°ticamente todos los seeders al finalizar.
* Ideal para resetear el estado de desarrollo con datos de prueba.
* comando usado constantemente durante el desarrollo.

## 6. Actualizando migraciones

A medida que la aplicaci√≥n evoluciona, es com√∫n necesitar modificar la estructura de la base de datos. En lugar de editar migraciones antiguas (lo cual es una mala pr√°ctica), se crean nuevas migraciones que describen los cambios.

Si necesitas a√±adir una nueva columna `stock` a la tabla `products`, se crea una nueva migraci√≥n as√≠:

```bash
# crear una nueva migraci√≥n para a√±adir una columna
sail artisan make:migration add_stock_to_products_table --table=products
```

En esta migraci√≥n, se define el cambio en el m√©todo `up()` y c√≥mo revertirlo en `down()`. Por tanto, los metodos solo contienen la modificaci√≥n:

```php
<?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
return new class extends Migration
{
    public function up(): void
    {
        Schema::table('products', function (Blueprint $table) {
            $table->integer('stock')->default(0); // Nueva columna stock
        });
    }

    public function down(): void
    {
        Schema::table('products', function (Blueprint $table) {
            $table->dropColumn('stock'); // Eliminar columna stock
        });
    }
};
```

> **Regla de Oro de las migraciones**
> 
> **NUNCA** modifiques una migraci√≥n que ya ha sido ejecutada en producci√≥n. Si necesitas hacer cambios, crea una nueva migraci√≥n.

