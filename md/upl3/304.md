# 3.4. Relaciones Eloquent

Como se vio en el primer apartado se implementan relaciones entre modelos (uno a uno, uno a muchos, muchos a muchos), aprendiendo a navegar entre datos relacionados de manera elegante y eficiente.

Eloquent ORM facilita la definici√≥n y gesti√≥n de relaciones entre modelos, permitiendo acceder a datos relacionados con una sintaxis intuitiva y expresiva.

## 4.1. ¬øQu√© son las Relaciones en Eloquent?

Las **relaciones** en Eloquent definen c√≥mo los modelos est√°n conectados entre s√≠, permitiendo navegar entre datos relacionados de manera elegante y eficiente sin escribir SQL complejo.

???examplelaravel "Analog√≠a: El Sistema de Referencias Cruzadas de la Biblioteca"

    **¬°Imagina que cada libro en la biblioteca tiene un sistema de referencias que te lleva autom√°ticamente a otros libros relacionados!**

    * ÔøΩ **Biblioteca sin referencias**: Tendr√≠as que buscar manualmente cada libro relacionado por toda la biblioteca
    * üîó **Sistema de Referencias Cruzadas (Eloquent Relationships)**: Los libros est√°n conectados inteligentemente

    **Ejemplos de referencias en la biblioteca:**

    * üë§ **Autor** ‚Üí ÔøΩ **Sus libros** (uno a muchos) Como cuando buscas "J.K. Rowling" y autom√°ticamente ves todos sus libros: Harry Potter 1, 2, 3... `$autor->libros` ‚Üí ¬°Todos sus libros al instante!
    * ÔøΩ **Libro** ‚Üî üè∑Ô∏è **Categor√≠as** (muchos a muchos) Un libro puede estar en varias categor√≠as (Fantas√≠a, Aventura, Juvenil) Una categor√≠a contiene muchos libros diferentes `$libro->categorias` ‚Üí ¬°Todas las categor√≠as al momento!
    * ÔøΩ **Libro** ‚Üî üìã **Su ficha de inventario √∫nica** (uno a uno) Cada libro tiene exactamente una ficha con su ubicaci√≥n y estado Cada ficha pertenece a un √∫nico libro `$libro->ficha` ‚Üí ¬°Acceso directo e inmediato!
    * üìö **Saga** ‚Üí üìñ **Entregas** (uno a muchos) La saga "El Se√±or de los Anillos" ‚Üí [La Comunidad, Las Dos Torres, El Retorno del Rey] `$saga->entregas` ‚Üí ¬°Todas las entregas ordenadas!

    **Sin relaciones** üòì: Buscar√≠as manualmente en diferentes secciones con m√∫ltiples consultas al cat√°logo **Con relaciones** üéØ: Navegas naturalmente: `$autor->libros->first()->categorias`

¬°Las relaciones Eloquent son como el sistema de referencias cruzadas que conecta toda la informaci√≥n de la biblioteca!

---

**Relaciones Polim√≥rficas**

Adem√°s de las relaciones b√°sicas, Eloquent tambi√©n soporta **relaciones polim√≥rficas**. Estas permiten que un modelo se relacione con m√∫ltiples tipos de modelos (ej: Comentarios ‚Üí Posts/Videos). Para ello utiliza una estructura especial en la base de datos con campos `*_type` y `*_id` para identificar el modelo relacionado y su identificador.



```mermaid
---
title: üìä Estructura de Tabla Polim√≥rfica - Comentarios
---
erDiagram
   COMMENTS {
       bigint id PK "Identificador √∫nico"
       text content "Contenido del comentario"
       string commentable_type "Tipo de modelo (Post, Video, etc.)"
       bigint commentable_id "ID del registro relacionado"
       bigint user_id FK "Usuario que comenta"
       timestamp created_at "Fecha de creaci√≥n"
       timestamp updated_at "Fecha de actualizaci√≥n"
   }
   
   POSTS {
       bigint id PK
       string title
       text content
   }
   
   VIDEOS {
       bigint id PK
       string title
       string url
   }
   
   COMMENTS ||--o{ POSTS : "commentable_type = 'Post'"
   COMMENTS ||--o{ VIDEOS : "commentable_type = 'Video'"
```

Este tipo de relaci√≥n es mas compleja y durante el curso no se ver√° en detalle. Pero es bueno saber que existe.

## 4.2. Relaci√≥n Uno a Uno (1:1)

Para definir una relaci√≥n uno a uno, se utilizan los m√©todos `hasOne()` y `belongsTo()` en los modelos correspondientes.

Se a√±adir√° `hasOne()` en el modelo que "tiene" la relaci√≥n y `belongsTo()` en el modelo que "pertenece" a otro.

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Product extends Model
{
    // Un producto tiene una oferta
    public function offer()
    {
        return $this->hasOne(Offer::class);
    }
}

class Offer extends Model
{
    // Una oferta pertenece a un producto
    public function product()
    {
        return $this->belongsTo(Product::class);
    }
}
```

## 4.3. Relaci√≥n Uno a Muchos (1:N)

La relaci√≥n uno a muchos es una de las m√°s comunes. Un registro en una tabla puede estar relacionado con m√∫ltiples registros en otra tabla.

Para definir una relaci√≥n uno a muchos, se utilizan los m√©todos `hasMany()` y `belongsTo()` en los modelos correspondientes.

Como en la relaci√≥n uno a uno, se a√±ade `hasMany()` en el modelo que "tiene" la relaci√≥n y `belongsTo()` en el modelo que "pertenece" a otro.

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Category extends Model
{
    // Una categor√≠a tiene muchos productos
    public function products()
    {
        return $this->hasMany(Product::class);
    }
}

class Product extends Model
{
    // Un producto pertenece a una categor√≠a
    public function category()
    {
        return $this->belongsTo(Category::class);
    }
}
```

## 4.4. Relaci√≥n Muchos a Muchos (N:N)

La relaci√≥n muchos a muchos permite que m√∫ltiples registros en una tabla est√©n relacionados con m√∫ltiples registros en otra tabla.

Para definir una relaci√≥n muchos a muchos, se utilizan los m√©todos `belongsToMany()` en ambos modelos.

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Product extends Model
{
    // Un producto puede estar en el carrito de muchos usuarios
    public function users()
    {
        return $this->belongsToMany(User::class);
    }
}

class User extends Model
{
    // Un usuario puede tener muchos productos en su carrito/favoritos
    public function products()
    {
        return $this->belongsToMany(Product::class);
    }
}
```

Si no se especifica, Eloquent asume que la tabla pivot se llama con los nombres de las tablas en orden alfab√©tico (ej: `product_user`). Si la tabla tiene un nombre diferente, se puede pasar como segundo par√°metro a `belongsToMany()`.

```php
<?php
return $this->belongsToMany(Product::class, 'cart_items');
```

### 4.4.1. Tabla Pivote con Campos Adicionales

Frecuentemente, las tablas pivot necesitan almacenar informaci√≥n adicional m√°s all√° de las claves for√°neas. Por ejemplo, en un carrito de compras, se necesita saber la **cantidad** de cada producto.

Para ello, se pueden definir campos adicionales en la migraci√≥n de la tabla pivot y luego acceder a ellos usando el m√©todo `withPivot()` en la definici√≥n de la relaci√≥n.

```php
<?php
// Modelo User con acceso a campos pivot
class User extends Model
{
    public function products()
    {
        return $this->belongsToMany(Product::class, 'product_user')
            ->withPivot('quantity')      // Incluir campo quantity
            ->withTimestamps();          // Incluir created_at y updated_at
    }
}

// Modelo Product (relaci√≥n inversa)
class Product extends Model
{
    public function users()
    {
        return $this->belongsToMany(User::class, 'product_user')
            ->withPivot('quantity')
            ->withTimestamps();
    }
}
```

### 4.4.4. Acceder a Datos Pivot en Controladores y Vistas

Una vez definida la relaci√≥n con `withPivot()`, se puede acceder a los datos adicionales de la tabla pivot a trav√©s del objeto `pivot`.

```php
<?php
{{-- Mostrar productos del carrito con cantidad --}}
@foreach($cartProducts as $product)
    <div class="cart-item">
        <h3>{{ $product->name }}</h3>
        <p>Precio: ‚Ç¨{{ $product->price }}</p>
        
        {{-- Acceder a la cantidad desde pivot --}}
        <p>Cantidad: {{ $product->pivot->quantity }}</p>
        
        {{-- Calcular subtotal --}}
        @php
            $subtotal = $product->price * $product->pivot->quantity;
        @endphp
        <p>Subtotal: ‚Ç¨{{ number_format($subtotal, 2) }}</p>
        
        {{-- Fecha de a√±adido (timestamps) --}}
        <small>A√±adido: {{ $product->pivot->created_at->format('d/m/Y') }}</small>
    </div>
@endforeach
```

### 4.5. Usar Relaciones

Para obtener datos de las relaciones solo hay que llamarla como si fuese una propiedad m√°s.

```php
<?php
$category = Category::find(1); // Se obtiene la categor√≠a con ID 1
$products = $category->products; // Llama a la relaci√≥n 1:N

$product = $products::first(); // Se obtiene el primer producto de la categor√≠a
$offer = $product->offer; // Llama a la relaci√≥n 1:1

$users = $product->users; // Llama a la relaci√≥n N:N
```

Si se quiere filtrar la consulta de la relaci√≥n, se puede llamar como un m√©todo (con par√©ntesis) para obtener el constructor de consultas y aplicar condiciones.

```php
<?php
$category = Category::find(1);
$products = $category->products()->where('price', '>', 100)->get(); // Necesita el parentesis
```

Si se quiere modificar la informaci√≥n de los datos relacionados, con las relaciones 1:1 y 1:N se puede usar el m√©todo `save()` o `create()` en la relaci√≥n. Pero con las relaciones N:N se usan los m√©todos `attach()`, `detach()` y `sync()`.

```php
<?php
// A√±adir productos a la pivot (product_user)
$user = User::find(1);
$user->products()->attach([1, 2, 3]); // Se a√±aden productos con ID 1, 2 y 3 al usuario

// Sincronizar carrito (elimina los que no est√°n en el array). Si no existe, lo a√±ade.
$user->products()->sync([1, 2, 3]);

// A√±adir producto con datos adicionales (cantidad)
$user->products()->attach(1, ['quantity' => 2]);

// A√±adir productos con datos adicionales (cantidad)
$user->products()->attach([
    2 => ['quantity' => 1],
    3 => ['quantity' => 5]
]);

// Actualizar la cantidad de un producto en el carrito
$user->products()->updateExistingPivot($productId, [
    'quantity' => 3
]);
```

**Actualizar datos pivot**

El m√©todo `updateExistingPivot()` solo actualiza los datos adicionales en la tabla pivot. No sincroniza la existencia del registro. Si el registro no existe, no se crea.

