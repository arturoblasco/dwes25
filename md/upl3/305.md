# 3.5. Seeders y Factories

Una vez que se ha aprendido a gestionar la estructura de la base de datos con migraciones y a interactuar con los datos mediante Eloquent ORM, el siguiente paso es poblar la base de datos con datos iniciales y de prueba. Esto se logra utilizando **seeders** y **factories**, herramientas que permiten automatizar la creaci√≥n de grandes cantidades de datos realistas para facilitar el desarrollo y las pruebas.

## 5.1. ¬øQu√© son los Seeders?

Los **seeders** son clases que definen datos iniciales para poblar la base de datos con informaci√≥n fija o de prueba. Permiten establecer un estado inicial consistente de la base de datos para desarrollo y testing.

???examplelaravel "Analog√≠a: La Colecci√≥n Inicial de la Biblioteca"

    **¬°Imagina que acabas de inaugurar una nueva biblioteca y necesitas llenarla con libros esenciales!**

    * üìö **Biblioteca vac√≠a** = Estanter√≠as vac√≠as esperando ser llenadas
    * üìñ **Seeders = La colecci√≥n fundamental** Los libros esenciales que toda biblioteca debe tener desde el primer d√≠a: Enciclopedias, diccionarios, cl√°sicos universales (Quijote, Shakespeare...)
    * üéØ **Datos iniciales bien definidos** No son libros aleatorios, son los pilares fundamentales perfectamente seleccionados
    * ‚ö° **Un comando para inicializar**`sail artisan db:seed` ‚Üí ¬°La biblioteca se llena con su colecci√≥n base al instante!

    **Sin seeders** üòì: Catalogar√≠as manualmente cada libro esencial uno por uno, cada vez que reinicies la biblioteca **Con seeders** üöÄ: Un comando y tu biblioteca tiene toda su colecci√≥n fundamental lista para funcionar

¬°Los seeders son como el plan de adquisici√≥n inicial que asegura que tu biblioteca tenga todo lo esencial desde el d√≠a uno!

## 5.2. Creando Seeders

### 5.2.1. Comando para Crear Seeders

Para crear un seeder, se utiliza el comando Artisan `make:seeder` seguido del nombre del seeder.

```bash
# Crear un seeder b√°sico
sail artisan make:seeder CategorySeeder
```

### 5.2.2. Estructura B√°sica de un Seeder
Una vez creado, un seeder tiene una estructura b√°sica con un m√©todo `run()` donde se define la l√≥gica para insertar datos en la base de datos.

```php
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Category;

class CategorySeeder extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        // L√≥gica para poblar la base de datos
    }
}
```

### 5.2.3. Seeder B√°sico con Datos Est√°ticos

Dentro del m√©todo `run()`, se pueden insertar datos manualmente utilizando los modelos Eloquent. Para ello lo mas conveniente es tener un arreglo con los datos y luego iterar sobre √©l para crear los registros.

```php
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Category;

class CategorySeeder extends Seeder
{
    public function run(): void
    {
        $categories = [
            [
                'name' => 'Electr√≥nica',
                'slug' => 'electronica',
                'description' => 'Dispositivos electr√≥nicos de √∫ltima generaci√≥n'
            ],
            [
                'name' => 'Ropa',
                'slug' => 'ropa',
                'description' => 'Moda y accesorios para todas las estaciones'
            ],
            [
                'name' => 'Hogar',
                'slug' => 'hogar',
                'description' => 'Art√≠culos para el hogar y decoraci√≥n'
            ]
        ];

        foreach ($categories as $category) {
            Category::create($category);
        }
    }
}
```

### 5.2.4. Seeder con Relaciones
Los seeders tambi√©n pueden crear datos que dependan de otros registros, respetando las relaciones definidas en la base de datos.

Por ejemplo, un `ProductSeeder` que crea productos asociados a categor√≠as y ofertas existentes. Se muestra a continuaci√≥n un ejemplo de un seeder que crea categor√≠as, productos y ofertas, respetando las relaciones entre ellos.

```php
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Category;
use App\Models\Product;
use App\Models\Offer;

class ProductSeeder extends Seeder
{
    public function run(): void
    {
        // Crear categor√≠as
        $electronics = Category::create([
            'name' => 'Electr√≥nica',
            'slug' => 'electronica'
        ]);

        $clothing = Category::create([
            'name' => 'Ropa',
            'slug' => 'ropa'
        ]);

        // Crear productos
        $iphone = Product::create([
            'name' => 'iPhone 15',
            'description' => '√öltimo modelo de iPhone',
            'price' => 999.99,
            'category_id' => $electronics->id
        ]);
        
        // Crear oferta para el iPhone
        Offer::create([
            'product_id' => $iphone->id,
            'discount_price' => 799.99,
            'start_date' => now(),
            'end_date' => now()->addDays(7)
        ]);

        $shirt = Product::create([
            'name' => 'Camiseta Premium',
            'description' => 'Camiseta de algod√≥n org√°nico',
            'price' => 29.99,
            'category_id' => $clothing->id
        ]);
    }
}
```

> **Atenci√≥n**
> 
> Este seeder crea multiples entidades en un mismo seeder. En aplicaciones reales, es recomendable separar cada entidad en su propio seeder para mantener el c√≥digo limpio y modular.

## 5.3. ¬øQu√© son las Factories?

Cuando los seeders necesitan crear grandes cantidades de datos que no son fijos, las factories son la herramienta ideal para generar estos datos ya que permiten definir patrones y variaciones en los datos generados.

Las **factories** son clases que generan datos de prueba realistas de forma automatizada. Utilizan la librer√≠a Faker para crear datos variados y cre√≠bles para desarrollo y testing.

???examplelaravel "Analog√≠a: El Generador Autom√°tico de Manuscritos"

    **¬°Imagina que necesitas llenar la biblioteca con miles de libros para hacer pruebas del sistema de catalogaci√≥n!**

    * üñ®Ô∏è **Factory = La m√°quina generadora de manuscritos realistas** Le das una plantilla base de "Libro de Ficci√≥n" y ella crea 1000 libros DIFERENTES y cre√≠bles autom√°ticamente
    * üé® **Faker = El generador de contenido variado** Cada libro tiene t√≠tulo √∫nico, autor diferente, a√±o aleatorio, sinopsis distinta ¬°Nunca genera dos libros exactamente iguales!
    * ÔøΩ **Libros generados = Datos de prueba realistas** "El Jard√≠n Secreto de las Estrellas", "Cr√≥nicas del Tiempo Perdido", "El √öltimo Guardi√°n"... Todos parecen libros reales y cre√≠bles
    * ‚ö° **L√≠nea de producci√≥n literaria autom√°tica**`Book::factory(50)->create()` ‚Üí ¬°50 libros √∫nicos catalogados al instante!

    **Sin factories** üòì: Escribir√≠as manualmente "Libro 1", "Libro 2", "Libro 3"... (¬°aburrido, repetitivo y poco realista!) **Con factories** üöÄ: La m√°quina genera t√≠tulos realistas, autores variados, argumentos √∫nicos... (¬°cre√≠ble y profesional!)

    * üìñ **Perfectos para pruebas del sistema** Necesitas probar el buscador, los filtros, la paginaci√≥n... Las factories te dan datos realistas sin esfuerzo

¬°Las factories son tu imprenta autom√°tica que llena la biblioteca con contenido realista para probar todo el sistema!

## 5.4. Creando Factories

### 5.4.1. Comando para Crear Factories

Para crear una factory, se utiliza el comando Artisan `make:factory` seguido del nombre de la factory y opcionalmente el modelo asociado.

Si se especifica el modelo, la factory se vincula autom√°ticamente a ese modelo, facilitando la creaci√≥n de instancias del mismo.

```bash
# Crear un factory b√°sico
sail artisan make:factory ProductFactory

# Crear factory con modelo especificado
sail artisan make:factory ProductFactory --model=Product
```

### 5.4.2. Estructura B√°sica de una Factory

Los factories tienen una estructura b√°sica que incluye un m√©todo `definition()` donde se definen los atributos del modelo y c√≥mo se generan sus valores utilizando Faker.

```php
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use App\Models\Category;

class ProductFactory extends Factory
{
    /**
     * Define the model's default state.
     */
    public function definition(): array
    {
        // Definir los atributos con datos generados por Faker
    }
}
```

### 5.4.3. Factory B√°sico con Datos Realistas

Los factories deben definir atributos con datos generados por Faker para crear registros variados y realistas.

Por ejemplo, una factory para el modelo `Product` podr√≠a verse as√≠:

```php
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use App\Models\Category;

class ProductFactory extends Factory
{
    public function definition(): array
    {
        return [
            'name' => $this->faker->randomElement([
                'iPhone 15 Pro',
                'Samsung Galaxy S24',
                'MacBook Air M3',
                'iPad Pro 12.9"',
                'AirPods Pro',
                'Apple Watch Series 9'
            ]),
            'description' => $this->faker->paragraph(3),
            'price' => $this->faker->randomFloat(2, 99, 1999),
            'category_id' => Category::factory(),
            'image' => $this->faker->imageUrl(400, 300, 'products'),
            'is_active' => $this->faker->boolean(90), // 90% activos
        ];
    }
}
```

**Faker**

Faker es una librer√≠a que genera datos falsos pero realistas, como nombres, direcciones, textos, n√∫meros, fechas, etc. Laravel la integra para facilitar la creaci√≥n de datos de prueba.

M√°s info: [Faker PHP](https://fakerphp.github.io/)

## 5.5. Usando Factories

Se pueden crear registros individuales o m√∫ltiples utilizando las factories. A continuaci√≥n se muestran ejemplos de c√≥mo utilizar las factories.

```php
// Crear un producto
$product = Product::factory()->create();

// Crear un producto con datos espec√≠ficos
$product = Product::factory()->create([
    'name' => 'iPhone 15',
    'price' => 999.99
]);

// Crear 10 productos
$products = Product::factory(10)->create();

// Crear productos con datos espec√≠ficos
$products = Product::factory(5)->create([
    'category_id' => 1
]);

// Crear productos sin guardar en base de datos
$products = Product::factory(10)->make();
```

### 5.5.3. Factories en Seeders

Las factories se utilizan dentro de los seeders para crear registros en la base de datos. Por tanto lo m√°s com√∫n es ver su uso dentro del m√©todo `run()` de los seeders.

En este ejemplo se muestra un seeder que utiliza factories para crear categor√≠as, productos, ofertas y asignar productos a usuarios.

```php
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Product;
use App\Models\Category;
use App\Models\Offer;
use App\Models\User;

class ProductSeeder extends Seeder
{
    public function run(): void
    {
        // Crear categor√≠as
        $categories = Category::factory(5)->create();

        // Crear productos
        $products = Product::factory(50)->create();

        // Crear ofertas para algunos productos
        $products->random(10)->each(function ($product) {
            Offer::factory()->create([
                'product_id' => $product->id
            ]);
        });

        // Asignar productos a usuarios (carrito/favoritos)
        $users = User::factory(10)->create();
        $users->each(function ($user) use ($products) {
            $user->products()->attach(
                $products->random(rand(1, 5))->pluck('id')->toArray(),
                ['quantity' => rand(1, 3)]
            );
        });
    }
}
```

**Funciones Avanzadas**

La funci√≥n `each()` permite iterar sobre una colecci√≥n y aplicar una funci√≥n a cada elemento, facilitando la creaci√≥n de relaciones y datos adicionales de forma din√°mica.

Por otro lado, `pluck()` extrae un array con los valores de una columna espec√≠fica de la colecci√≥n, √∫til para obtener IDs u otros atributos.

## 5.6. Seeder Principal

Cuando se trabaja con bases de datos relacionales con claves for√°neas, **el orden de ejecuci√≥n de los seeders es crucial**. Se deben crear primero las entidades "padre" antes que las entidades "hijo" que dependen de ellas.

???examplelaravel "Analog√≠a: Protocolo de Montaje Oficial de BiblioTech S.A."

    **¬°Imagina que est√°s montando una biblioteca entera desde cero con los kits de BiblioTech S.A.! No puedes a√±adir un libro si la estanter√≠a no est√° montada.**

    * **Paso 1: Estanter√≠as (Tablas sin dependencias)** Primero, elegimos las `Categor√≠as` ("Ciencia Ficci√≥n", "Drama") y montamos las estanter√≠as. Tambi√©n podemos empezar a dar de alta `Usuarios`. Son independientes.
    * **Paso 2: Libros (Tablas con dependencias)** Una vez tienes las categor√≠as y autores, puedes empezar a catalogar los `Libros`. Cada libro necesita una categor√≠a (`category_id`). No se podr√≠a catalogar en ninguna estanter√≠a si no est√°n ya montadas.
    * **Paso 3: Conexiones y Detalles (Tablas pivote)** Con los libros y los usuarios ya en el sistema, puedes gestionar los `Pr√©stamos` (tabla `book_user`). Esta tabla conecta un `user_id` con un `book_id`, y no tendr√≠a sentido sin que ambos existan previamente.

    **El orden es crucial: no puedes hacer un pr√©stamo de un libro que a√∫n no has catalogado, ni asignar un libro a un usuario que no has registrado. El `DatabaseSeeder` es tu plan de montaje que garantiza que todo se construya en la secuencia correcta.**

Para ello hay que asegurarse de que las tablas que no tengan claves for√°neas deben ejecutarse primero, y las tablas que dependan de otras (por ejemplo, productos que dependen de categor√≠as) deben ejecutarse despu√©s.

Para ejecutar los seeders y poblar la base de datos, se utiliza el seeder principal `DatabaseSeeder`, que a su vez llama a los dem√°s seeders en el orden definido.

```php
<?php
namespace Database\Seeders;
use Illuminate\Database\Seeder;
class DatabaseSeeder extends Seeder
{
    public function run(): void
    {
        $this->call([
            UserSeeder::class,
            CategorySeeder::class,
            OfferSeeder::class,
            ProductSeeder::class,
            ProductUserSeeder::class,
        ]);
    }
}
```

En el siguiente diagrama se muestra un ejemplo de c√≥mo los seeders y factories trabajan juntos para poblar la base de datos. Estos deben ejecutarse en un orden espec√≠fico para respetar las relaciones de claves for√°neas entre tablas.

```mermaid
graph TD
    A[üë®‚Äçüíª Desarrollador] -->|sail artisan db:seed| B[üéØ DatabaseSeeder]
    B -->|1. Primero| C[üë• UserSeeder]
    B -->|2. Segundo| D[üìÅ CategorySeeder]
    B -->|3. Tercero| E[üéÅ OfferSeeder]
    B -->|4. Cuarto| F[üì¶ ProductSeeder]
    B -->|5. Quinto| G[üîó ProductUserSeeder]
    
    C -->|usa| H[üè≠ UserFactory]
    D -->|crea manual| I[(üóÑÔ∏è categories)]
    E -->|usa| J[üè≠ OfferFactory]
    F -->|usa| K[üè≠ ProductFactory]
    G -->|crea manual| L[(üóÑÔ∏è product_user)]
    
    H -->|genera 10 registros| M[(üóÑÔ∏è users)]
    I -->|inserta 3 categor√≠as| I
    J -->|genera ofertas| N[(üóÑÔ∏è offers)]
    K -->|genera 20 productos| O[(üóÑÔ∏è products)]
    L -->|inserta relaciones N:M| L
    
    M -->|‚úÖ foreign_key| L
    I -->|‚úÖ foreign_key| O
    O -->|‚úÖ foreign_key| N
    O -->|‚úÖ foreign_key| L
    
    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#e8f5e9
    style D fill:#e8f5e9
    style E fill:#e8f5e9
    style F fill:#e8f5e9
    style G fill:#e8f5e9
    style H fill:#f3e5f5
    style J fill:#f3e5f5
    style K fill:#f3e5f5
    style M fill:#ffebee
    style I fill:#ffebee
    style N fill:#ffebee
    style O fill:#ffebee
    style L fill:#ffebee
```
