# 2.2. Mapa de la Aplicaci√≥n

Cuando un usuario accede a una URL en una aplicaci√≥n Laravel, el framework necesita saber exactamente qu√© hacer con esa solicitud. Esta responsabilidad recae en dos pilares fundamentales: el **Sistema de Rutas** y los **Controladores**.

En esta secci√≥n se explorar√° el sistema de enrutamiento de Laravel, aprendiendo a definir rutas, manejar par√°metros din√°micos y crear controladores profesionales siguiendo el patr√≥n MVC. Se comprender√° c√≥mo separar claramente la l√≥gica de negocio de la presentaci√≥n, siguiendo las mejores pr√°cticas del framework.

???+examplelaravel "Analog√≠a: Sistema de Puertas y Personal del Aeropuerto"

    **Imagina Laravel como el sistema de gesti√≥n de puertas de un aeropuerto internacional.**

    * üó∫Ô∏è **Panel de Informaci√≥n (Rutas)** Las pantallas por todo el aeropuerto muestran: "Vuelo LV742 ‚Üí Puerta A12", "Vuelo IB531 ‚Üí Puerta B7" Esto es tu archivo `routes/web.php`: cada ruta dice "si buscas /products/42, ve al ProductController"
    * ÔøΩ‚Äç‚úàÔ∏è **Personal de Puerta (Controladores)** En cada puerta hay personal especializado de la aerol√≠nea:
  
        * `index()`: Muestra la lista de todos los vuelos disponibles.
        * `show(42)`: Busca informaci√≥n del vuelo espec√≠fico #42 
        * `create()`: Registra un nuevo vuelo en el sistema.
    * üé´ **El Viaje del Pasajero** Pasajero: "Necesito informaci√≥n del Vuelo 42" ‚Üí Mira el panel (ruta): "Vuelo 42 ‚Üí Puerta A12" ‚Üí Va a la puerta A12 ‚Üí El personal ejecuta `show(42)`: busca el vuelo y te da toda la informaci√≥n.

    **¬°Sin el panel de informaci√≥n, estar√≠as perdido en el aeropuerto! Sin el personal especializado, nadie te ayudar√≠a!**

## 2.1. Convenci√≥n Fundamental: Programa en Ingl√©s

**Laravel est√° dise√±ado para funcionar en ingl√©s.** Todos los nombres de archivos, clases, m√©todos, variables y rutas deben estar en **ingl√©s**, siguiendo las convenciones del idioma.

Laravel deduce autom√°ticamente nombres usando reglas del ingl√©s.

- `ProductController` ‚Üí busca en `resources/views/products/`. 
- Modelo `Product` ‚Üí busca tabla `products`.

```php
<?php
// Controladores (singular, PascalCase)
ProductController, CategoryController, UserController, OfferController

// Rutas (plural, kebab-case)
/products, /categories, /users, /offers

// M√©todos (verbos en ingl√©s, camelCase)
index(), show(), create(), store(), edit(), update(), destroy()

// Variables (descriptivas en ingl√©s, camelCase)
$product, $category, $totalPrice, $isActive
```

* **Controladores**: Singular + "Controller" ‚Üí `ProductController`, `CategoryController`
* **Rutas**: Plural en kebab-case ‚Üí `/products`, `/categories`, `/user-profiles`
* **Vistas**: Plural como carpeta ‚Üí `resources/views/products/index.blade.php`
* **M√©todos**: Verbos en ingl√©s ‚Üí `index()`, `show()`, `create()`, `store()`
* **Variables**: camelCase descriptivo ‚Üí `$product`, `$totalPrice`, `$isActive`

**üéØ A partir de ahora, todo el c√≥digo de este curso seguir√° estas convenciones.**

## 2.2. El Sistema de Enrutamiento de Laravel

Las rutas son las encargadas de dirigir cada solicitud HTTP a la parte correspondiente de la aplicaci√≥n. Laravel utiliza un sistema de enrutamiento que permite definir rutas de manera clara y mantenible.

### 2.2.1. Archivos de Rutas

Las rutas que responden a peticiones del navegador se definen principalmente en estos archivos:

* **`routes/web.php`**: Es el archivo de rutas de la aplicaci√≥n web. Estas rutas gestionan sesiones, cookies y protecci√≥n CSRF, lo que las hace ideales para cualquier interfaz con la que un usuario interact√∫e.
* **`routes/api.php`**: Se utiliza para definir las rutas de las API RESTful de la aplicaci√≥n. Estas rutas no incluyen middleware de sesi√≥n ni CSRF por defecto.
* **`routes/console.php`**: Para definir comandos de Artisan personalizados.

> **Nota**
> 
> Este curso se enfocar√° en `routes/web.php`, que es donde se definir√°n la mayor√≠a de las rutas para la interfaz web.

### 2.2.2. Tipos de Rutas seg√∫n el Verbo HTTP

Como se vio en la unidad 1, la web funciona con diferentes m√©todos o "verbos" HTTP para distintas acciones. Laravel permite registrar rutas para cada uno de ellos de forma muy sencilla. Los m√°s comunes son:

* **`Route::get($uri, $callback)`** - Para solicitar y mostrar datos (ej. ver productos, categor√≠as).
* **`Route::post($uri, $callback)`** - Para enviar y crear datos nuevos (ej. crear un producto).
* **`Route::put($uri, $callback)`** - Para actualizar un recurso completo (ej. actualizar un producto).
* **`Route::patch($uri, $callback)`** - Para actualizar parcialmente un recurso (ej. cambiar solo el precio).
* **`Route::delete($uri, $callback)`** - Para eliminar un recurso (ej. eliminar un producto).

Las rutas definen las p√°ginas que los usuarios pueden visitar relacionadas con productos. Aqu√≠ hay un ejemplo de c√≥mo se podr√≠an definir estas rutas en `routes/web.php`:

```php
<?php
// Fichero: routes/web.php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\ProductController;

// P√°gina de lista de productos - muestra todos los productos
Route::get('/products', [ProductController::class, 'index'])->name('home');

// P√°gina de detalle de un producto
Route::get('/products/{id}', [ProductController::class, 'show'])->name('products.show');

// P√°gina de creaci√≥n de un nuevo producto
Route::get('/products/create', [ProductController::class, 'create'])->name('products.create');
Route::post('/products', [ProductController::class, 'store'])->name('products.store');

// P√°gina de edici√≥n de un producto existente
Route::get('/products/{id}/edit', [ProductController::class, 'edit'])->name('products.edit');
Route::put('/products/{id}', [ProductController::class, 'update'])->name('products.update');

// Eliminar un producto
Route::delete('/products/{id}', [ProductController::class, 'destroy'])->name('products.destroy');
```

### 2.2.3. Rutas con M√∫ltiples Verbos HTTP

Laravel tambi√©n permite definir rutas que respondan a m√∫ltiples verbos HTTP:

```php
<?php
// Responde a GET, POST y ambos se dirigen al mismo m√©todo
Route::match(['get', 'post'], '/products/search', [ProductController::class, 'search']);

// Responde a cualquier verbo HTTP y todas las rutas se dirigen al mismo m√©todo
Route::any('/tags', [ProductController::class, 'handle']);
```

### 2.2.4. Rutas que Solo Muestran Vistas

Para casos muy simples donde una ruta solo debe mostrar una vista sin ninguna l√≥gica adicional, se puede usar un atajo. Las permiten definir una funci√≥n an√≥nima (o closure) que devuelve una vista directamente:



```php
<?php
// Fichero: routes/web.php

// En lugar de esto:
Route::get('/about', function () {
    return view('about');
});

Route::get('/contact', function () {
    return view('contact');
});

// Puedes usar esto:
Route::view('/about', 'about');
Route::view('/contact', 'contact');
```

### 2.2.5. Rutas con Par√°metros

A menudo, se necesitar√° enviar y capturar par√°metros por la URL. Por ejemplo, para mostrar un producto espec√≠fico se puede enviar el identificador del producto: `/products/123` donde `123` es el ID del producto. Laravel facilita la definici√≥n y captura de estos par√°metros.

#### Par√°metros Obligatorios

Se definen encerrando el nombre del par√°metro entre llaves `{}`. Este valor se pasar√° autom√°ticamente como argumento a la funci√≥n del controlador.



```php
<?php
// En routes/web.php
use App\Http\Controllers\ProductController;

// Definir una ruta con un par√°metro obligatorio {id}
Route::get('/products/{id}', [ProductController::class, 'show']);
```



```php
<?php
// En app/Http/Controllers/ProductController.php

// El m√©todo show recibe el ID del producto como argumento
public function show(string $id): View
{
    // Implementaci√≥n del m√©todo
}
```

#### Par√°metros Opcionales

Para que un par√°metro sea opcional, se a√±ade un signo de interrogaci√≥n `?` despu√©s de su nombre y se proporciona un valor por defecto en el m√©todo del controlador.



```php
<?php
// En routes/web.php

// Definir una ruta con un par√°metro opcional {category?}
Route::get('/products/{category?}', [ProductController::class, 'index']);
```



```php
<?php
// En app/Http/Controllers/ProductController.php

// El par√°metro $category es opcional y puede ser null
public function index(string $category = null): View
{
    // Si no se especifica categor√≠a, mostrar todos los productos
    return view('products.index', ['category' => $category]);
}
```

Seg√∫n si llega o no la categor√≠a:

* `/products/electronics` mostrar√° productos de electr√≥nica
* `/products` mostrar√° todos los productos

#### Restricciones con Expresiones Regulares

Se puede asegurar que un par√°metro de ruta tenga un formato espec√≠fico usando el m√©todo `where()`. Esto es especialmente √∫til para validar que los par√°metros cumplan con el formato esperado.



```php
<?php
// Solo acepta IDs num√©ricos para los productos
Route::get('/products/{id}', [ProductController::class, 'show'])->where('id', '[0-9]+');

// Solo aceptar√° categor√≠as con letras y guiones
Route::get('/category/{slug}', [CategoryController::class, 'show'])->where('slug', '[A-Za-z-]+');

// M√∫ltiples restricciones
Route::get('/products/{id}/offer/{offerId}', [ProductController::class, 'showOffer'])
    ->where(['id' => '[0-9]+', 'offerId' => '[0-9]+']);
```

#### Par√°metros con Model Binding

Laravel tambi√©n permite el **model binding**, donde autom√°ticamente resuelve un modelo Eloquent basado en el par√°metro de la ruta:



```php
<?php
// Laravel autom√°ticamente busca el modelo Product con el ID proporcionado
Route::get('/products/{product}', [ProductController::class, 'show']);

// En el controlador, recibir√°s directamente el modelo
public function show(Product $product): View
{
    // $product ya est√° resuelto autom√°ticamente
    return view('products.show', ['product' => $product]);
}
```

Avance: Modelos

Para entender completamente el model binding, es necesario conocer los **modelos Eloquent**, que se ver√°n en detalle m√°s adelante en el curso.

### 2.2.5. Rutas con Nombre

Asignar un nombre a una ruta es una de las mejores pr√°cticas en Laravel. En lugar de "`hardcodear`" (escribir directamente) las URLs en las vistas y redirecciones, se llama a las rutas por un nombre. Si en el futuro se cambia la URL, no se tendr√° que modificar nada m√°s en el c√≥digo.

Se definen encadenando el m√©todo `name()` y es habitual poner un prefijo que indique el recurso (como `products`) y la acci√≥n (como `index`):



```php
<?php
// En routes/web.php
Route::get('/products', [ProductController::class, 'index'])->name('products.index');

Route::get('/products/{id}', [ProductController::class, 'show'])->name('products.show');
```

Luego, en las vistas de Blade, se puede generar la URL f√°cilmente con a√±adiendo la funci√≥n `route()` en la referencia de los enlaces y en lugar de escribir la URL directamente se usa el nombre de la ruta:

```html
{{-- Enlace a todos los productos --}}
<a href="{{ route('products.index') }}">Todos los productos</a>

{{-- Enlace a un producto espec√≠fico --}}
<a href="{{ route('products.show', ['id' => $product->id]) }}">Ver detalles</a>
```

### 2.2.6. Agrupaci√≥n de Rutas

Cuando varias rutas comparten caracter√≠sticas comunes, se pueden agrupar para mantener el archivo de rutas limpio y organizado:



```php
<?php
// Agrupar rutas con un prefijo com√∫n
Route::prefix('admin')->group(function () {
    Route::get('/dashboard', [AdminController::class, 'dashboard']);
    Route::get('/users', [AdminController::class, 'users']);
    Route::get('/settings', [AdminController::class, 'settings']);
});

// Agrupar rutas con middleware com√∫n
Route::middleware(['auth'])->group(function () {
    Route::get('/profile', [UserController::class, 'profile']);
    Route::get('/settings', [UserController::class, 'settings']);
});

// Agrupar rutas con un namespace com√∫n
Route::namespace('Admin')->group(function () {
    Route::get('/admin/users', 'UserController@index');
    Route::get('/admin/posts', 'PostController@index');
});
```

### 2.2.7. Funcionalidades en las Rutas

Hasta ahora se ha visto c√≥mo definir rutas en Laravel y en estas a√±adir l√≥gica directamente en el archivo de rutas usando funciones an√≥nimas (closures), pero esto se convierte r√°pidamente en un problema:



```php
<?php
Route::get('/products/{id}', function (string $id) {
    // Implementaci√≥n de la l√≥gica aqu√≠
    return view('products.show', ['product' => $products[$id]]);
});

// ... y as√≠ con cada ruta
```

#### **Problemas de este enfoque:**

* üìÅ **Archivo enorme**: `routes/web.php` se vuelve inmanejable con cientos de l√≠neas
* üîÑ **C√≥digo duplicado**: Se repite la carga de datos en cada ruta
* üêõ **Dif√≠cil de testear**: No se puede probar la l√≥gica de forma aislada
* üìö **Mezcla de responsabilidades**: Las rutas definen URLs Y contienen l√≥gica de negocio
* üîç **Dif√≠cil de mantener**: Encontrar y modificar funcionalidad espec√≠fica es un caos

#### **La soluci√≥n profesional: Controladores**

Los **controladores** resuelven todos estos problemas organizando la l√≥gica en clases especializadas, separando claramente las responsabilidades y facilitando el mantenimiento del c√≥digo.

## 2.3. Controladores Profesionales

Un **controlador** es una clase de PHP cuya responsabilidad es agrupar la l√≥gica relacionada con las peticiones HTTP. Act√∫a como un intermediario que recibe la petici√≥n desde la ruta, interact√∫a con otras partes de la aplicaci√≥n (como los modelos, que se ver√°n m√°s adelante) y finalmente prepara y devuelve una respuesta, que normalmente es una vista.

Los controladores permiten separar la l√≥gica de negocio de la presentaci√≥n, siguiendo el patr√≥n **MVC (Modelo-Vista-Controlador)** que vimos en la primera sesi√≥n.

???+examplelaravel "Analog√≠a del Controlador como Torre de Control A√©reo"

    Imagina el controlador como un controlador a√©reo en la torre de control del aeropuerto:

    * **Recibe la solicitud de aterrizaje/despegue** (petici√≥n HTTP) del piloto
    * **Coordina con diferentes departamentos** (modelos, servicios): meteorolog√≠a, servicios en tierra, tr√°fico a√©reo
    * **Verifica permisos y disponibilidad** (l√≥gica de negocio): pista libre, condiciones meteorol√≥gicas, slot horario
    * **Autoriza y dirige la operaci√≥n** (procesa datos): "Vuelo 742, autorizado aterrizaje pista 12L"
    * **Comunica el resultado al piloto** (respuesta): instrucciones claras de qu√© hacer y d√≥nde ir

    ¬°El controlador a√©reo no pilota el avi√≥n ni carga equipaje, solo coordina y autoriza operaciones!

### 2.3.1. Tipos de Controladores

Existen varios tipos de controladores en Laravel, cada uno con su prop√≥sito espec√≠fico.

#### Controladores de Acci√≥n √önica (Invokable)

Son controladores dise√±ados para hacer una sola cosa. Son muy √∫tiles para tareas simples y espec√≠ficas. Se crean con el flag `--invokable`.



```bash
php artisan make:controller HomeController --invokable
```

Este controlador solo tendr√° un m√©todo: `__invoke()`. Para registrarlo en las rutas, no se necesita especificar el m√©todo.



```php
<?php
// En routes/web.php
use App\Http\Controllers\HomeController;

Route::get('/', HomeController::class)->name('home');
```

#### Controladores de Recursos (Resource)

Este es el tipo de controlador m√°s potente y com√∫n para gestionar entidades de la aplicaci√≥n (como usuarios, productos, posts, etc.). Un controlador de recursos agrupa toda la l√≥gica **CRUD** (Crear, Leer, Actualizar, Borrar) para un modelo.

Se crean con el flag **`--resource`**:



```bash
php artisan make:controller ProductController --resource
```

Este comando genera un controlador con 7 m√©todos predefinidos, cada uno mapeado a una acci√≥n CRUD espec√≠fica:

* `index()`: Mostrar una lista de todos los recursos (ej. todos los productos).
* `create()`: Mostrar el formulario para crear un nuevo recurso.
* `store(Request $request)`: Guardar el nuevo recurso en la base de datos.
* `show($id)`: Mostrar un recurso espec√≠fico.
* `edit($id)`: Mostrar el formulario para editar un recurso existente.
* `update(Request $request, $id)`: Actualizar el recurso en la base de datos.
* `destroy($id)`: Eliminar el recurso de la base de datos.

Lo mejor es que no se tiene que registrar una ruta para cada uno de estos m√©todos. Laravel da un atajo m√°gico:



```php
<?php
// En routes/web.php
use App\Http\Controllers\ProductController;

Route::resource('products', ProductController::class);
```

Esa sola l√≠nea de c√≥digo crea autom√°ticamente las 7 rutas necesarias para todo el flujo CRUD, con sus verbos HTTP y nombres de ruta correctos:

* **`GET /products`** ‚Üí `ProductController@index` (listar productos)
* **`GET /products/create`** ‚Üí `ProductController@create` (formulario crear producto)
* **`POST /products`** ‚Üí `ProductController@store` (guardar nuevo producto)
* **`GET /products/{id}`** ‚Üí `ProductController@show` (mostrar producto)
* **`GET /products/{id}/edit`** ‚Üí `ProductController@edit` (formulario editar)
* **`PUT /products/{id}`** ‚Üí `ProductController@update` (actualizar producto)
* **`DELETE /products/{id}`** ‚Üí `ProductController@destroy` (eliminar producto)

### 2.3.2. Rutas Adicionales en Controladores Resource

Aunque las rutas resource son muy convenientes, a veces se necesitan rutas adicionales espec√≠ficas para funcionalidades que no encajan en el patr√≥n CRUD est√°ndar. Cuando se combina `Route::resource()` con rutas personalizadas adicionales, el orden de declaraci√≥n se vuelve crucial.

El Orden Importa

Las rutas custom **DEBEN definirse ANTES** de la ruta resource. Laravel procesa las rutas en el orden en que aparecen en el archivo, y la primera que coincida con la URL ser√° la que se ejecute.

#### ¬øPor qu√© el orden es importante?



```php
<?php
// ‚ùå INCORRECTO - La ruta resource captura "on-sale" como un {id} de la ruta show
Route::resource('products', ProductController::class);
Route::get('/products/on-sale', [ProductController::class, 'onSale']); // ¬°Nunca se ejecuta!
```

1. Usuario visita `/products/on-sale`
2. Laravel comprueba las primeras rutas creadas con resource: `Route::resource('products', ...)`
3. Las rutas resource tienen `GET /products/{id}`, donde `{id}` puede ser cualquier cosa
4. Laravel interpreta "on-sale" como un ID y ejecuta `show('on-sale')`
5. El controlador busca un producto con ID "on-sale" y falla
6. La ruta custom nunca se alcanza



```php
<?php
// ‚úÖ CORRECTO - La ruta custom se define primero
Route::get('/products/on-sale', [ProductController::class, 'onSale'])->name('products.on-sale');
Route::resource('products', ProductController::class);
```

## 2.4. Creando Nuestra Primera Conexi√≥n (Paso a Paso)

Se va a definir la primera ruta y asociarla a un m√©todo en un controlador. Se reemplazar√° la ruta de bienvenida por defecto para que sea gestionada por el propio controlador.

### Paso 1: Crear el Controlador

Se usar√° **Artisan**, la herramienta de l√≠nea de comandos de Laravel, para crear el controlador. Se abre el terminal en la ra√≠z del proyecto y se ejecuta:



```bash
php artisan make:controller HomeController
```

Este comando crear√° un nuevo archivo en `app/Http/Controllers/HomeController.php`.

### Paso 2: A√±adir un M√©todo al Controlador

Ahora, se abre el archivo `app/Http/Controllers/HomeController.php` y se a√±ade un m√©todo p√∫blico. Se llamar√° `index`. Este m√©todo se encargar√° de la l√≥gica para la p√°gina de inicio. Por ahora, simplemente devolver√° la vista de bienvenida.



```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\View\View; // Es buena pr√°ctica importar la clase View

class HomeController extends Controller
{
    /**
     * Muestra la p√°gina de inicio del blog.
     */
    public function index(): View
    {
        return view('welcome');
    }
}
```

> **Nota de PHP 8.4:** Observa que hemos a√±adido `: View` al m√©todo. Esto se llama **tipado de retorno** y le indica a PHP que esta funci√≥n siempre debe devolver un objeto de tipo `View`. Es una pr√°ctica moderna que hace el c√≥digo m√°s robusto y f√°cil de entender.

### Paso 3: Conectar la Ruta con el Controlador

Finalmente, se vuelve al archivo `routes/web.php` y se modifica la ruta ra√≠z para que, en lugar de usar una funci√≥n, "llame" al m√©todo `index` del nuevo `HomeController`.



```php
<?php
// Fichero: routes/web.php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\HomeController; // ¬°No olvides importar el controlador!

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
*/

// La sintaxis es: Route::verbo('url', [Controlador::class, 'metodo']);
Route::get('/', [HomeController::class, 'index'])->name('home');
```

## 2.5. Helpers Comunes de Laravel

Laravel incluye una gran cantidad de funciones auxiliares (helpers) que hacen el desarrollo m√°s eficiente y seguro. Estas funciones est√°n disponibles globalmente en toda la aplicaci√≥n y son especialmente √∫tiles en controladores y vistas.

### `abort()`: Manejo de Errores HTTP

La funci√≥n `abort()` permite detener la ejecuci√≥n de la aplicaci√≥n y devolver una respuesta HTTP de error de forma inmediata. Es muy √∫til para validaciones de seguridad y manejo de casos edge.



```php
<?php
// En un controlador
public function show(string $id): View
{
    $product = $this->find($id);
    
    // Si el producto no existe, devolver error 404
    if (!$product) {
        abort(404, 'Producto no encontrado');
    }
    
    // Si el usuario no tiene permisos, devolver error 403
    if (!$this->userCanView($product)) {
        abort(403, 'No tienes permisos para ver este producto');
    }
    
    return view('products.show', ['product' => $product]);
}
```

**¬øPor qu√© usar `abort()`?** En aplicaciones reales, se necesita manejar situaciones donde algo sale mal: un usuario intenta acceder a un producto que no existe, o alguien sin permisos intenta ver contenido privado. `abort()` permite manejar estos casos de forma elegante y consistente.

### `dd()`: Depuraci√≥n y Desarrollo

La funci√≥n `dd()` (dump and die) es una herramienta de depuraci√≥n que imprime informaci√≥n sobre variables y detiene la ejecuci√≥n del script. Es extremadamente √∫til durante el desarrollo para inspeccionar datos.



```php
<?php
public function index(): View
{
    $products = $this->all();
    
    // Durante el desarrollo, puedes inspeccionar los datos
    dd($products); // Esto mostrar√° el contenido y detendr√° la ejecuci√≥n
    
    return view('products.index', ['products' => $products]);
}
```

**¬øPor qu√© es importante `dd()`?** Durante el desarrollo, se necesita verificar que los datos tienen la estructura correcta antes de pasarlos a las vistas. `dd()` permite inspeccionar arrays, objetos, y cualquier variable de forma clara y estructurada, evitando errores en tiempo de ejecuci√≥n.

### Helpers de Rutas de Archivos

Laravel proporciona funciones helper para construir rutas de archivos de forma segura y consistente, independientemente del sistema operativo.

#### `database_path()`

Esta funci√≥n devuelve la ruta completa al directorio `database` de la aplicaci√≥n Laravel.



```php
<?php
// Cargar datos mock desde la carpeta database
$products = require database_path('data/mock-products.php');

// Acceder a un archivo de migraci√≥n
$migrationFile = database_path('migrations/2025_01_15_create_products_table.php');
```

#### `base_path()`

Esta funci√≥n devuelve la ruta completa al directorio ra√≠z de la aplicaci√≥n Laravel.



```php
<?php
// Acceder a archivos en la ra√≠z del proyecto
$configFile = base_path('config/app.php');

// Acceder a archivos en subdirectorios
$envFile = base_path('.env');
$composerFile = base_path('composer.json');
```

**¬øPor qu√© usar estos helpers?** En lugar de escribir rutas como `'../database/data/mock-products.php'` o `__DIR__ . '/../../database/data/mock-products.php'`, estos helpers dan rutas absolutas y seguras. Esto es especialmente importante cuando la aplicaci√≥n se despliega en diferentes entornos (desarrollo, producci√≥n) donde las rutas relativas pueden fallar.

