# 2.6. Datos mock

En el desarrollo de aplicaciones web, especialmente durante las fases iniciales de un proyecto, es una prÃ¡ctica profesional trabajar con **datos mock** (datos de prueba simulados) en lugar de depender inmediatamente de una base de datos real. Los datos mock permiten desarrollar y probar funcionalidades de forma Ã¡gil, sin la complejidad inicial de configurar y mantener una base de datos completa.

???examplelaravel "AnalogÃ­a: Simulador de Vuelo para Entrenar Pilotos"

    **Â¡Imagina que estÃ¡s entrenando pilotos para una aerolÃ­nea!**

    * âœˆï¸ **Sin simulador (el camino peligroso y caro)** Usas un aviÃ³n real Boeing 737 valorado en 100 millones de euros, quemas combustible real (miles de euros/hora), y arriesgas vidas si el piloto en entrenamiento comete errores.
    * ğŸ® **Con simulador de vuelo (el camino profesional)** Usas datos mock: clima simulado, aeropuertos virtuales, emergencias artificiales, pasajeros ficticios. Â¡Son falsos, pero el piloto aprende TODAS las maniobras sin riesgo ni coste!
    * âœ… **Lo real funciona con lo simulado** La cabina es real, los controles son reales, los procedimientos son reales, el sistema de navegaciÃ³n es real. Solo los "datos del vuelo" son simulados. Â¡Pero todo funciona exactamente igual!
    * ğŸ‰ **El primer vuelo real** El piloto entrenado sube al aviÃ³n verdadero. Â¡Sabe hacer TODO porque lo practicÃ³ mil veces! Solo los datos son ahora reales.
    * ğŸ’¡ **La gran ventaja** Has entrenado cientos de pilotos, probado miles de escenarios (tormentas, fallos de motor, aterrizajes de emergencia) sin gastar millones ni arriesgar vidas.

    **Â¡AsÃ­ funcionan los datos mock en Laravel! Te permiten construir y probar TODO sin depender de una base de datos real.**

Los datos mock ofrecen mÃºltiples beneficios durante el desarrollo:

ğŸ’¡**Desarrollo rÃ¡pido**: No requiere configuraciÃ³n de base de datos.

ğŸ’¡**Datos consistentes**: Mismos datos para todos los desarrolladores del equipo.

ğŸ’¡**FÃ¡cil testing**: Datos predecibles para pruebas.

ğŸ’¡**Simplicidad**: Estructura simple y fÃ¡cil de entender.

ğŸ’¡**Versionado**: Los datos mock se pueden versionar con Git.

ğŸ’¡**CentralizaciÃ³n**: Un solo lugar para modificar los datos de toda la aplicaciÃ³n.

ğŸ’¡**Sin duplicaciÃ³n**: Evita repetir datos en cada controlador.


ğŸ‘¥ Cuando varios desarrolladores **trabajan en el mismo proyecto**:

* **Sin datos mock centralizados**: Cada desarrollador crea sus propios datos de prueba. *Ana tiene 5 productos, Carlos tiene 8, y MarÃ­a tiene 3*. Caos total cuando intentan integrar su cÃ³digo.
* **Con datos mock centralizados**: Todos comparten `mock-products.php` con los mismos 10 productos. El cÃ³digo de Ana funciona en el ordenador de Carlos sin cambios.
* **Cambios coordinados**: Si Ana actualiza el precio de un producto en el mock, automÃ¡ticamente Carlos y MarÃ­a ven ese cambio en su prÃ³ximo `git pull`.
* **Testing consistente**: Las pruebas funcionan igual para todos porque usan los mismos datos base.

Â¡Los datos mock centralizados son como tener un "idioma comÃºn" para todo el equipo!

## 1. Estructura de Datos Mock

En Laravel, los datos mock se organizan tÃ­picamente en el directorio **`database/data/`**. AquÃ­ es donde se almacenan los archivos PHP que devuelven arrays con los datos simulados.

Cada archivo mock devuelve un array PHP con la estructura de datos correspondiente. A veces puede ser Ãºtil tener un array asociativo con IDs como claves para facilitar bÃºsquedas rÃ¡pidas.

* Array de elementos simples:

  ```php
  <?php

  return [
      [
          'id' => 1,
          'name' => 'CategorÃ­a 1',
          'description' => 'DescripciÃ³n de la categorÃ­a 1'
      ],
      [
          'id' => 2,
          'name' => 'CategorÃ­a 2',
          'description' => 'DescripciÃ³n de la categorÃ­a 2'
      ],
  ];
  ```
* Array asociativo con IDs como claves:

  ```php
  <?php

  return [
      1 => [
          'name' => 'Producto 1',
          'description' => 'DescripciÃ³n del producto 1'
          'category_id' => 1
      ],
      2 => [
          'name' => 'Producto 2',
          'description' => 'DescripciÃ³n del producto 2'
          'category_id' => 1
      ],
  ];
  ```

Dependiendo de las necesidades, puedes elegir el formato que mejor se adapte a tu caso.

**Helper `database\_path()`**

Laravel proporciona el helper **`database_path()`** que devuelve la ruta completa al directorio `database/` de la aplicaciÃ³n. Esto permite cargar archivos de forma segura independientemente del sistema operativo.

## 2. Traits: reutilizando cÃ³digo entre controladores

### 2.1. Â¿QuÃ© es un Trait?

Un **trait** es un mecanismo de reutilizaciÃ³n de cÃ³digo en PHP que permite compartir mÃ©todos entre mÃºltiples clases. Es especialmente Ãºtil cuando varias clases necesitan la misma funcionalidad pero no pueden heredar de una clase comÃºn.

???examplelaravel "AnalogÃ­a: Trait como Sistema Centralizado de Equipamiento del Aeropuerto"

    âœˆï¸ **Imagina un aeropuerto internacional con mÃºltiples aerolÃ­neas operando:**

    * **MÃºltiples aerolÃ­neas** operan vuelos diferentes desde el mismo aeropuerto
    * **Todas necesitan** los mismos servicios bÃ¡sicos: sistema de check-in, escÃ¡neres de seguridad, equipos de comunicaciÃ³n, tractores de equipaje
    * **Sin trait**: Cada aerolÃ­nea instala su propio check-in, sus propios escÃ¡neres, sus propios tractores. Si el escÃ¡ner falla, hay que reparar 5 escÃ¡neres diferentes.
    * **Con trait**: El aeropuerto proporciona infraestructura centralizada compartida. Un escÃ¡ner para todas las aerolÃ­neas. Una averÃ­a = una reparaciÃ³n.
    * **AÃ±ades un nuevo sistema de embarque automatizado**: AutomÃ¡ticamente todas las aerolÃ­neas pueden usarlo sin que tengas que instalarlo puerta por puerta.
    * **Cada aerolÃ­nea** sigue gestionando sus propios vuelos, rutas y pasajeros (su lÃ³gica especÃ­fica), pero comparte la infraestructura bÃ¡sica del aeropuerto.

    Â¡AsÃ­ funcionan los traits! Son la "infraestructura compartida del aeropuerto" que todos los controladores usan sin duplicar cÃ³digo.

Los traits ofrecen mÃºltiples ventajas cuando se trabaja con datos mock:

ğŸ’¡**DRY (Don't Repeat Yourself)**: Elimina la duplicaciÃ³n de cÃ³digo.

ğŸ’¡**Mantenimiento centralizado**: Un solo lugar para modificar la lÃ³gica de carga.

ğŸ’¡**Consistencia**: Todos los controladores usan los mismos mÃ©todos.

ğŸ’¡**Escalabilidad**: FÃ¡cil aÃ±adir nuevos mÃ©todos al trait.

ğŸ’¡**Legibilidad**: Los controladores se enfocan en su lÃ³gica especÃ­fica.

ğŸ’¡**Testing**: MÃ¡s fÃ¡cil probar la lÃ³gica de carga de datos.


### 2.2. Crear el Trait para Datos mock

Los traits son ideales para centralizar los mÃ©todos de carga de datos mock que varios controladores necesitan.

Si varios controladores necesitan cargar datos desde archivos mock, en lugar de repetir los mismos mÃ©todos en cada controlador, se puede crear un trait **`LoadsMockData`** que contenga todos estos mÃ©todos.

```php
<?php
// Fichero: app/Traits/LoadsMockData.php

namespace App\Traits;

trait LoadsMockData
{
    /**
     * Load categories from mock file
     */
    protected function getCategories(): array
    {
        return require database_path('data/mock-categories.php');
    }


    /**
     * Load products from mock file
     */
    protected function getProducts(): array
    {
        return require database_path('data/mock-products.php');
    }

    /**
     * Load all mock data at once
     */
    protected function getAllMockData(): array
    {
        return [
            'categories' => $this->getCategories(),
            'offers' => $this->getOffers(),
            'cart' => $this->getCart(),
            'products' => $this->getProducts(),
        ];
    }
}
```

### 2.3. Uso de Traits

Los traits se incluyen en una clase usando la palabra clave **`use`**. Esto hace que todos los mÃ©todos del trait estÃ©n disponibles en la clase.

```php
<?php

namespace App\Http\Controllers;

use App\Traits\LoadsMockData;
use Illuminate\Http\Request;
use Illuminate\View\View;

class ProductController extends Controller
{
    use LoadsMockData; // Â¡Una lÃ­nea da acceso a todos los mÃ©todos!

    
    public function index(): View
    {
       // ImplementaciÃ³n para listar productos
       $products = $this->getProducts(); // MÃ©todo del trait
       // ... lÃ³gica adicional ...
    }

    // Otros mÃ©todos del controlador...
}
```

## 3. Funciones avanzadas con datos mock

### 3.1. Filtrado de datos con array\_filter()

La funciÃ³n **`array_filter()`** de PHP permite filtrar elementos de un array segÃºn una condiciÃ³n.

```php
$products = $this->getProducts();
$filtered = array_filter($products, function($product) {
    return $product['price'] > 50;  // Filtra productos con precio mayor a 50
});
```

### 3.2 TransformaciÃ³n de datos con array\_map()

La funciÃ³n **`array_map()`** de PHP permite transformar cada elemento de un array aplicando una funciÃ³n a cada uno.

```php
$products = $this->getProducts();
$categories = $this->getCategories();
$enrichedProducts = array_map(function($product) use ($categories) {
    $product['category'] = $categories[$product['category_id']] ?? null;    
    return $product;
}, $products);


// Retorna productos enriquecidos con datos de categorÃ­a

[
    1 => [
        'name' => 'Producto 1',
        'description' => 'DescripciÃ³n del producto 1'
        'category_id' => 1,
        'category' => [
            'name' => 'CategorÃ­a 1',
            'description' => 'DescripciÃ³n de la categorÃ­a 1'
        ]
    ],
    2 => [
        'name' => 'Producto 2',
        'description' => 'DescripciÃ³n del producto 2',
        'category_id' => 1,
        'category' => [
            'name' => 'CategorÃ­a 1',
            'description' => 'DescripciÃ³n de la categorÃ­a 1'
        ]
    ],
]
```

### 3.3. BÃºsqueda por ID con operador ??

El operador **`??`** (null coalescing) es perfecto para buscar elementos por ID:

```php
// Buscar producto con ID 5
$product = $products[3] ?? null;

// Si existe: $product tiene los datos
// Si no existe: $product es null

// Luego validar
if (!$product) {
    abort(404, 'Producto no encontrado');
}
```
