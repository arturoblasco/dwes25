El concepto de *inyección de dependencias* es muy habitual en el uso de frameworks. Consiste en un mecanismo que facilita recursos a los diferentes componentes de la aplicación, y es algo que ya hemos utilizado, sin saberlo, en los métodos que se han generado para los controladores.

## 1. Inyectando la petición del usuario

Cuando necesitas trabajar con datos que el cliente envía a tu aplicación, *Laravel* puede inyectar automáticamente un objeto de tipo `Request` en los métodos de tus controladores. Automáticamente, *Laravel* procesa el tipo de dato y obtiene el objeto asociado (en este caso, la petición del cliente).

```bash
class LibroController extends Controller
{
    public function store(Request $request)
    {
        // Aquí podemos usar $request para acceder a los datos enviados por el cliente
    }
}
```

- **Ventaja:** No necesitas crear ni configurar el objeto `Request`, Laravel lo hace por tí.

- **Uso común:** Obtener datos enviados por el cliente mediante `$request->input('campo')` o `$request->all()`.

## 2. Inyectando la respuesta del servidor

Además de manejar peticiones, los controladores pueden gestionar respuestas que se envían de vuelta al cliente. *Laravel* proporciona un método `response` al que le podemos pasar varios parámetros:

### 2.1. Generar respuestas básicas

1. **El contenido de la respuesta** (por ejemplo, un mensaje).
2. **El código de estado HTTP** (por defecto es `200`).
3. **Cabeceras adicionales** (opcional).

!!!examplelaravel "Ejemplo:"
    ```bash
    return response("Mensaje de respuesta", 201)
        ->header('Content-Type', 'text/plain');
    ```

### 2.2. Respuestas en formato JSON

Cuando necesitas devolver datos en formato JSON (muy común en APIs), puedes usar `response()->json()`.
!!!examplelaravel "Ejemplo:"
    ```bash
    return response()->json(['mensaje' => 'Éxito'], 201)
    ->header('Custom-Header', 'Valor');
    ```


## 3. Redirecciones con respuestas
Laravel facilita las redirecciones mediante el método redirect. Esto es útil para enviar al usuario a otra página o ruta después de completar una acción.

### 3.1. Redirección básica
Redirige a la raíz del sitio:

```bash
return redirect('/');
```
Redirige a una ruta específica usando su nombre:

```bash
return redirect()->route('inicio');
```
### 3.2. Pasar datos a la redirección
Puedes incluir datos temporales en la redirección usando el método **`with`**. Estos datos estarán disponibles solo en la próxima solicitud.

!!!examplelaravel "Ejemplo:"
    ```bash
    return redirect()->route('inicio')->with('mensaje', 'Guardado correctamente');
    En la vista, puedes acceder al mensaje usando la función session:
    ```
    ```bash
    @if(session()->has('mensaje'))
        <p>{{ session('mensaje') }}</p>
    @endif
    ```

### 3.3. Redirección desde controladores
Si realizas una redirección dentro de un controlador, recuerda usar **`return`** para que *Laravel* la procese correctamente.

!!!examplelaravel "Ejemplo:"
    ```bash
    class LibroController extends Controller
    {
        public function store(Request $request)
        {
            // Lógica para guardar datos
            return redirect()->route('libros.index');
        }
    }
    ```


## 4. Los *helpers*

Un **helper** es básicamente una función de utilidad que podemos querer utilizar en diversos puntos de nuestra web, y que necesitamos tener localizada y compartida. Son una forma eficiente de centralizar lógica común que no está directamente relacionada con las clases o métodos principales.

A continuación, se explica cómo crear y utilizar *helpers* en Laravel mediante el **ejemplo práctico: resaltar el menú activo**.

!!!examplelaravel "ejemplo práctico: resaltar el menú activo"
    Queremos resaltar en el menú de navegación la opción correspondiente a la página que el usuario está visitando. Para lograrlo:

    1. **Define una clase CSS** (por ejemplo, `activo`) en tus estilos para destacar el menú activo.
    2. Usa la función `request()->routeIs()` de Laravel para determinar si la ruta actual coincide con la ruta del menú.
    En una vista Blade, podríamos escribir el siguiente código:
    
    ```html
    <nav>
        <ul>
            <li class="{{ request()->routeIs('inicio') ? 'activo' : '' }}">
                <a href="/">Inicio</a>
            </li>
            <li class="{{ request()->routeIs('contacto') ? 'activo' : '' }}">
                <a href="/contacto">Contacto</a>
            </li>
        </ul>
    </nav>
    ```
    
    **¿Cómo funciona?**
    
    - `request()->routeIs('inicio')`: Verifica si la ruta actual coincide con `'inicio'`.
    - Operador ternario: Si la ruta coincide, se añade la clase `activo`; si no, se deja vacío.


### 4.1. Crear un helper para centralizar la lógica
Para mejorar el mantenimiento y legibilidad del código, extraemos esta lógica a un helper llamado `setActivo`.

**4.1.1. Crea un archivo de helper**<br />
Crea un archivo llamado `helpers.php` en la carpeta `app` (o cualquier ubicación adecuada).

Contenido del archivo:

```php
<?php

function setActivo($nombreRuta)
{
    return request()->routeIs($nombreRuta) ? 'activo' : '';
}
```

**4.1.2. Usar el helper en la vista**<br />
Ahora, en lugar de escribir la lógica directamente en la vista, simplemente llamamos a `setActivo()`:

```bash
<nav>
    <ul>
        <li class="{{ setActivo('inicio') }}">
            <a href="/">Inicio</a>
        </li>
        <li class="{{ setActivo('contacto') }}">
            <a href="/contacto">Contacto</a>
        </li>
    </ul>
</nav>
```
**Ventaja**: La vista es más limpia y la lógica está centralizada en el *helper*.

### 4.2. Usar comodines para rutas anidadas
Si queremos que el enlace permanezca activo en subrutas (por ejemplo, al visualizar detalles de un registro desde una lista), usamos el comodín **`*`** en la función `routeIs()`.

!!!examplelaravel "Ejemplo con comodines"
	```html
	<li class="{{ setActivo('peliculas.*') }}">
        <a href="{{ route('peliculas') }}">Películas</a>
    </li>
	```

### 4.3. Hacer que Laravel cargue el helper
Por defecto, *Laravel* no carga archivos *PHP* que no sean clases. Para asegurarnos de que el archivo `helpers.php` esté disponible en toda la aplicación, debemos configurarlo en `composer.json`.

**4.3.1. Modifica composer.json**<br />
En la raíz de tu proyecto, abre el archivo `composer.json` y añade el archivo *helpers.php* en la sección *autoload*:

```json
"autoload": {
    "classmap": [],
    "psr-4": {
        "App\\": "app/"
    },
    "files": [
        "app/helpers.php"
    ]
}
```
**4.3.2. Actualiza el autoloader**<br />
Ejecuta el siguiente comando en la terminal para que *Composer* reconozca el nuevo archivo:

```bash
composer dump-autoload
```


??? questionlaravel "Ejercicios a realizar"
	-  `Ejercicio 2`.