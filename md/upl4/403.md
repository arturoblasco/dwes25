# 4.3. Manejo de Sesiones y Estado

En el **apartado 2** dominaste la validaci√≥n de datos de formularios. Pero hay un problema fundamental: **HTTP es un protocolo stateless** (sin estado), lo que significa que el servidor no recuerda qui√©n eres entre peticiones.

Las sesiones son un mecanismo fundamental para mantener informaci√≥n del usuario entre m√∫ltiples peticiones HTTP. Permiten que las aplicaciones web mantengan el contexto del usuario, como el estado de login, preferencias, carritos de compra y otros datos temporales.

## 1. Fundamentos de las Sesiones

### 1.1. ¬øQu√© es una Sesi√≥n?

Una sesi√≥n es un mecanismo que permite almacenar informaci√≥n del usuario en el servidor y asociarla con un identificador √∫nico que se env√≠a al cliente. Esta informaci√≥n persiste entre m√∫ltiples peticiones HTTP.

???examplelaravel "Analog√≠a: Analog√≠a: La Pulsera Identificativa del Festival"

    **¬°Imagina que una sesi√≥n web es como la pulsera identificativa que te dan al entrar a un festival de m√∫sica!**

    üé´ **Al entrar al festival (Primera petici√≥n):**

    * Llegas y muestras tu ticket
    * Te dan una **pulsera con chip NFC √∫nico** ‚Üí Laravel crea sesi√≥n con ID √∫nico
    * Ese c√≥digo identifica qui√©n eres durante todo el festival

    üé∏ **Moverte entre escenarios (Peticiones HTTP):**

    * Vas al escenario principal ‚Üí Escanean tu pulsera (Laravel lee el ID de sesi√≥n)
    * Vas a la zona de comida ‚Üí Escanean de nuevo (otra petici√≥n, misma sesi√≥n)
    * Vas al ba√±o VIP ‚Üí Verifican que tienes acceso VIP (datos almacenados en la sesi√≥n)

    üóÑÔ∏è **El sistema del festival recuerda:**

    * Tu nombre y tipo de entrada (datos del usuario autenticado)
    * Tus compras acumuladas (carrito de compra)
    * Tu zona de camping asignada (preferencias del usuario)
    * Si tienes acceso VIP o backstage (roles y permisos)

    üö™ **Al salir del festival (Logout/Expiraci√≥n):**

    * Cortan tu pulsera al salir ‚Üí Laravel destruye la sesi√≥n
    * Si intentas volver a entrar con la pulsera cortada ‚Üí rechazado
    * Necesitas un nuevo ticket para una nueva pulsera ‚Üí nuevo login

    **¬°Sin la pulsera, el festival no sabr√≠a qui√©n eres en cada zona!****¬°Sin sesiones, Laravel no sabr√≠a qui√©n eres en cada petici√≥n!**

### 1.2. ¬øPor qu√© son Necesarias las Sesiones?

HTTP es un protocolo **stateless** (sin estado), lo que significa que cada petici√≥n es independiente y el servidor no recuerda peticiones anteriores. Las sesiones resuelven este problema:

| Problema sin Sesiones | Soluci√≥n con Sesiones |
| --- | --- |
| No se recuerda el login | Estado de autenticaci√≥n persistente |
| No se mantiene el carrito | Carrito de compra persistente |
| No se recuerdan preferencias | Configuraciones del usuario |
| No se puede personalizar | Experiencia personalizada |

### 1.3. Flujo de una Sesi√≥n

A continuaci√≥n se visualiza c√≥mo funciona una sesi√≥n desde que el usuario entra hasta que navega por la aplicaci√≥n:

```mermaid
sequenceDiagram
    participant U as üë§ Usuario
    participant B as üåê Navegador
    participant L as ‚ö° Laravel
    participant S as üóÑÔ∏è Almac√©n Sesi√≥n

    Note over U,S: üé´ Primera Visita - Dar la Pulsera
    U->>B: Visita la aplicaci√≥n
    B->>L: GET / (sin cookie de sesi√≥n)
    L->>L: Genera ID de sesi√≥n √∫nico
    Note over L: Session ID: abc123xyz789
    L->>S: Almacena datos de sesi√≥n vac√≠os
    S-->>L: OK
    L->>B: Responde HTML + Set-Cookie
    Note over B: laravel_session=abc123xyz789
    B->>B: Almacena cookie
    B-->>U: Muestra p√°gina de inicio
    
    Note over U,S: üö∂ Segunda Petici√≥n - Escanear Pulsera
    U->>B: Navega a /dashboard
    B->>L: GET /dashboard + Cookie (abc123xyz789)
    L->>S: ¬øDatos de abc123xyz789?
    S-->>L: {"user_id": 42, "vip": true}
    L->>L: Procesa con contexto del usuario 42
    L-->>B: Dashboard personalizado
    B-->>U: Muestra "Bienvenido, Juan"
```

El Session ID es la Clave de Todo

**El Session ID** (ejemplo: `abc123xyz789`) es el **√∫nico v√≠nculo** entre el navegador del usuario y sus datos en el servidor.

* **Se env√≠a como cookie** en cada petici√≥n HTTP
* **Laravel lo verifica** autom√°ticamente en cada request
* **Si la cookie se pierde o expira**, el usuario pierde su sesi√≥n
* **Si alguien roba tu cookie de sesi√≥n** ‚Üí puede suplantar tu identidad

**Por eso Laravel protege las sesiones:**

* ‚úÖ Tokens largos y aleatorios (imposible adivinar)
* ‚úÖ Cookies `HttpOnly` (JavaScript no puede leerlas)
* ‚úÖ Cookies `Secure` en HTTPS (solo conexi√≥n segura)
* ‚úÖ Regenera el ID despu√©s del login (previene session fixation)

## 2. Configuraci√≥n de Sesiones en Laravel

Laravel permite configurar c√≥mo y d√≥nde se almacenan las sesiones. La configuraci√≥n se encuentra en el archivo `config/session.php`.

### 2.1. Configuraci√≥n B√°sica

El archivo de configuraci√≥n de sesiones contiene m√∫ltiples opciones que controlan el comportamiento de las sesiones en tu aplicaci√≥n.

```php
<?php
// config/session.php
return [
    'driver' => env('SESSION_DRIVER', 'file'),
    'lifetime' => env('SESSION_LIFETIME', 120),
    'expire_on_close' => false,
    'encrypt' => false,
    'files' => storage_path('framework/sessions'),
    'connection' => env('SESSION_CONNECTION'),
    'table' => 'sessions',
    'store' => env('SESSION_STORE'),
    'lottery' => [2, 100],
    'cookie' => env('SESSION_COOKIE', Str::slug(env('APP_NAME', 'laravel'), '_').'_session'),
    'path' => '/',
    'domain' => env('SESSION_DOMAIN'),
    'secure' => env('SESSION_SECURE_COOKIE'),
    'http_only' => true,
    'same_site' => 'lax',
];
```

### 2.2. Drivers de Sesi√≥n

Laravel soporta m√∫ltiples drivers para almacenar sesiones. Cada uno tiene ventajas espec√≠ficas seg√∫n el tama√±o y necesidades de tu aplicaci√≥n.

| Driver | Descripci√≥n | Uso Recomendado |
| --- | --- | --- |
| **file** | Almacena en archivos | Desarrollo, aplicaciones peque√±as |
| **cookie** | Almacena en cookies | Aplicaciones simples |
| **database** | Almacena en base de datos | Aplicaciones medianas |
| **memcached** | Almacena en Memcached | Aplicaciones de alto rendimiento |
| **redis** | Almacena en Redis | Aplicaciones de alto rendimiento |

### 2.3. Configurar Sesiones en Base de Datos

Para aplicaciones en producci√≥n con m√∫ltiples servidores, almacenar sesiones en base de datos es m√°s confiable que archivos. Laravel proporciona un comando para crear la tabla necesaria.

```bash
# Crear tabla de sesiones
php artisan session:table
php artisan migrate
```

```php
<?php
// .env
SESSION_DRIVER=database
SESSION_CONNECTION=mysql
```

## 3. Uso de Sesiones en Laravel

Laravel proporciona una API simple e intuitiva para trabajar con sesiones. Puedes almacenar, recuperar, verificar y eliminar datos f√°cilmente.

### 3.1. Almacenar Datos en la Sesi√≥n

Hay m√∫ltiples formas de guardar datos en la sesi√≥n. Todas son equivalentes, elige la que prefieras seg√∫n tu estilo de c√≥digo.

```php
<?php
// Almacenar datos en la sesi√≥n
session(['key' => 'value']);
session(['user_id' => 123, 'username' => 'juan']);

// Usando el helper session()
session()->put('cart', $cartItems);
session()->put('user.preferences.theme', 'dark');

// Usando la facade Session
Session::put('last_visited', now());
Session::put('user.settings', $settings);
```

### 3.2. Recuperar Datos de la Sesi√≥n

Para leer los datos almacenados en la sesi√≥n, puedes usar el helper `session()` o la facade `Session`. Ambos m√©todos permiten especificar un valor por defecto si la clave no existe.

```php
<?php
// Recuperar datos de la sesi√≥n
$value = session('key');
$userId = session('user_id');

// Con valor por defecto
$theme = session('theme', 'light');
$cart = session('cart', []);

// Usando el helper session()
$user = session()->get('user');
$preferences = session()->get('user.preferences', []);

// Usando la facade Session
$lastVisit = Session::get('last_visited');
$settings = Session::get('user.settings', []);
```

### 3.3. Verificar y Eliminar Datos

Es importante poder verificar si un dato existe en la sesi√≥n antes de usarlo, y poder eliminar datos cuando ya no sean necesarios para mantener la sesi√≥n limpia.

```php
<?php
// Verificar si existe
if (session()->has('user_id')) {
    // Usuario autenticado
}

// Verificar si existe y no est√° vac√≠o
if (session()->exists('cart')) {
    // Carrito existe
}

// Eliminar datos espec√≠ficos
session()->forget('cart');
session()->forget(['user_id', 'username']);

// Eliminar todos los datos
session()->flush();

// Eliminar datos espec√≠ficos usando la facade
Session::forget('last_visited');
Session::flush();
```

## 4. Casos de Uso Comunes

### 4.1. Carrito de Compras

Un carrito de compras es uno de los usos m√°s comunes de las sesiones en aplicaciones web. Permite a los usuarios navegar por el sitio a√±adiendo productos sin necesidad de crear una cuenta inmediatamente, manteniendo su selecci√≥n entre p√°ginas hasta que decidan finalizar la compra.

```php
<?php
// Agregar producto al carrito
public function addToCart(Request $request, $productId)
{
    $product = Product::findOrFail($productId);
    $cart = session()->get('cart', []);
    
    if (isset($cart[$productId])) {
        $cart[$productId]['quantity']++;
    } else {
        $cart[$productId] = [
            'name' => $product->name,
            'price' => $product->price,
            'quantity' => 1,
            'image' => $product->image,
        ];
    }
    
    session()->put('cart', $cart);
    
    return redirect()->back()->with('success', 'Producto a√±adido al carrito');
}

// Ver carrito
public function viewCart()
{
    $cart = session()->get('cart', []);
    $total = 0;
    
    foreach ($cart as $item) {
        $total += $item['price'] * $item['quantity'];
    }
    
    return view('cart.index', compact('cart', 'total'));
}

// Eliminar del carrito
public function removeFromCart($productId)
{
    $cart = session()->get('cart', []);
    
    if (isset($cart[$productId])) {
        unset($cart[$productId]);
        session()->put('cart', $cart);
    }
    
    return redirect()->back()->with('success', 'Producto eliminado del carrito');
}
```

### 4.2. Preferencias del Usuario

Las sesiones son ideales para almacenar preferencias temporales del usuario como el idioma seleccionado, tema visual (modo oscuro/claro), o configuraciones de visualizaci√≥n. Estas preferencias persisten durante la navegaci√≥n sin necesidad de consultarlas constantemente en la base de datos.

```php
<?php
// Guardar preferencias
public function savePreferences(Request $request)
{
    $preferences = [
        'theme' => $request->theme,
        'language' => $request->language,
        'notifications' => $request->notifications,
        'items_per_page' => $request->items_per_page,
    ];
    
    session()->put('user.preferences', $preferences);
    
    return redirect()->back()->with('success', 'Preferencias guardadas');
}

// Aplicar preferencias
public function applyPreferences()
{
    $preferences = session()->get('user.preferences', []);
    
    // Aplicar tema
    if (isset($preferences['theme'])) {
        // L√≥gica para aplicar tema
    }
    
    // Aplicar idioma
    if (isset($preferences['language'])) {
        app()->setLocale($preferences['language']);
    }
}
```

### 4.3. Historial de Navegaci√≥n

Guardar un historial de las p√°ginas que el usuario ha visitado puede mejorar significativamente la experiencia de usuario, permitiendo funcionalidades como "volver atr√°s", "productos vistos recientemente", o mostrar sugerencias basadas en su navegaci√≥n reciente.

```php
<?php
// Agregar p√°gina al historial
public function addToHistory($page)
{
    $history = session()->get('navigation.history', []);
    
    // Evitar duplicados consecutivos
    if (empty($history) || end($history) !== $page) {
        $history[] = $page;
        
        // Limitar historial a 10 p√°ginas
        if (count($history) > 10) {
            $history = array_slice($history, -10);
        }
        
        session()->put('navigation.history', $history);
    }
}

// Obtener historial
public function getHistory()
{
    return session()->get('navigation.history', []);
}
```

## 5. Notificaciones y Mensajes Flash

### 5.1. Mensajes Flash

Los flash messages son datos de sesi√≥n que solo persisten para la siguiente petici√≥n HTTP. Son perfectos para mostrar mensajes de confirmaci√≥n despu√©s de acciones como "Producto creado exitosamente" o "Usuario eliminado", que deben aparecer una sola vez y luego desaparecer.

```php
<?php
// En el controlador
return redirect()->route('products.index')
    ->with('success', 'Producto creado exitosamente');

return redirect()->back()
    ->with('error', 'Error al procesar la solicitud');

return redirect()->route('home')
    ->with('warning', 'Producto con stock bajo')
    ->with('info', 'Nuevos productos disponibles');
```

### 5.2. Mostrar Mensajes en la Vista

```html
<!-- Mostrar mensajes flash -->
@if(session('success'))
    <div class="alert alert-success">
        {{ session('success') }}
    </div>
@endif

@if(session('error'))
    <div class="alert alert-danger">
        {{ session('error') }}
    </div>
@endif

@if(session('warning'))
    <div class="alert alert-warning">
        {{ session('warning') }}
    </div>
@endif

@if(session('info'))
    <div class="alert alert-info">
        {{ session('info') }}
    </div>
@endif

<!-- Mostrar todos los mensajes -->
@foreach(['success', 'error', 'warning', 'info'] as $type)
    @if(session($type))
        <div class="alert alert-{{ $type }}">
            {{ session($type) }}
        </div>
    @endif
@endforeach
```

### 5.3. Notificaciones Personalizadas

Para sistemas de notificaciones m√°s complejos, puedes crear tus propios m√©todos que encapsulen la l√≥gica de mostrar mensajes flash con diferentes tipos y estilos.

```php
<?php
// Crear notificaci√≥n personalizada
public function showNotification($message, $type = 'info')
{
    session()->flash('notification', [
        'message' => $message,
        'type' => $type,
        'timestamp' => now(),
    ]);
}

// En la vista
@if(session('notification'))
    @php $notification = session('notification'); @endphp
    <div class="alert alert-{{ $notification['type'] }}">
        <strong>{{ $notification['timestamp']->format('H:i') }}</strong>
        {{ $notification['message'] }}
    </div>
@endif
```

## 6. Cookies y Sesiones

Las cookies y sesiones trabajan juntas: las cookies almacenan el ID de sesi√≥n en el navegador del usuario, mientras que los datos reales est√°n en el servidor. Es importante entender c√≥mo configurarlas correctamente para seguridad.

### 6.1. Configuraci√≥n de Cookies

Laravel permite configurar c√≥mo se comportan las cookies de sesi√≥n a trav√©s del archivo de configuraci√≥n. Estas opciones afectan la seguridad y el alcance de las sesiones.

```php
<?php
// config/session.php
'cookie' => env('SESSION_COOKIE', 'laravel_session'),
'path' => '/',
'domain' => env('SESSION_DOMAIN'),
'secure' => env('SESSION_SECURE_COOKIE', false),
'http_only' => true,
'same_site' => 'lax',
```

### 6.2. Trabajar con Cookies

Adem√°s de las cookies de sesi√≥n autom√°ticas, puedes crear tus propias cookies para almacenar peque√±as cantidades de datos en el navegador del usuario (preferencias, temas, etc.).

```php
<?php
// Crear cookie
Cookie::queue('user_preference', 'dark_theme', 60); // 60 minutos

// Recuperar cookie
$preference = Cookie::get('user_preference');

// Eliminar cookie
Cookie::queue(Cookie::forget('user_preference'));
```

### 6.3. Cookies vs Sesiones

Aunque cookies y sesiones trabajan juntas, tienen diferencias importantes en t√©rminos de almacenamiento, seguridad y uso. Conocer estas diferencias te ayuda a elegir la herramienta correcta para cada situaci√≥n.

| Aspecto | Cookies | Sesiones |
| --- | --- | --- |
| **Almacenamiento** | Cliente | Servidor |
| **Seguridad** | Menor | Mayor |
| **Tama√±o** | Limitado (4KB) | Ilimitado |
| **Persistencia** | Configurable | Temporal |
| **Acceso** | JavaScript | Solo servidor |

## 7. Seguridad de Sesiones

La seguridad de las sesiones es cr√≠tica porque un atacante que robe un ID de sesi√≥n puede suplantar la identidad del usuario. Laravel proporciona herramientas para proteger las sesiones contra los ataques m√°s comunes.

### 7.1. Regeneraci√≥n de ID de Sesi√≥n

Regenerar el ID de sesi√≥n despu√©s de operaciones cr√≠ticas (como login) previene ataques de fijaci√≥n de sesi√≥n donde un atacante intenta forzar un ID de sesi√≥n espec√≠fico.

```php
<?php
// Regenerar ID de sesi√≥n
session()->regenerate();

// Regenerar y eliminar datos antiguos
session()->regenerate(true);
```

### 7.2. Configuraci√≥n de Seguridad

Laravel proporciona m√∫ltiples opciones de configuraci√≥n para endurecer la seguridad de las sesiones. Estas configuraciones deben ajustarse especialmente en entornos de producci√≥n.

```php
<?php
// config/session.php
'secure' => env('SESSION_SECURE_COOKIE', true), // Solo HTTPS
'http_only' => true, // No accesible desde JavaScript
'same_site' => 'strict', // Protecci√≥n CSRF
```

### 7.3. Timeout de Sesi√≥n

Las sesiones no deben durar indefinidamente. Configurar un timeout autom√°tico cierra sesiones inactivas, reduciendo el riesgo de que alguien use una sesi√≥n abandonada.

```php
<?php
// Configurar timeout
'lifetime' => 120, // 2 horas en minutos

// Verificar sesi√≥n expirada
if (session()->has('last_activity')) {
    $lastActivity = session('last_activity');
    if (now()->diffInMinutes($lastActivity) > 120) {
        session()->flush();
        return redirect()->route('login');
    }
}

session()->put('last_activity', now());
```

## 8. Optimizaci√≥n de Sesiones

En aplicaciones con muchos usuarios, las sesiones pueden acumularse y afectar el rendimiento. Laravel incluye mecanismos para optimizar y limpiar sesiones autom√°ticamente.

### 8.1. Limpieza Autom√°tica

Laravel puede limpiar sesiones expiradas autom√°ticamente usando un sistema de "loter√≠a" que se ejecuta ocasionalmente durante peticiones normales.

```php
<?php
// config/session.php
'lottery' => [2, 100], // 2% de probabilidad de limpieza
```

### 8.2. Almacenamiento Eficiente

Almacena solo los datos estrictamente necesarios en la sesi√≥n. Evita guardar objetos completos o datos grandes que puedas recuperar f√°cilmente de la base de datos.

```php
<?php
// Almacenar solo datos necesarios
session()->put('user.id', $user->id);
session()->put('user.name', $user->name);
// No almacenar objetos completos
```

### 8.3. Cache de Sesiones

Para aplicaciones de alto tr√°fico, usar Redis o Memcached como driver de sesiones proporciona mejor rendimiento que archivos o base de datos relacional.

```php
<?php
// Usar Redis para sesiones
SESSION_DRIVER=redis
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379
```
