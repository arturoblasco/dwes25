# 4.5. Middleware personalizado

En el **apartado 4** aprendiste c√≥mo autenticar usuarios con Laravel Breeze. Pero ¬øqu√© pasa si necesitas aplicar **l√≥gica com√∫n** a m√∫ltiples rutas antes de que lleguen al controlador?

El middleware personalizado permite aplicar l√≥gica com√∫n a m√∫ltiples rutas, manteniendo el c√≥digo organizado y reutilizable. Laravel proporciona un sistema de middleware flexible que permite crear, registrar y aplicar middleware personalizado para diferentes prop√≥sitos como logging, rate limiting, validaciones espec√≠ficas y transformaci√≥n de respuestas.

## 1. Fundamentos del Middleware

### 1.1. ¬øQu√© es el Middleware?

El middleware es una capa de software que procesa las peticiones HTTP **antes** de que lleguen a los controladores y **despu√©s** de que se genere la respuesta. Act√∫a como un filtro que puede modificar, validar o interceptar las peticiones y respuestas.

???examplelaravel "Analog√≠a: Controles de Seguridad en Cascada del Festival"

    **¬°Imagina que el middleware son los m√∫ltiples controles de seguridad que atraviesas en un festival de m√∫sica!**

    üé´ **Control 1 - Entrada Principal (Middleware Global):**

    * **TODOS** los asistentes deben pasar por aqu√≠
    * Escanean tu ticket y verifican que sea v√°lido
    * Dan una pulsera b√°sica de identificaci√≥n
    * **En Laravel**: `StartSession`, `CSRF Token Verification`

    üîç **Control 2 - Detector de Metales (Middleware de Grupo):**

    * Solo para ciertos grupos (ej: los que van a zona de escenario)
    * Revisan equipaje y pasan detector de metales
    * Verifican que no lleves objetos prohibidos
    * **En Laravel**: Middleware del grupo `web` o `api`

    üåü **Control 3 - Acceso VIP (Middleware de Ruta):**

    * Solo para acceder a zonas espec√≠ficas (VIP, backstage)
    * Verifican tu pulsera especial y acreditaci√≥n
    * Si no tienes acceso VIP ‚Üí rechazado
    * **En Laravel**: `auth`, `can:admin`, middleware personalizado

    üìä **Control 4 - Registro de Actividad (Middleware After):**

    * **Despu√©s** de salir de cada zona, registran tu actividad
    * Cuentan cu√°ntos asistentes pasaron
    * Guardan logs de seguridad
    * **En Laravel**: Middleware que procesa la respuesta antes de enviarla

    **Flujo completo:**

    1. Llegas ‚Üí Control 1 (ticket)
    2. Pasas ‚Üí Control 2 (detector)
    3. Entras a zona VIP ‚Üí Control 3 (acreditaci√≥n)
    4. Disfrutas del concierto ‚Üí **Controlador** (tu destino final)
    5. Sales ‚Üí Control 4 (registro de salida)
    6. Vuelves a Control 2 y 1 ‚Üí **Respuesta HTTP**

    **¬°Cada middleware es un checkpoint que debe aprobar tu petici√≥n antes de continuar!**

### 1.2. Flujo del Middleware

El middleware opera en capas: la petici√≥n atraviesa cada middleware hasta llegar al controlador, y luego la respuesta atraviesa los mismos middleware en orden inverso. Este flujo bidireccional permite procesar tanto las peticiones entrantes como las respuestas salientes.

```mermaid
graph TD
    A[Petici√≥n HTTP] --> B[Middleware 1]
    B --> C[Middleware 2]
    C --> D[Middleware 3]
    D --> E[Controlador]
    E --> F[Respuesta]
    F --> G[Middleware 3]
    G --> H[Middleware 2]
    H --> I[Middleware 1]
    I --> J[Respuesta Final]
```

### 1.3. Tipos de Middleware

Laravel organiza el middleware en diferentes categor√≠as seg√∫n su alcance y aplicaci√≥n. Conocer estos tipos te ayuda a decidir d√≥nde y c√≥mo registrar tu middleware personalizado.

| Tipo | Descripci√≥n | Ejemplo |
| --- | --- | --- |
| **Global** | Se aplica a todas las peticiones | CORS, Logging |
| **Grupo** | Se aplica a grupos de rutas | Web, API |
| **Ruta** | Se aplica a rutas espec√≠ficas | Auth, Rate Limiting |
| **Personalizado** | L√≥gica espec√≠fica de la aplicaci√≥n | Validaci√≥n, Transformaci√≥n |

## 2. Crear Middleware Personalizado

Laravel facilita la creaci√≥n de middleware personalizado mediante Artisan. Puedes crear middleware para cualquier l√≥gica espec√≠fica de tu aplicaci√≥n: logging, validaci√≥n, transformaci√≥n de datos, control de acceso, y m√°s.

### 2.1. Generar Middleware

El primer paso para crear middleware personalizado es generarlo usando Artisan. Esto crear√° una clase base con la estructura necesaria que podr√°s personalizar seg√∫n tus necesidades.

```bash
# Crear middleware personalizado
php artisan make:middleware LogUserActivity
```

### 2.2. Estructura del Middleware

Un middleware t√≠pico tiene un m√©todo `handle()` que recibe la petici√≥n y una funci√≥n `$next()`. Puedes ejecutar l√≥gica antes de llamar a `$next()` (antes del controlador) y despu√©s (despu√©s del controlador).

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Symfony\Component\HttpFoundation\Response;

class LogUserActivity
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next): Response
    {
        // L√≥gica antes de procesar la petici√≥n
        $startTime = microtime(true);
        
        // Procesar la petici√≥n
        $response = $next($request);
        
        // L√≥gica despu√©s de procesar la petici√≥n
        $endTime = microtime(true);
        $duration = round(($endTime - $startTime) * 1000, 2);
        
        // Log de la actividad
        Log::info('User activity', [
            'user_id' => auth()->id(),
            'user_name' => auth()->user()?->name,
            'method' => $request->method(),
            'url' => $request->fullUrl(),
            'ip' => $request->ip(),
            'user_agent' => $request->userAgent(),
            'duration_ms' => $duration,
            'status_code' => $response->getStatusCode(),
            'timestamp' => now(),
        ]);
        
        return $response;
    }
}
```

### 2.3. Middleware con Par√°metros

Los middleware pueden aceptar par√°metros adicionales para hacerlos m√°s flexibles y reutilizables. Esto te permite crear un solo middleware que se comporta diferente seg√∫n los par√°metros que reciba.

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class CheckUserRole
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next, string $role): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }
        
        if (!auth()->user()->hasRole($role)) {
            abort(403, 'No tienes permisos para acceder a esta p√°gina');
        }
        
        return $next($request);
    }
}
```

## 3. Registrar Middleware

Despu√©s de crear el middleware, necesitas registrarlo para que Laravel sepa cu√°ndo y c√≥mo aplicarlo. El registro determina si el middleware es global, de grupo o de ruta.

### 3.1. Registro en bootstrap/app.php

Una vez creado el middleware, debes registrarlo en tu aplicaci√≥n para que Laravel lo reconozca y pueda aplicarlo. El registro se realiza en el archivo `bootstrap/app.php` y determina su alcance (global, grupo o ruta espec√≠fica).

```php
<?php
// bootstrap/app.php
->withMiddleware(function (Middleware $middleware) {
    // Middleware global
    $middleware->web(append: [
        \App\Http\Middleware\LogUserActivity::class,
    ]);
    
    // Middleware de grupo
    $middleware->group('admin', [
        \App\Http\Middleware\CheckUserRole::class,
    ]);
    
    // Alias de middleware
    $middleware->alias([
        'role' => \App\Http\Middleware\CheckUserRole::class,
        'log.activity' => \App\Http\Middleware\LogUserActivity::class,
    ]);
})
```

### 3.2. Aplicar Middleware a Rutas

Una vez registrado con un alias, puedes aplicar el middleware a rutas individuales o grupos de rutas usando el m√©todo `middleware()`. Tambi√©n puedes combinar m√∫ltiples middleware.

```php
<?php
// Aplicar middleware a rutas espec√≠ficas
Route::get('/admin', [AdminController::class, 'index'])
    ->middleware('role:admin');

Route::post('/products', [ProductController::class, 'store'])
    ->middleware(['auth', 'log.activity']);

// Aplicar middleware a grupos de rutas
Route::middleware(['auth', 'role:admin'])->group(function () {
    Route::get('/admin/users', [UserController::class, 'index']);
    Route::post('/admin/users', [UserController::class, 'store']);
    Route::delete('/admin/users/{user}', [UserController::class, 'destroy']);
});
```

## 4. Casos de Uso Comunes
El middleware personalizado puede resolver muchos problemas comunes en aplicaciones web: rate limiting, validaci√≥n de API, transformaci√≥n de respuestas, logging, y m√°s. Estos ejemplos te muestran patrones √∫tiles que puedes adaptar.

### 4.1. Rate Limiting Personalizado

El rate limiting controla cu√°ntas peticiones puede hacer un usuario en un per√≠odo de tiempo. Crear rate limiting personalizado te permite aplicar diferentes l√≠mites seg√∫n el tipo de usuario, la acci√≥n que realiza, o el recurso al que accede.



```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;
use Symfony\Component\HttpFoundation\Response;

class RateLimitProductCreation
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next): Response
    {
        $userId = auth()->id();
        $key = 'product_creation_' . $userId;
        $attempts = Cache::get($key, 0);
        $limit = auth()->user()->is_premium ? 20 : 5; // L√≠mite diferente para usuarios premium
        
        if ($attempts >= $limit) {
            return response()->json([
                'error' => 'Has alcanzado el l√≠mite de productos que puedes crear por hora.',
                'limit' => $limit,
                'reset_time' => Cache::get($key . '_reset')
            ], 429);
        }
        
        $response = $next($request);
        
        // Incrementar contador solo si la petici√≥n fue exitosa
        if ($request->isMethod('POST') && $request->routeIs('products.store') && $response->getStatusCode() === 200) {
            Cache::put($key, $attempts + 1, 3600); // 1 hora
            Cache::put($key . '_reset', now()->addHour(), 3600);
        }
        
        return $response;
    }
}
```

### 4.2. Middleware de Validaci√≥n de API

En APIs REST es com√∫n requerir formatos espec√≠ficos en las peticiones (headers, estructura JSON, autenticaci√≥n por tokens). Un middleware de validaci√≥n de API verifica estos requisitos antes de que la petici√≥n llegue al controlador.



```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class ValidateApiRequest
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next): Response
    {
        // Verificar header de API
        if (!$request->hasHeader('X-API-Key')) {
            return response()->json(['error' => 'API Key requerida'], 401);
        }
        
        // Verificar formato de API Key
        $apiKey = $request->header('X-API-Key');
        if (!preg_match('/^[a-zA-Z0-9]{32}$/', $apiKey)) {
            return response()->json(['error' => 'Formato de API Key inv√°lido'], 401);
        }
        
        // Verificar que la API Key existe en la base de datos
        $user = \App\Models\User::where('api_key', $apiKey)->first();
        if (!$user) {
            return response()->json(['error' => 'API Key no v√°lida'], 401);
        }
        
        // A√±adir usuario a la petici√≥n
        $request->merge(['authenticated_user' => $user]);
        
        return $next($request);
    }
}
```

### 4.3. Middleware de Transformaci√≥n de Respuesta

A veces necesitas transformar todas las respuestas de ciertas rutas a un formato espec√≠fico, como envolver los datos en una estructura est√°ndar de API o a√±adir metadatos adicionales. Este middleware act√∫a despu√©s de que el controlador genera la respuesta.



```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class TransformResponse
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next): Response
    {
        $response = $next($request);
        
        // Solo transformar respuestas JSON
        if ($response->headers->get('Content-Type') === 'application/json') {
            $content = json_decode($response->getContent(), true);
            
            // A√±adir metadatos
            $transformedContent = [
                'data' => $content,
                'meta' => [
                    'timestamp' => now()->toISOString(),
                    'version' => '1.0',
                    'request_id' => $request->header('X-Request-ID', uniqid()),
                ]
            ];
            
            $response->setContent(json_encode($transformedContent));
        }
        
        return $response;
    }
}
```

## 5. Middleware Avanzado

Los middleware avanzados implementan patrones m√°s complejos como caching de respuestas, logging de errores con contexto detallado, y sanitizaci√≥n autom√°tica de inputs. Estos ejemplos muestran t√©cnicas profesionales de producci√≥n.

### 5.1. Middleware de Cache

El caching de respuestas puede mejorar dr√°sticamente el rendimiento de tu aplicaci√≥n al almacenar respuestas completas y servirlas directamente sin ejecutar el controlador. Este middleware verifica si existe una respuesta en cach√© antes de procesarla.



```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;
use Symfony\Component\HttpFoundation\Response;

class CacheResponse
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next, int $minutes = 60): Response
    {
        // Generar clave de cache
        $cacheKey = 'response_' . md5($request->fullUrl() . serialize($request->all()));
        
        // Verificar si existe en cache
        if (Cache::has($cacheKey)) {
            $cachedResponse = Cache::get($cacheKey);
            return response($cachedResponse['content'])
                ->withHeaders($cachedResponse['headers']);
        }
        
        // Procesar petici√≥n
        $response = $next($request);
        
        // Cachear respuesta si es exitosa
        if ($response->getStatusCode() === 200) {
            Cache::put($cacheKey, [
                'content' => $response->getContent(),
                'headers' => $response->headers->all(),
            ], $minutes * 60);
        }
        
        return $response;
    }
}
```

### 5.2. Middleware de Logging de Errores

Capturar y registrar errores de forma centralizada es crucial para el mantenimiento de aplicaciones. Este middleware intercepta excepciones y las registra con contexto adicional antes de que Laravel las maneje.

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Symfony\Component\HttpFoundation\Response;

class LogErrors
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next): Response
    {
        $response = $next($request);
        
        // Log errores del servidor
        if ($response->getStatusCode() >= 500) {
            Log::error('Server error occurred', [
                'status_code' => $response->getStatusCode(),
                'url' => $request->fullUrl(),
                'method' => $request->method(),
                'ip' => $request->ip(),
                'user_agent' => $request->userAgent(),
                'user_id' => auth()->id(),
                'request_data' => $request->except(['password', 'password_confirmation']),
                'timestamp' => now(),
            ]);
        }
        
        // Log errores del cliente
        if ($response->getStatusCode() >= 400 && $response->getStatusCode() < 500) {
            Log::warning('Client error occurred', [
                'status_code' => $response->getStatusCode(),
                'url' => $request->fullUrl(),
                'method' => $request->method(),
                'ip' => $request->ip(),
                'user_id' => auth()->id(),
                'timestamp' => now(),
            ]);
        }
        
        return $response;
    }
}
```

### 5.3. Middleware de Normalizaci√≥n de Entrada

La normalizaci√≥n de datos de entrada mejora la consistencia (trim de espacios, normalizaci√≥n de formato). Este middleware limpia y normaliza inputs antes de que lleguen al controlador.

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class NormalizeInput
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next): Response
    {
        // Normalizar datos de entrada
        $input = $request->all();
        
        foreach ($input as $key => $value) {
            if (is_string($value)) {
                // ‚úÖ Trim espacios en blanco al inicio y final
                $input[$key] = trim($value);
                
                // ‚úÖ Normalizar m√∫ltiples espacios en blanco a uno solo
                $input[$key] = preg_replace('/\s+/', ' ', $input[$key]);
            }
        }
        
        // Reemplazar datos de la petici√≥n
        $request->merge($input);
        
        return $next($request);
    }
}
```

‚ö†Ô∏è Antipatr√≥n: NO Uses htmlspecialchars() en la Entrada

**NUNCA** uses `htmlspecialchars()`, `strip_tags()` o similar en los datos de **entrada** antes de guardarlos en la base de datos.

**‚ùå MAL (Antipatr√≥n):**

```php
<?php
// NO HACER: Escapar HTML en la entrada
$input[$key] = htmlspecialchars($value, ENT_QUOTES, 'UTF-8');
$user->name = $input['name']; // Guardas "&lt;script&gt;" en lugar de "<script>"
```

**Problemas:**

1. **P√©rdida de datos**: Si guardas `htmlspecialchars("Caf√© & Copas")`, se convierte en `"Caf&eacute; &amp; Copas"`
2. **Doble escaping**: Cuando lo muestres con Blade `{ { } }`, se ver√° mal: `"Caf&amp;eacute; &amp;amp; Copas"`
3. **Datos corruptos**: No puedes buscar, ordenar o comparar correctamente

**‚úÖ CORRECTO:**

```php
<?php
// ‚úÖ GUARDAR: Datos limpios sin escapar
$user->name = $request->input('name'); // Guardas "<script>" tal cual

// ‚úÖ MOSTRAR: Blade escapa autom√°ticamente en la salida
{{ $user->name }}  // Muestra "&lt;script&gt;" (seguro)
```

**Regla de oro:**

* **Entrada**: Valida y normaliza (trim, formato), pero **NO escapes HTML**
* **Salida**: Blade  escapa autom√°ticamente (protecci√≥n XSS)
* **Almacenamiento**: Guarda los datos originales sin modificar

## 6. Testing de Middleware

Testear middleware es esencial para asegurar que las capas de seguridad y l√≥gica funcionan correctamente. Laravel proporciona herramientas para simular peticiones y verificar respuestas f√°cilmente.

### 6.1. Test B√°sico

Los tests b√°sicos de middleware verifican que las peticiones autorizadas pasen y las no autorizadas sean bloqueadas o redirigidas correctamente.

```php
<?php

namespace Tests\Feature;

use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use App\Http\Middleware\CheckUserRole;

class CheckUserRoleTest extends TestCase
{
    use RefreshDatabase;

    public function test_middleware_allows_admin_access()
    {
        $user = \App\Models\User::factory()->create(['role' => 'admin']);
        
        $response = $this->actingAs($user)
            ->get('/admin')
            ->assertStatus(200);
    }

    public function test_middleware_denies_non_admin_access()
    {
        $user = \App\Models\User::factory()->create(['role' => 'user']);
        
        $response = $this->actingAs($user)
            ->get('/admin')
            ->assertStatus(403);
    }

    public function test_middleware_redirects_guests()
    {
        $response = $this->get('/admin')
            ->assertRedirect('/login');
    }
}
```

### 6.2. Test de Rate Limiting

Los tests de rate limiting verifican que los l√≠mites se apliquen correctamente, contando peticiones y rechazando las que excedan el l√≠mite establecido.

```php
<?php

namespace Tests\Feature;

use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Cache;

class RateLimitProductCreationTest extends TestCase
{
    use RefreshDatabase;

    public function test_rate_limiting_works()
    {
        $user = \App\Models\User::factory()->create();
        
        // Crear 5 productos (l√≠mite para usuario normal)
        for ($i = 0; $i < 5; $i++) {
            $response = $this->actingAs($user)
                ->post('/products', [
                    'name' => 'Product ' . $i,
                    'description' => 'Description',
                    'price' => 100,
                ]);
            
            $this->assertEquals(200, $response->getStatusCode());
        }
        
        // El sexto producto debe ser rechazado
        $response = $this->actingAs($user)
            ->post('/products', [
                'name' => 'Product 6',
                'description' => 'Description',
                'price' => 100,
            ]);
        
        $this->assertEquals(429, $response->getStatusCode());
    }
}
```

## 7. Mejores Pr√°cticas

Seguir buenas pr√°cticas en la organizaci√≥n, documentaci√≥n y configuraci√≥n de middleware mejora la mantenibilidad del c√≥digo y facilita el trabajo en equipo.

### 7.1. Organizaci√≥n del C√≥digo

Organiza tu middleware en carpetas seg√∫n su prop√≥sito (Auth, API, Logging, Security). Esto facilita encontrar y mantener el c√≥digo a medida que crece tu aplicaci√≥n.

```php
<?php
// Agrupar middleware relacionado
app/Http/Middleware/
‚îú‚îÄ‚îÄ Auth/
‚îÇ   ‚îú‚îÄ‚îÄ CheckUserRole.php
‚îÇ   ‚îú‚îÄ‚îÄ CheckUserPermission.php
‚îÇ   ‚îî‚îÄ‚îÄ RedirectIfAuthenticated.php
‚îú‚îÄ‚îÄ Api/
‚îÇ   ‚îú‚îÄ‚îÄ ValidateApiRequest.php
‚îÇ   ‚îú‚îÄ‚îÄ TransformResponse.php
‚îÇ   ‚îî‚îÄ‚îÄ RateLimitApi.php
‚îú‚îÄ‚îÄ Logging/
‚îÇ   ‚îú‚îÄ‚îÄ LogUserActivity.php
‚îÇ   ‚îú‚îÄ‚îÄ LogErrors.php
‚îÇ   ‚îî‚îÄ‚îÄ LogApiRequests.php
‚îî‚îÄ‚îÄ Security/
    ‚îú‚îÄ‚îÄ SanitizeInput.php
    ‚îú‚îÄ‚îÄ PreventXSS.php
    ‚îî‚îÄ‚îÄ ValidateCSRF.php
```

### 7.2. Documentaci√≥n del Middleware

Documenta tus middleware con PHPDoc detallado explicando qu√© hace, qu√© par√°metros acepta, y c√≥mo usarlo. Esto es especialmente √∫til para middleware complejos o con par√°metros.

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

/**
 * Middleware para verificar el rol del usuario
 * 
 * @param string $role Rol requerido (admin, user, moderator)
 * 
 * Uso:
 * Route::get('/admin', [AdminController::class, 'index'])
 *     ->middleware('role:admin');
 */
class CheckUserRole
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next, string $role): Response
    {
        // Implementaci√≥n...
    }
}
```

### 7.3. Configuraci√≥n Flexible

Dise√±a middleware que acepte configuraci√≥n mediante par√°metros. Esto aumenta la reutilizaci√≥n y evita crear m√∫ltiples middleware similares para casos ligeramente diferentes.



```php
<?php
// Configurar middleware con opciones
Route::get('/products', [ProductController::class, 'index'])
    ->middleware('cache:30'); // Cache por 30 minutos

Route::get('/admin', [AdminController::class, 'index'])
    ->middleware('role:admin,moderator'); // M√∫ltiples roles
```
