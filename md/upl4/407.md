# 4.7. Sistema de almacenamiento de archivos

En las sesiones anteriores aprendiste a manejar formularios, validar datos y autenticar usuarios. Pero ¬øqu√© pasa cuando los usuarios suben **archivos** como im√°genes de perfil, fotos de productos, o documentos?

El almacenamiento de archivos es una necesidad fundamental en aplicaciones web modernas. Laravel proporciona un sistema de almacenamiento robusto, seguro y f√°cil de usar a trav√©s de su facade `Storage`.

## 7.1. ¬øPor Qu√© Necesitamos un Sistema de Almacenamiento?

Cuando los usuarios suben archivos a tu aplicaci√≥n (im√°genes, documentos, videos), estos archivos deben:

1. **Almacenarse en el servidor** de forma segura
2. **Ser accesibles** p√∫blicamente (para im√°genes que se muestran en la web)
3. **Gestionarse** (crear, leer, actualizar, eliminar)
4. **Organizarse** en directorios l√≥gicos

???examplelaravel "Analog√≠a: Sistema de Almacenamiento como Archivo del Festival"

    **¬°Imagina el sistema de almacenamiento como las diferentes √°reas de archivo y gesti√≥n de contenido de un festival de m√∫sica!**

    * üì∏ **Zona P√∫blica de Fotos (public disk)**: Galer√≠a p√∫blica del festival

    + Fotos del escenario, cartel del festival, logos de patrocinadores
    + Acceso: Cualquier asistente puede ver estas fotos en pantallas y redes sociales
    + **Equivalente web**: Im√°genes de productos, logos, fotos de perfiles p√∫blicos
    + **Ubicaci√≥n f√≠sica**: `storage/app/public/` ‚Üí enlazado a `public/storage/`
    * üîí **Oficina de Backstage (local disk)**: Archivos privados del festival

    + Contratos de artistas, facturas, documentos legales
    + Acceso: Solo el staff autorizado con credenciales
    + **Equivalente web**: Facturas de usuarios, documentos privados, backups
    + **Ubicaci√≥n f√≠sica**: `storage/app/` (NO accesible v√≠a web directamente)
    * ‚òÅÔ∏è **Almac√©n Externo en la Nube (s3 disk)**: Servidor externo de contenido

    + Videos completos de conciertos almacenados en Amazon S3 o Google Cloud
    + Acceso: Mediante conexi√≥n API segura con el proveedor cloud
    + **Equivalente web**: Archivos pesados, im√°genes escalables, CDN
    + **Ubicaci√≥n f√≠sica**: Servidores de Amazon, Google, etc.
    * üìã **Sistema de Gesti√≥n (Storage facade)**: El manager del festival

    + Registra d√≥nde est√° cada archivo (galer√≠a, backstage, nube)
    + Controla qui√©n puede acceder a qu√© archivo
    + Facilita subir, buscar, mover, copiar y eliminar archivos
    + **Equivalente web**: La API de Laravel `Storage::`

    **¬°El Storage de Laravel es tu sistema de gesti√≥n de archivos con diferentes "zonas" de almacenamiento!**

## 7.2. Discos de Almacenamiento en Laravel

Laravel organiza el almacenamiento en "discos" (disks), que son ubicaciones configuradas donde se guardan archivos.

### 7.2.1. Discos Predefinidos

Laravel viene con tres discos configurados por defecto, cada uno con un prop√≥sito espec√≠fico seg√∫n el nivel de acceso y ubicaci√≥n requerida.

| Disco | Ubicaci√≥n | Acceso P√∫blico | Uso T√≠pico |
| --- | --- | --- | --- |
| **local** | `storage/app/` | ‚ùå No | Archivos privados, logs internos |
| **public** | `storage/app/public/` | ‚úÖ S√≠ (con enlace simb√≥lico) | Im√°genes de productos, avatares |
| **s3** | Amazon S3 (nube) | ‚úÖ Configurable | Archivos en producci√≥n, alta escalabilidad |

### 7.2.2. Configuraci√≥n de Discos

Los discos se configuran en `config/filesystems.php`:

```php
<?php

return [
    'default' => env('FILESYSTEM_DISK', 'local'),

    'disks' => [
        'local' => [
            'driver' => 'local',
            'root' => storage_path('app'),
            'throw' => false,
        ],

        'public' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
            'url' => env('APP_URL').'/storage',
            'visibility' => 'public',
            'throw' => false,
        ],

        's3' => [
            'driver' => 's3',
            'key' => env('AWS_ACCESS_KEY_ID'),
            'secret' => env('AWS_SECRET_ACCESS_KEY'),
            'region' => env('AWS_DEFAULT_REGION'),
            'bucket' => env('AWS_BUCKET'),
            'url' => env('AWS_URL'),
        ],
    ],
];
```

## 7.3. El Disco P√∫blico y el Enlace Simb√≥lico

El disco `public` es especial porque necesita ser accesible desde la web, pero por defecto est√° en `storage/app/public/`, que **no es accesible p√∫blicamente**.

### 7.3.1. ¬øPor Qu√© Existe Este Problema?

La carpeta `storage/` est√° fuera de la carpeta `public/` por seguridad. Los navegadores solo pueden acceder a archivos dentro de `public/`, por lo que archivos en `storage/app/public/` no son accesibles directamente.

```text
tu-proyecto/
‚îú‚îÄ‚îÄ public/              ‚Üê Carpeta accesible por navegadores (www.tuapp.com/)
‚îÇ   ‚îú‚îÄ‚îÄ index.php
‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îî‚îÄ‚îÄ js/
‚îî‚îÄ‚îÄ storage/             ‚Üê Carpeta PRIVADA, NO accesible por navegadores
    ‚îî‚îÄ‚îÄ app/
        ‚îî‚îÄ‚îÄ public/      ‚Üê ¬øC√≥mo hacer que esto sea accesible?
            ‚îî‚îÄ‚îÄ products/
                ‚îî‚îÄ‚îÄ iphone.jpg
```

**Problema:**

* Los navegadores solo pueden acceder a archivos en `public/`
* Pero guardamos archivos en `storage/app/public/`
* Los navegadores **no pueden** acceder directamente a `storage/`

### 7.3.2. Soluci√≥n: Enlace Simb√≥lico

Un **enlace simb√≥lico** (symbolic link) es como un "portal" que conecta dos ubicaciones:

```bash
# Crear el enlace simb√≥lico
php artisan storage:link
```

**Resultado:**

```text
public/storage ‚Üí storage/app/public/
    (enlace)         (carpeta real)
```

Ahora:

```text
www.tuapp.com/storage/products/iphone.jpg
              ‚Üì
public/storage/products/iphone.jpg
       ‚Üì (enlace simb√≥lico)
storage/app/public/products/iphone.jpg
```

Crear el Enlace Simb√≥lico

**Siempre debes ejecutar `php artisan storage:link` despu√©s de:**

* Clonar el proyecto por primera vez
* Configurar un nuevo entorno de desarrollo
* Desplegar en un nuevo servidor

**Sin el enlace simb√≥lico, las im√°genes no se mostrar√°n en el navegador.**

### 7.3.3. Verificar el Enlace

Puedes verificar si el enlace simb√≥lico ya existe ejecutando el comando nuevamente. Si existe, Laravel te lo indicar√° para evitar conflictos.

```bash
# Verificar si el enlace existe
sail artisan storage:link

# Si ya existe, ver√°s:
# The "public/storage" directory already exists.

# Para forzar la recreaci√≥n:
sail artisan storage:link --force
```

## 7.4. Operaciones B√°sicas con Storage

La facade `Storage` proporciona m√©todos simples para guardar, leer, actualizar y eliminar archivos. Estas operaciones son consistentes sin importar qu√© disco uses (`local`, `public`, `s3`).

### 7.4.1. Guardar Archivos

Para guardar archivos desde un formulario, usa el m√©todo `store()` o `storeAs()` del archivo subido. Laravel autom√°ticamente gestiona el nombre y ubicaci√≥n del archivo.

**Desde un Formulario:**

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;

class ProductController extends Controller
{
    public function store(Request $request)
    {
        // Validar el archivo
        $request->validate([
            'image' => 'required|image|mimes:jpeg,png,jpg,gif|max:2048', // 2MB m√°ximo
        ]);

        // Guardar el archivo en storage/app/public/products/
        $path = $request->file('image')->store('products', 'public');
        
        // $path contiene la ruta relativa: "products/abc123def456.jpg"
        
        // Guardar la ruta en la base de datos
        $product = Product::create([
            'name' => $request->name,
            'image' => $path,  // ‚Üê Guardamos la ruta
        ]);

        return redirect()->route('products.show', $product);
    }
}
```

**Con Nombre Personalizado:**

```php
<?php
// Guardar con nombre original
$path = $request->file('image')->storeAs(
    'products',
    $request->file('image')->getClientOriginalName(),
    'public'
);

// Guardar con nombre personalizado
$fileName = 'product_' . time() . '.' . $request->file('image')->extension();
$path = $request->file('image')->storeAs('products', $fileName, 'public');
```

### 7.4.2. Leer/Obtener Archivos

Para mostrar archivos guardados en storage necesitas obtener su URL p√∫blica. Laravel proporciona el m√©todo `Storage::url()` y el helper `asset()` para generar URLs accesibles.

**Obtener la URL P√∫blica:**

```php
<?php
// En el controlador
$product = Product::find(1);
$url = Storage::url($product->image);
// $url = "/storage/products/abc123def456.jpg"
```

**En Blade:**

```php
<?php
{{-- Mostrar imagen desde Storage --}}
<img src="{{ asset('storage/' . $product->image) }}" alt="{{ $product->name }}">

{{-- O usando el helper Storage::url() --}}
<img src="{{ Storage::url($product->image) }}" alt="{{ $product->name }}">
```

**Verificar si un Archivo Existe:**

```php
<?php
if (Storage::disk('public')->exists($product->image)) {
    // El archivo existe
    $url = Storage::url($product->image);
} else {
    // Usar imagen placeholder
    $url = asset('images/placeholder.jpg');
}
```

### 7.4.3. Actualizar Archivos

Cuando actualizas un registro que tiene un archivo, debes:

1. Eliminar el archivo antiguo (si existe)
2. Guardar el nuevo archivo
3. Actualizar la ruta en la base de datos

```php
<?php

public function update(Request $request, Product $product)
{
    $request->validate([
        'name' => 'required|string|max:255',
        'image' => 'nullable|image|mimes:jpeg,png,jpg,gif|max:2048',
    ]);

    // Actualizar datos b√°sicos
    $product->name = $request->name;

    // Si se subi√≥ una nueva imagen
    if ($request->hasFile('image')) {
        // 1. Eliminar imagen anterior (si existe)
        if ($product->image && Storage::disk('public')->exists($product->image)) {
            Storage::disk('public')->delete($product->image);
        }

        // 2. Guardar nueva imagen
        $path = $request->file('image')->store('products', 'public');

        // 3. Actualizar la ruta
        $product->image = $path;
    }

    $product->save();

    return redirect()->route('products.show', $product)
        ->with('success', 'Producto actualizado exitosamente');
}
```

### 7.4.4. Eliminar Archivos

Cuando eliminas un registro que tiene archivos asociados, tambi√©n debes eliminar los archivos del disco para evitar archivos "hu√©rfanos" que ocupan espacio innecesariamente.



```php
<?php

public function destroy(Product $product)
{
    // Eliminar el archivo de Storage
    if ($product->image && Storage::disk('public')->exists($product->image)) {
        Storage::disk('public')->delete($product->image);
    }

    // Eliminar el registro de la base de datos
    $product->delete();

    return redirect()->route('products.index')
        ->with('success', 'Producto eliminado exitosamente');
}
```

## 7.5. M√©todos √ötiles de Storage

Adem√°s de las operaciones b√°sicas, Storage proporciona m√©todos √∫tiles para verificar, gestionar directorios, y copiar o mover archivos.

### 7.5.1. Verificaci√≥n de Archivos

Verifica la existencia, tama√±o y √∫ltima modificaci√≥n de archivos antes de realizar operaciones sobre ellos.

```php
<?php

// Verificar si existe
Storage::disk('public')->exists('products/image.jpg');

// Verificar si NO existe
Storage::disk('public')->missing('products/image.jpg');

// Obtener tama√±o en bytes
Storage::disk('public')->size('products/image.jpg');

// Obtener √∫ltima modificaci√≥n (timestamp)
Storage::disk('public')->lastModified('products/image.jpg');
```

### 7.5.2. Gesti√≥n de Directorios

Crea, lista y elimina directorios para mantener tus archivos organizados. Estos m√©todos facilitan la gesti√≥n de la estructura de carpetas.

```php
<?php

// Listar archivos en un directorio
$files = Storage::disk('public')->files('products');
// ['products/img1.jpg', 'products/img2.jpg']

// Listar todos los archivos (recursivo)
$files = Storage::disk('public')->allFiles('products');

// Listar directorios
$directories = Storage::disk('public')->directories('products');

// Crear directorio
Storage::disk('public')->makeDirectory('products/featured');

// Eliminar directorio y todo su contenido
Storage::disk('public')->deleteDirectory('products/old');
```

### 7.5.3. Copiar y Mover Archivos

Copia o mueve archivos entre directorios sin necesidad de subirlos de nuevo. √ötil para reorganizar contenido o crear respaldos.

```php
<?php

// Copiar archivo
Storage::disk('public')->copy(
    'products/old-image.jpg',
    'products/backup/old-image.jpg'
);

// Mover archivo
Storage::disk('public')->move(
    'products/temp-image.jpg',
    'products/featured/image.jpg'
);

// Renombrar archivo (es un alias de move)
Storage::disk('public')->move(
    'products/abc123.jpg',
    'products/producto-destacado.jpg'
);
```

## 7.6. Archivos Privados (Opcional)

A diferencia del disco `public` que es accesible para cualquiera, el disco `local` permite almacenar archivos que **requieren autenticaci√≥n** para ser descargados.

### 7.6.1. ¬øCu√°ndo Usar Archivos Privados?

**Casos de uso comunes:**

* Facturas de clientes
* Documentos personales
* Contratos privados
* Archivos de n√≥minas
* Cualquier documento sensible que requiera control de acceso

### 7.6.2. Guardar Archivos Privados

Los archivos privados se guardan en el disco `local` que no es accesible directamente v√≠a web. Debes servir estos archivos a trav√©s de controladores que verifican permisos.

```php
<?php

// Guardar en el disco 'local' (privado)
$documentPath = $request->file('invoice')->store('invoices', 'local');

// Se guarda en: storage/app/invoices/
// NO es accesible desde el navegador
```

### 7.6.3. Servir Archivos Privados con Control de Acceso

Para servir archivos privados, necesitas un controlador que verifique los permisos:

```php
<?php

namespace App\Http\Controllers;

use App\Models\Invoice;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Symfony\Component\HttpFoundation\StreamedResponse;

class InvoiceController extends Controller
{
    /**
     * Descargar factura privada.
     */
    public function download($id): StreamedResponse
    {
        // 1. Buscar la factura
        $invoice = Invoice::findOrFail($id);
        
        // 2. Verificar que el usuario tiene permiso
        if (auth()->id() !== $invoice->user_id && !auth()->user()->isAdmin()) {
            abort(403, 'No tienes permiso para acceder a este archivo.');
        }
        
        // 3. Verificar que el archivo existe
        if (!Storage::disk('local')->exists($invoice->file_path)) {
            abort(404, 'Archivo no encontrado.');
        }
        
        // 4. Descargar el archivo
        return Storage::disk('local')->download(
            $invoice->file_path,
            $invoice->original_filename  // Nombre del archivo descargado
        );
    }
    
    /**
     * Ver archivo privado en el navegador (sin descargar).
     */
    public function view($id): StreamedResponse
    {
        $invoice = Invoice::findOrFail($id);
        
        // Verificar permisos
        if (auth()->id() !== $invoice->user_id && !auth()->user()->isAdmin()) {
            abort(403, 'No tienes permiso para acceder a este archivo.');
        }
        
        // Mostrar en el navegador (para PDFs, im√°genes)
        return Storage::disk('local')->response(
            $invoice->file_path,
            $invoice->original_filename
        );
    }
}
```

**Definir la Ruta:**

```php
<?php
// routes/web.php
Route::middleware('auth')->group(function () {
    Route::get('/invoices/{id}/download', [InvoiceController::class, 'download'])
        ->name('invoices.download');
    
    Route::get('/invoices/{id}/view', [InvoiceController::class, 'view'])
        ->name('invoices.view');
});
```

**En la Vista:**

```php
<?php
{{-- Enlace para descargar factura privada --}}
<a href="{{ route('invoices.download', $invoice->id) }}" 
   class="btn btn-primary">
    Descargar Factura
</a>

{{-- Enlace para ver en el navegador --}}
<a href="{{ route('invoices.view', $invoice->id) }}" 
   target="_blank"
   class="btn btn-secondary">
    Ver Factura
</a>
```

Diferencia: download() vs response()

* **`download()`**: Fuerza la descarga del archivo (header `Content-Disposition: attachment`)
* **`response()`**: Muestra el archivo en el navegador (para PDFs, im√°genes)

## 7.7. Buenas Pr√°cticas

Seguir buenas pr√°cticas en el manejo de archivos es crucial para la seguridad, rendimiento y mantenibilidad de tu aplicaci√≥n. Estas recomendaciones te ayudar√°n a evitar problemas comunes.

### 7.7.1. Siempre Validar Archivos

Valida tipo, tama√±o y dimensiones de los archivos subidos para prevenir archivos maliciosos, excesivamente grandes, o de formatos incorrectos.

```php
<?php

$request->validate([
    'image' => [
        'required',          // Campo obligatorio
        'image',             // Debe ser una imagen
        'mimes:jpeg,png,jpg,gif,webp',  // Tipos permitidos
        'max:2048',          // Tama√±o m√°ximo en KB (2MB)
        'dimensions:min_width=100,min_height=100',  // Dimensiones m√≠nimas
    ],
]);
```

### 7.7.2. Advertencia de Seguridad: Extensiones de Archivo

Confiar solo en la extensi√≥n del archivo es un grave error de seguridad. Los atacantes pueden manipular extensiones para intentar subir c√≥digo malicioso.

‚ö†Ô∏è Nunca Conf√≠es en la Extensi√≥n del Archivo

Un atacante puede renombrar un archivo malicioso `virus.php` a `virus.jpg` para intentar enga√±ar al sistema.

**Medidas de seguridad obligatorias:**

1. **Siempre usa la regla `image`**: Laravel valida el contenido real del archivo (tipo MIME), no solo la extensi√≥n
2. **Nunca ejecutes archivos subidos**: Los archivos subidos por usuarios nunca deben ejecutarse directamente
3. **Usa el disco correcto**:
   * Archivos p√∫blicos ‚Üí disco `public` (im√°genes visibles)
   * Archivos sensibles ‚Üí disco `local` (con control de acceso)
4. **Valida el tipo MIME**: `mimes:jpeg,png,jpg,gif` verifica el contenido real

```php
<?php

// ‚úÖ BUENO: Validaci√≥n completa
$request->validate([
    'image' => 'required|image|mimes:jpeg,png,jpg,gif|max:2048',
]);

// ‚ùå MALO: Solo verificar extensi√≥n
if (pathinfo($file->getClientOriginalName(), PATHINFO_EXTENSION) === 'jpg') {
    // Un atacante puede renombrar virus.php a virus.jpg
}
```

### 7.7.3. Organizar Archivos en Subdirectorios

Mant√©n tus archivos organizados en subdirectorios por tipo o fecha. Esto facilita el mantenimiento, backups, y evita problemas de rendimiento con muchos archivos.


```php
<?php

// ‚ùå Malo: Todos los archivos en el mismo directorio
Storage::disk('public')->put('image.jpg', $file);
// storage/app/public/image.jpg

// ‚úÖ Bueno: Organizar por tipo
Storage::disk('public')->put('products/image.jpg', $file);
// storage/app/public/products/image.jpg

// ‚úÖ Mejor: Organizar por fecha
$date = now()->format('Y/m');
Storage::disk('public')->put("products/{$date}/image.jpg", $file);
// storage/app/public/products/2025/01/image.jpg
```

### 7.7.4. Eliminar Archivos Hu√©rfanos

Siempre elimina el archivo cuando eliminas el registro:

```php
<?php

// ‚ùå Malo: Solo eliminar el registro
$product->delete();
// El archivo queda en storage ocupando espacio

// ‚úÖ Bueno: Eliminar archivo y registro
if ($product->image && Storage::disk('public')->exists($product->image)) {
    Storage::disk('public')->delete($product->image);
}
$product->delete();
```

### 7.7.5. Usar Nombres de Archivo √önicos

Genera nombres √∫nicos para evitar colisiones y sobrescritura accidental de archivos cuando m√∫ltiples usuarios suben archivos con el mismo nombre.

```php
<?php

// ‚ùå Malo: Nombre predecible
$fileName = 'product.jpg';
// Si varios usuarios suben 'product.jpg', se sobrescriben

// ‚úÖ Bueno: Nombre √∫nico con timestamp
$fileName = 'product_' . time() . '.' . $request->file('image')->extension();

// ‚úÖ Mejor: Nombre √∫nico con UUID
$fileName = Str::uuid() . '.' . $request->file('image')->extension();

// ‚úÖ Autom√°tico: Laravel genera nombres √∫nicos con store()
$path = $request->file('image')->store('products', 'public');
// Laravel genera: "products/abc123def456ghi789.jpg"
```

### 7.7.6. Manejar Im√°genes Faltantes en Vistas

Siempre maneja el caso de im√°genes faltantes o eliminadas mostrando una imagen placeholder. Esto evita enlaces rotos y mejora la experiencia de usuario.


```php
<?php

{{-- ‚ùå Malo: Error si la imagen no existe --}}
<img src="{{ asset('storage/' . $product->image) }}">

{{-- ‚úÖ Bueno: Verificar primero --}}
@if($product->image && Storage::disk('public')->exists($product->image))
    <img src="{{ asset('storage/' . $product->image) }}" alt="{{ $product->name }}">
@else
    <img src="{{ asset('images/placeholder.jpg') }}" alt="Sin imagen">
@endif

{{-- ‚úÖ Mejor: Usar un accessor en el modelo --}}
<img src="{{ $product->image_url }}" alt="{{ $product->name }}">
```

**Accessor en el Modelo:**

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Storage;
use Illuminate\Database\Eloquent\Casts\Attribute;

class Product extends Model
{
    /**
     * Get the product's image URL.
     */
    protected function imageUrl(): Attribute
    {
        return Attribute::make(
            get: function () {
                if ($this->image && Storage::disk('public')->exists($this->image)) {
                    return asset('storage/' . $this->image);
                }
                return asset('images/placeholder.jpg');
            },
        );
    }
}
```

## 7.8. Flujo Completo: Subida de Imagen en un Producto

Este ejemplo completo integra todas las piezas: formulario HTML, controlador con validaci√≥n y almacenamiento, y vista para mostrar la imagen. Es el patr√≥n t√≠pico para gestionar uploads.

### 7.8.1. Formulario HTML

El formulario debe incluir `enctype="multipart/form-data"` y un input de tipo `file` para permitir la subida de archivos.

```php
<?php

{{-- resources/views/admin/products/create.blade.php --}}
<form action="{{ route('admin.products.store') }}" method="POST" enctype="multipart/form-data">
    @csrf

    <div>
        <label for="name">Nombre del Producto</label>
        <input type="text" id="name" name="name" value="{{ old('name') }}" required>
        @error('name')
            <p class="text-red-500">{{ $message }}</p>
        @enderror
    </div>

    <div>
        <label for="image">Imagen del Producto</label>
        <input type="file" id="image" name="image" accept="image/*" required>
        @error('image')
            <p class="text-red-500">{{ $message }}</p>
        @enderror
    </div>

    <button type="submit">Crear Producto</button>
</form>
```

### 7.8.2. Controlador

El controlador valida el archivo, lo guarda en storage, y almacena la ruta en la base de datos. Tambi√©n incluye m√©todos para actualizar y eliminar im√°genes correctamente.

```php
<?php

namespace App\Http\Controllers;

use App\Models\Product;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;

class ProductController extends Controller
{
    /**
     * Mostrar formulario de creaci√≥n.
     */
    public function create()
    {
        return view('admin.products.create');
    }

    /**
     * Guardar nuevo producto.
     */
    public function store(Request $request)
    {
        // 1. Validar datos
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'image' => 'required|image|mimes:jpeg,png,jpg,gif|max:2048',
        ]);

        // 2. Guardar imagen en Storage
        $imagePath = $request->file('image')->store('products', 'public');

        // 3. Crear producto en la base de datos
        $product = Product::create([
            'name' => $validated['name'],
            'image' => $imagePath,
        ]);

        // 4. Redirigir con mensaje de √©xito
        return redirect()->route('admin.products.index')
            ->with('success', 'Producto creado exitosamente');
    }

    /**
     * Actualizar producto existente.
     */
    public function update(Request $request, Product $product)
    {
        // 1. Validar datos (imagen opcional en actualizaci√≥n)
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'image' => 'nullable|image|mimes:jpeg,png,jpg,gif|max:2048',
        ]);

        // 2. Actualizar nombre
        $product->name = $validated['name'];

        // 3. Si se subi√≥ nueva imagen
        if ($request->hasFile('image')) {
            // 3a. Eliminar imagen anterior
            if ($product->image && Storage::disk('public')->exists($product->image)) {
                Storage::disk('public')->delete($product->image);
            }

            // 3b. Guardar nueva imagen
            $product->image = $request->file('image')->store('products', 'public');
        }

        // 4. Guardar cambios
        $product->save();

        // 5. Redirigir con mensaje de √©xito
        return redirect()->route('admin.products.index')
            ->with('success', 'Producto actualizado exitosamente');
    }

    /**
     * Eliminar producto.
     */
    public function destroy(Product $product)
    {
        // 1. Eliminar imagen de Storage
        if ($product->image && Storage::disk('public')->exists($product->image)) {
            Storage::disk('public')->delete($product->image);
        }

        // 2. Eliminar producto de la base de datos
        $product->delete();

        // 3. Redirigir con mensaje de √©xito
        return redirect()->route('admin.products.index')
            ->with('success', 'Producto eliminado exitosamente');
    }
}
```

### 7.8.3. Mostrar Imagen en la Vista

En la vista, verifica siempre que la imagen existe antes de mostrarla. Si no existe, muestra una imagen placeholder para mantener una buena experiencia de usuario.


```php
<?php

{{-- resources/views/products/show.blade.php --}}
<div class="product-card">
    <div class="product-image">
        @if($product->image && Storage::disk('public')->exists($product->image))
            <img src="{{ asset('storage/' . $product->image) }}" 
                 alt="{{ $product->name }}"
                 class="w-full h-64 object-cover">
        @else
            <img src="{{ asset('images/placeholder.jpg') }}" 
                 alt="Sin imagen"
                 class="w-full h-64 object-cover">
        @endif
    </div>

    <div class="product-info">
        <h2>{{ $product->name }}</h2>
    </div>
</div>
```
