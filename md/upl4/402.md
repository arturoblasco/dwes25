# 4.2. Sistema de validación

En el **apartado 1** viste cómo proteger formularios con CSRF y buenas prácticas de seguridad. Ahora es momento de profundizar en el **corazón de la seguridad de formularios**: el sistema de validación de Laravel.

La validación es el proceso de verificar que los datos ingresados por el usuario cumplan con los criterios especificados antes de ser procesados por la aplicación. Laravel proporciona un sistema de validación robusto y flexible que permite crear reglas personalizadas, manejar errores elegantemente y proporcionar feedback claro al usuario.

## 1. Fundamentos de la validación

### 1.1. ¿Qué es la validación?

La validación es el proceso de verificar que los datos cumplan con las reglas definidas antes de ser procesados. Es una capa de seguridad esencial que previene errores, mantiene la integridad de los datos y mejora la experiencia del usuario.


### 1.2. Tipos de validación

| Tipo | Descripción | Ejemplo |
| --- | --- | --- |
| **Frontend** | Validación en el navegador | JavaScript, HTML5 |
| **Backend** | Validación en el servidor | Laravel Validation |
| **Base de Datos** | Validación a nivel de BD | Constraints, Triggers |


**¿Por qué 3 capas?**

* **Frontend**: Mejora experiencia del usuario (feedback inmediato).
* **Backend**: Seguridad real (nunca confiar en el cliente).
* **Base de datos**: Última defensa (por si algo falla en Backend).


> **La validación backend es obligatoria**
> 
> NUNCA te fíes solo de la validación Frontend. Un atacante puede:
> 
> * Desactivar JavaScript en su navegador
> * Modificar el HTML con las herramientas del navegador
> * Enviar peticiones HTTP directamente sin usar tu formulario
> 
> **La validación de Laravel (backend) es tu verdadera seguridad.**

## 2. Sistema de validación de Laravel

Laravel proporciona un sistema de validación potente y expresivo que permite definir reglas de manera clara y concisa. Veamos desde la validación más básica hasta casos avanzados.

### 2.1. Validación básica

La forma más simple de validar datos en Laravel es usando el método **`validate()`** directamente en el `request` dentro del controlador.


```php
<?php
// Validación básica en el controlador
public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required|string|max:255',
        'email' => 'required|email|unique:users',
        'password' => 'required|min:8|confirmed',
    ]);

    // Los datos validados están disponibles en $validated
    User::create($validated);
}
```

### 2.2. Reglas de validación comunes

Laravel incluye docenas de reglas de validación predefinidas para los casos más comunes. Aquí están las más utilizadas:

| Regla | Descripción | Ejemplo |
| --- | --- | --- |
| `required` | Campo obligatorio | `'name' => 'required'` |
| `string` | Debe ser texto | `'name' => 'string'` |
| `email` | Formato de email válido | `'email' => 'email'` |
| `numeric` | Debe ser numérico | `'price' => 'numeric'` |
| `min:valor` | Valor mínimo | `'age' => 'min:18'` |
| `max:valor` | Valor máximo | `'name' => 'max:255'` |
| `unique:tabla` | Único en la tabla | `'email' => 'unique:users'` |
| `confirmed` | Debe tener confirmación | `'password' => 'confirmed'` |
| `exists:tabla` | Debe existir en la tabla | `'category_id' => 'exists:categories,id'` |

### 2.3. Validación con múltiples reglas

Puedes combinar múltiples reglas de validación en un solo campo usando el separador **`|`** (pipe) o mediante un array.

```php
<?php
$request->validate([
    'name' => 'required|string|max:255|min:3',
    'email' => 'required|email|unique:users,email',
    'password' => 'required|string|min:8|confirmed',
    'age' => 'required|integer|min:18|max:120',
    'website' => 'nullable|url',
    'phone' => 'nullable|regex:/^[0-9]{9}$/',
]);
```

## 3. Validación avanzada

Las aplicaciones reales a menudo requieren validación de estructuras complejas: arrays de datos, campos condicionales y archivos con requisitos específicos.

### 3.1. Validación de arrays

Cuando tu formulario envía múltiples elementos (como una lista de productos o etiquetas) Laravel puede validar cada elemento del array individualmente usando la notación con asterisco **`*`**.

```php
<?php
// Validación de arrays
$request->validate([
    'tags' => 'array',
    'tags.*' => 'exists:tags,id',
    'products' => 'array|min:1',
    'products.*.name' => 'required|string',
    'products.*.price' => 'required|numeric|min:0',
]);
```
Explicación:

- `'tags' => 'array'` Indica que el campo tags debe ser un array.
- `'tags.*' => 'exists:tags,id'` El asterisco (\*) significa "cada elemento del array". Esta regla valida que cada elemento dentro del array tags exista en la columna id de la tabla tags en la base de datos.
- `'products' => 'array|min:1'`  El campo products también debe ser un array, y además debe contener al menos 1 elemento (min:1).
- `'products.*.name' => 'required|string'`  Valida que cada producto dentro del array tenga un campo name obligatorio y de tipo texto (string).
- `'products.*.price' => 'required|numeric|min:0'`  Valida que cada producto tenga un campo price: obligatorio (required),numérico (numeric), y con un mínimo valor 0 (no negativo).



### 3.2. Validación condicional

A veces necesitas validar un campo solo si se cumple cierta condición. Por ejemplo, solicitar el nombre de empresa solo si el tipo de usuario es "empresa".

```php
<?php
// Validación condicional
$request->validate([
    'type' => 'required|in:individual,company',
    'company_name' => 'required_if:type,company|string|max:255',
    'tax_id' => 'required_if:type,company|string|max:20',
]);
```
Explicación:

- `'type' => 'required|in:individual,company'`  El campo type es obligatorio(required). Su valor solo puede ser "individual" o "company" (in:individual,company).
- `'company_name' => 'required_if:type,company|string|max:255'` El campo company_name solo es obligatorio si el campo type tiene el valor "company".
- `'tax_id' => 'required_if:type,company|string|max:20'` También es obligatorio solo si type = company.Debe ser una cadena de texto con un máximo de 20 caracteres (por ejemplo, un NIF o CIF).


### 3.3. Validación de archivos

La validación de archivos es crítica para la seguridad. Laravel proporciona reglas específicas para verificar el tipo, tamaño y dimensiones de archivos subidos.

```php
<?php
// Validación de archivos
$request->validate([
    'image' => 'required|image|mimes:jpeg,png,jpg|max:2048',
    'document' => 'nullable|file|mimes:pdf,doc,docx|max:10240',
    'avatar' => 'nullable|image|dimensions:min_width=100,min_height=100',
]);
```

## 4. Reglas personalizadas

Laravel proporciona decenas de reglas de validación predefinidas, pero a veces necesitas crear reglas específicas para tu aplicación.

### 4.1. Crear reglas personalizadas

Cuando las reglas predefinidas de Laravel no cubren tus necesidades específicas, puedes **crear tus propias reglas de validación personalizadas**. Esto es útil para validaciones complejas de negocio que requieren lógica específica de tu aplicación.



```php
<?php
// Crear regla personalizada
php artisan make:rule StrongPassword
```

```php
<?php

namespace App\Rules;

use Illuminate\Contracts\Validation\Rule;

class StrongPassword implements Rule
{
    public function passes($attribute, $value)
    {
        return preg_match('/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/', $value);
    }

    public function message()
    {
        return 'La contraseña debe contener al menos 8 caracteres, una mayúscula, una minúscula, un número y un carácter especial.';
    }
}
```

### 4.2. Usar reglas personalizadas

Una vez creada la regla personalizada, puedes usarla como cualquier otra regla de validación de Laravel.

```php
<?php
use App\Rules\StrongPassword;

$request->validate([
    'password' => ['required', new StrongPassword],
]);
```

### 4.3. Reglas con parámetros

Las reglas personalizadas pueden aceptar parámetros en su constructor, permitiendo crear validaciones más flexibles y reutilizables.

```php
<?php

namespace App\Rules;

use Illuminate\Contracts\Validation\Rule;

class NotBlacklisted implements Rule
{
    protected $blacklist;

    public function __construct($blacklist = [])
    {
        $this->blacklist = $blacklist;
    }

    public function passes($attribute, $value)
    {
        return !in_array(strtolower($value), $this->blacklist);
    }

    public function message()
    {
        return 'El valor no está permitido.';
    }
}
```

## 5. Manejo de errores

Cuando la validación falla, Laravel redirige automáticamente al usuario de vuelta al formulario con los errores. Es crucial mostrar estos errores de forma clara para que el usuario sepa qué corregir.

### 5.1. Mostrar errores en Blade

```html
<!-- Mostrar errores específicos -->
<div>
    <label for="name">Nombre</label>
    <input type="text" id="name" name="name" 
           class="@error('name') border-red-500 @enderror"
           value="{{ old('name') }}">
    @error('name')
        <p class="text-red-600 text-sm mt-1">{{ $message }}</p>
    @enderror
</div>

<!-- Mostrar todos los errores -->
@if($errors->any())
    <div class="alert alert-danger">
        <ul>
            @foreach($errors->all() as $item)
                <li>{{ $item }}</li>
            @endforeach
        </ul>
    </div>
@endif
```

### 5.2. Mensajes personalizados

Los mensajes de error predeterminados de Laravel están en inglés. Puedes personalizarlos para que sean más específicos y acordes a tu aplicación.

```php
<?php
// Mensajes personalizados
$request->validate([
    'email' => 'required|email',
    'password' => 'required|min:8',
], [
    'email.required' => 'El campo email es obligatorio.',
    'email.email' => 'El email debe tener un formato válido.',
    'password.required' => 'La contraseña es obligatoria.',
    'password.min' => 'La contraseña debe tener al menos 8 caracteres.',
]);
```

### 5.3. Atributos personalizados

En lugar de personalizar cada mensaje, puedes cambiar cómo Laravel nombra los campos en los mensajes de error.

```php
<?php
// Atributos personalizados
$request->validate([
    'first_name' => 'required|string',
    'last_name' => 'required|string',
], [], [
    'first_name' => 'nombre',
    'last_name' => 'apellido',
]);
```

## 6. Validación en formularios

La validación se puede aplicar tanto en el frontend (navegador) como en el backend (Laravel). **Ambas son complementarias y necesarias**.

### 6.1. Validación frontend con HTML5

HTML5 proporciona validación básica en el navegador antes de enviar el formulario, mejorando la experiencia del usuario con feedback inmediato.

```html
<!-- Validación HTML5 -->
<form>
    <input type="text" name="name" required minlength="3" maxlength="255">
    <input type="email" name="email" required>
    <input type="password" name="password" required minlength="8">
    <input type="number" name="age" min="18" max="120">
    <input type="url" name="website">
    <input type="tel" name="phone" pattern="[0-9]{9}">
</form>
```

### 6.2. Validación con JavaScript

Para validaciones más complejas o personalizadas en el frontend, puedes usar JavaScript puro. Esto te permite crear reglas específicas y proporcionar feedback inmediato mientras el usuario rellena el formulario.

```javascript
// Validación con JavaScript
function validateForm() {
    const name = document.getElementById('name').value;
    const email = document.getElementById('email').value;
    const password = document.getElementById('password').value;

    if (name.length < 3) {
        showError('name', 'El nombre debe tener al menos 3 caracteres');
        return false;
    }

    if (!isValidEmail(email)) {
        showError('email', 'El email no es válido');
        return false;
    }

    if (password.length < 8) {
        showError('password', 'La contraseña debe tener al menos 8 caracteres');
        return false;
    }

    return true;
}

function isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}
```

### 6.3. Validación en tiempo real

La validación en tiempo real proporciona feedback instantáneo mientras el usuario interactúa con el formulario. Se activa al salir de un campo (evento `blur`) o mientras escribe (evento `input`), mejorando significativamente la experiencia del usuario.

```javascript
// Validación en tiempo real
document.getElementById('email').addEventListener('blur', function() {
    const email = this.value;
    if (email && !isValidEmail(email)) {
        showError('email', 'El email no es válido');
    } else {
        clearError('email');
    }
});
```

## 7. Validación de relaciones

Cuando trabajas con bases de datos relacionales, es crucial validar que las referencias entre tablas sean válidas antes de crear o actualizar registros.

### 7.1. Validación de claves foráneas

La regla `exists` verifica que un valor exista en una tabla específica antes de permitir su uso como clave foránea. Esto previene errores de integridad referencial.

```php
<?php
// Validar que la categoría existe
$request->validate([
    'category_id' => 'required|exists:categories,id',
    'tags' => 'array',
    'tags.*' => 'exists:tags,id',
]);
```

### 7.2. Validación de relaciones Muchos a Muchos

En relaciones muchos a muchos (como productos y etiquetas), necesitas validar arrays de IDs para asegurar que todos los elementos relacionados existan en sus respectivas tablas.

```php
<?php
// Validar etiquetas de producto
$request->validate([
    'product_id' => 'required|exists:products,id',
    'tags' => 'array|min:1',
    'tags.*' => 'exists:tags,id',
]);
```

### 7.3. Validación de unicidad con condiciones

Al editar registros, necesitas validar unicidad pero excluyendo el registro actual. Laravel permite añadir excepciones y condiciones adicionales a la regla `unique`.

```php
<?php
// Validar unicidad con condiciones
$request->validate([
    'email' => 'required|email|unique:users,email,' . $user->id,
    'slug' => 'required|unique:products,slug,' . $product->id . ',id,category_id,' . $request->category_id,
]);
```

## 8. Validación de formularios complejos

Los formularios del mundo real a menudo combinan múltiples tipos de datos: información básica, relaciones, archivos e inventario. Aquí verás ejemplos completos de validación para estos casos.

### 8.1. Formulario de producto con inventario

Un formulario completo de producto incluye datos básicos, relaciones con categorías y etiquetas, control de inventario y archivos. Todas estas validaciones deben trabajar en conjunto.

```php
<?php
// Validación completa de producto
$request->validate([
    // Datos del producto
    'name' => 'required|string|max:255',
    'description' => 'required|string|max:1000',
    'price' => 'required|numeric|min:0|max:999999.99',
    'category_id' => 'required|exists:categories,id',
    
    // Etiquetas
    'tags' => 'array',
    'tags.*' => 'exists:tags,id',
    
    // Inventario
    'quantity' => 'required|integer|min:0',
    'location' => 'required|string|max:255',
    'reorder_level' => 'required|integer|min:0',
    
    // Archivo
    'image' => 'nullable|image|mimes:jpeg,png,jpg|max:2048',
]);
```

### 8.2. Validación de formularios anidados

Los formularios pueden enviar datos en estructuras anidadas (arrays dentro de arrays). Laravel permite validar cada nivel de anidación usando la notación de punto.

```php
<?php
// Validación de formularios anidados
$request->validate([
    'user' => 'required|array',
    'user.name' => 'required|string|max:255',
    'user.email' => 'required|email|unique:users,email',
    'user.profile' => 'required|array',
    'user.profile.bio' => 'nullable|string|max:500',
    'user.profile.avatar' => 'nullable|image|max:1024',
]);
```

## 9. Mejores prácticas

Para mantener tu código limpio, mantenible y escalable, es importante seguir las mejores prácticas de validación que Laravel propone.

### 9.1. Validación en el controlador

La forma más directa de validar es hacerlo en el método del controlador. Es apropiada para validaciones simples que no se reutilizan en múltiples lugares.

```php
<?php
// Validación en el controlador
public function store(Request $request)
{
    $validated = $request->validate([
        'name' => 'required|string|max:255',
        'email' => 'required|email|unique:users',
    ]);

    // Usar solo datos validados
    $user = User::create($validated);
    
    return redirect()->route('users.show', $user)
        ->with('success', 'Usuario creado exitosamente');
}
```

### 9.2. Validación en Form Requests

**Form Requests: Organizando la Validación Compleja**

Cuando un formulario tiene muchas reglas de validación, es mejor práctica crear una clase **Form Request** dedicada en lugar de tener todo en el controlador.

**Ventajas:**

✅ **Código limpio**: El controlador se mantiene simple.

✅ **Reutilizable**: Puedes usar la misma validación en múltiples métodos.

✅ **Autorización integrada**: Puedes verificar permisos en el mismo lugar.

✅ **Mensajes centralizados**: Todos los mensajes de error en un solo archivo.

✅ **Testing más fácil**: Puedes testear la validación de forma aislada.

```bash
// Crear Form Request
php artisan make:request StoreProductRequest
```

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreProductRequest extends FormRequest
{
    public function authorize()
    {
        return true;
    }

    public function rules()
    {
        return [
            'name' => 'required|string|max:255',
            'description' => 'required|string|max:1000',
            'price' => 'required|numeric|min:0',
            'category_id' => 'required|exists:categories,id',
        ];
    }

    public function messages()
    {
        return [
            'name.required' => 'El nombre del producto es obligatorio.',
            'price.min' => 'El precio debe ser mayor a 0.',
        ];
    }
}
```

### 9.3. Usar Form Requests en controladores


```php
<?php
// Usar Form Request en el controlador
public function store(StoreProductRequest $request)
{
    $validated = $request->validated();
    $product = Product::create($validated);
    
    return redirect()->route('products.show', $product);
}
```
