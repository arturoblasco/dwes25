UD.3 Práctica Guiada: Persistencia de Datos con Laravel | Introducción a Laravel



[Skip to content](#VPContent)

[![](/25-26-introduccion-laravel/img/logo.png)Introducción a  
Laravel](/25-26-introduccion-laravel/)

Appearance

Menu

Return to top

 Sidebar Navigation 

## Sesión 3: Gestión de Datos

[Inicio](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/)

[1. Migraciones y Estructura de Base de Datos](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/1-migraciones-estructura-bd.html)

[2. Introducción a Eloquent ORM](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/2-introduccion-eloquent-orm.html)

[3. Operaciones CRUD con Eloquent](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/3-operaciones-crud-eloquent.html)

[4. Relaciones en Eloquent](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/4-relaciones-eloquent.html)

[5. Seeders y Factories](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/5-seeders-factories.html)

## Ejercicios Prácticos

[P3. Persistencia de Datos](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/p3-persistencia-de-datos.html)

![](/25-26-introduccion-laravel/img/logo-autor.png)

![](/25-26-introduccion-laravel/img/logo-gva.png)

![](/25-26-introduccion-laravel/img/logo-centro.png)

En esta página

# UD.3 Práctica Guiada: Persistencia de Datos con Laravel [​](#ud-3-practica-guiada-persistencia-de-datos-con-laravel)

## Objetivo [​](#objetivo)

El objetivo de esta práctica es migrar la tienda online de la Práctica 2 de datos mock a una base de datos real usando Laravel. Se implementarán migraciones para definir la estructura de la base de datos, modelos Eloquent para interactuar con los datos, operaciones CRUD completas, relaciones entre modelos y seeders para poblar la base de datos con datos iniciales.

### Continuidad con la Práctica 2 [​](#continuidad-con-la-practica-2)

Continuación de la Práctica 2

Esta práctica está basada en la tienda online creada en la **Práctica 2**. Se migrarán los datos mock (categorías, productos, ofertas, carrito) a una base de datos real manteniendo la misma funcionalidad y estructura.

**Base de Datos**: Se utilizará MySQL a través de Laravel Sail para la persistencia de datos.

**Datos Mock**: Los archivos mock creados en la Práctica 2 (`mock-categories.php`, `mock-products.php`, `mock-offers.php`, `mock-cart.php`) se reutilizarán en los seeders para poblar la base de datos.

### ¿Qué vamos a hacer? [​](#¿que-vamos-a-hacer)

En esta práctica aprenderás a:

* **Migrar de datos mock a base de datos real**: Transformar los arrays PHP en tablas MySQL
* **Crear migraciones**: Definir la estructura de las tablas (categorías, productos, ofertas, carrito)
* **Implementar modelos Eloquent**: Crear modelos con relaciones entre entidades
* **Realizar operaciones CRUD completas**: Crear, leer, actualizar y eliminar datos
* **Crear seeders**: Poblar la base de datos reutilizando los datos mock de la Práctica 2
* **Actualizar controladores**: Reemplazar el trait `LoadsMockData` por consultas Eloquent

---

## FASE 1: Configurar la Base de Datos [​](#fase-1-configurar-la-base-de-datos)

### **1. Verificar la Configuración de la Base de Datos** [​](#_1-verificar-la-configuracion-de-la-base-de-datos)

Antes de empezar a trabajar con la base de datos, es fundamental asegurarse de que Laravel Sail esté configurado correctamente para trabajar con MySQL.

Como ya se vio en la prácica 1, Laravel utiliza el archivo `.env` para almacenar la configuración de la aplicación, incluyendo los datos de conexión a la base de datos.

Abre el archivo `.env` y verifica que contenga la siguiente configuración:

Configuración de la base de datos

env

```
DB_CONNECTION=mysql
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=sail
DB_PASSWORD=password
```

¿Qué significa cada parámetro?

* **DB\_CONNECTION**: El tipo de base de datos que usaremos (MySQL en este caso)
* **DB\_HOST**: La dirección del servidor de base de datos (127.0.0.1 es localhost)
* **DB\_PORT**: El puerto donde MySQL está escuchando (3306 es el puerto por defecto)
* **DB\_DATABASE**: El nombre de la base de datos que usaremos
* **DB\_USERNAME**: El usuario para conectarse a MySQL
* **DB\_PASSWORD**: La contraseña del usuario

### **2. Iniciar Laravel Sail** [​](#_2-iniciar-laravel-sail)

Laravel Sail utiliza Docker para crear contenedores que incluyen todos los servicios necesarios (PHP, MySQL, Redis, etc.). Antes de trabajar con la base de datos, necesitamos asegurarnos de que estos servicios estén en funcionamiento.

Ejecuta el siguiente comando para iniciar los contenedores:

bash

```
sail up -d
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail up -d
[+] Running 7/7
 ✔ sail-8.4/app                     Built                          0.0s
 ✔ Network myshop_sail              Created                        0.0s
 ✔ Volume myshop_sail-redis         Created                        0.0s
 ✔ Volume myshop_sail-mysql         Created                        0.0s
 ✔ Container myshop-mysql-1         Started                        0.8s
 ✔ Container myshop-redis-1         Started                        0.8s
 ✔ Container myshop-laravel.test-1  Started                        1.0s
```

### **3. Verificar la Conexión a la Base de Datos** [​](#_3-verificar-la-conexion-a-la-base-de-datos)

Una vez que los contenedores están en funcionamiento, podemos verificar que Laravel puede conectarse correctamente a la base de datos MySQL.

Ejecuta el siguiente comando:

bash

```
sail artisan migrate:status
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan migrate:status

  Migration name ................................................ Batch / Status
  0001_01_01_000000_create_users_table .............................. [1] Ran
  0001_01_01_000001_create_cache_table .............................. [1] Ran
  0001_01_01_000002_create_jobs_table ............................... [1] Ran
  2025_09_30_140225_create_telescope_entries_table .................. [1] Ran
```

## FASE 2: Crear las Migraciones [​](#fase-2-crear-las-migraciones)

### **1. ¿Qué son las Migraciones?** [​](#_1-¿que-son-las-migraciones)

Las migraciones son como un "control de versiones" para la base de datos. Permiten definir y modificar la estructura de las tablas de forma programática, manteniendo un historial de cambios.

En la Práctica 2 creamos archivos mock (`mock-categories.php`, `mock-products.php`, `mock-offers.php`) que contenían arrays con datos de prueba. Ahora vamos a crear **migraciones** que definirán las **tablas reales** en MySQL con la misma estructura que tenían esos arrays.

De Arrays a Tablas

**Antes (Práctica 2)**:

php

```
// database/data/mock-categories.php
return [
    1 => ['id' => 1, 'name' => 'Categoría 1', 'slug' => 'categoria-1']
];
```

**Ahora (Práctica 3)**:

php

```
// database/migrations/xxxx_create_categories_table.php
Schema::create('categories', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->string('slug')->unique();
});
```

### **2. Crear la Migración de Categorías** [​](#_2-crear-la-migracion-de-categorias)

La tabla `categories` almacenará las categorías de productos. Esta tabla corresponde al archivo `database/data/mock-categories.php` que creaste en la Práctica 2.

Los atributos de la tabla serán los mismos que tenías en el array mock:

* **id**: Identificador único de la categoría
* **name**: Nombre de la categoría
* **slug**: Identificador amigable para URLs (por ejemplo, "electronica", "ropa-hombre")
* **description**: Descripción breve de la categoría (puede ser null)
* **timestamps**: Laravel añade automáticamente `created_at` y `updated_at`

Ejecuta el siguiente comando para crear la migración:

bash

```
sail artisan make:migration create_categories_table
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:migration create_categories_table

   INFO  Migration [database/migrations/2025_01_15_103045_create_categories_table.php] created successfully.
```

Abre el archivo generado en `database/migrations/` (el nombre incluirá la fecha y hora) y reemplaza su contenido:

Código PHP

php

```
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('categories', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('categories');
    }
};
```

Métodos up() y down()

* **up()**: Define qué hacer cuando se ejecuta la migración (crear la tabla)
* **down()**: Define cómo revertir la migración (eliminar la tabla)

Esto permite hacer y deshacer cambios en la base de datos fácilmente.

### **3. Crear la Migración de Ofertas** [​](#_3-crear-la-migracion-de-ofertas)

La tabla `offers` almacenará las ofertas especiales con descuentos. Esta tabla corresponde al archivo `database/data/mock-offers.php` que creaste en la Práctica 2.

En la Práctica 2, una oferta tenía los siguientes atributos:

* **id**: Identificador único de la oferta
* **name**: Nombre de la oferta (por ejemplo, "Descuento Primavera")
* **slug**: Identificador amigable para URLs
* **discount\_percentage**: Porcentaje de descuento (por ejemplo, 20 para un 20%)
* **description**: Descripción breve de la oferta

Ejecuta el siguiente comando para crear la migración:

bash

```
sail artisan make:migration create_offers_table
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:migration create_offers_table

   INFO  Migration [database/migrations/2025_01_15_103112_create_offers_table.php] created successfully.
```

Abre el archivo generado y reemplaza su contenido:

Código PHP

php

```
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('offers', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('slug')->unique();
            $table->integer('discount_percentage');
            $table->text('description')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('offers');
    }
};
```

Tipos de Datos en Migraciones

* `id()`: Crea un campo auto-incremental (equivalente a BIGINT UNSIGNED)
* `string()`: Crea un campo VARCHAR (por defecto 255 caracteres)
* `integer()`: Crea un campo INT
* `text()`: Crea un campo TEXT (para textos largos)
* `nullable()`: Permite valores NULL en el campo
* `unique()`: Añade un índice único al campo
* `timestamps()`: Crea automáticamente `created_at` y `updated_at`

### **4. Crear la Migración de Productos** [​](#_4-crear-la-migracion-de-productos)

La tabla `products` es el corazón de nuestra tienda. Almacenará todos los productos con sus detalles y relaciones con categorías y ofertas. Esta tabla corresponde al archivo `database/data/mock-products.php` que creaste en la Práctica 2.

En la Práctica 2, un producto tenía estos atributos:

* **id**: Identificador único del producto
* **name**: Nombre del producto
* **description**: Descripción del producto
* **price**: Precio del producto
* **category\_id**: ID de la categoría a la que pertenece
* **offer\_id**: ID de la oferta aplicable (puede ser null si no tiene oferta)

Reglas de Negocio (de la Práctica 2)

* **Una oferta** puede aplicarse a **múltiples productos** (relación 1:N)
* **Un producto** solo puede tener **una oferta activa** a la vez (o ninguna)
* No todos los productos tienen ofertas (en ese caso `offer_id` es `null`)

Ejecuta el siguiente comando para crear la migración:

bash

```
sail artisan make:migration create_products_table
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:migration create_products_table

   INFO  Migration [database/migrations/2025_01_15_103145_create_products_table.php] created successfully.
```

Abre el archivo generado y reemplaza su contenido:

Código PHP

php

```
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('products', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->text('description');
            $table->decimal('price', 10, 2);
            $table->foreignId('category_id')->constrained()->onDelete('cascade');
            $table->foreignId('offer_id')->nullable()->constrained()->onDelete('set null');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('products');
    }
};
```

Claves Foráneas y Restricciones

* `foreignId('category_id')`: Crea un campo BIGINT UNSIGNED para la relación
* `constrained()`: Crea automáticamente la clave foránea a la tabla `categories`
* `onDelete('cascade')`: Si se elimina la categoría, se eliminan todos sus productos
* `nullable()`: Permite que `offer_id` sea NULL (productos sin oferta)
* `onDelete('set null')`: Si se elimina la oferta, el campo se pone a NULL

**Importante**: Las migraciones deben ejecutarse en orden. Por eso creamos primero `categories` y `offers`, y luego `products` que las referencia.

### **5. Crear la Migración de la Tabla Pivot Product-User** [​](#_5-crear-la-migracion-de-la-tabla-pivot-product-user)

La tabla `product_user` implementa una relación **N:M** directa entre productos y usuarios. Esta tabla corresponde al archivo `database/data/mock-cart.php` que creaste en la Práctica 2, pero ahora con una estructura más clara siguiendo las convenciones de Laravel.

En la Práctica 2, el carrito tenía esta estructura:

* **id**: Identificador único del item en el carrito
* **user\_id**: ID del usuario propietario del carrito
* **product\_id**: ID del producto añadido al carrito
* **quantity**: Cantidad de unidades de ese producto

Producto-Usuario (Tabla Pivot)

**Relación N:M**: Un producto puede estar en múltiples carritos (diferentes usuarios) y un usuario puede tener múltiples productos en su carrito.

La tabla `product_user` actúa como **tabla pivot enriquecida** entre productos y usuarios:

* **product\_id**: Referencia al producto (primero por orden alfabético)
* **user\_id**: Identifica el usuario propietario del carrito
* **quantity**: Cantidad específica de ese producto en ese carrito (campo adicional)

**Convención de Laravel**: Las tablas pivot siguen el orden alfabético de los nombres de las tablas en singular: `product_user` (no `user_product`).

**¿Por qué no es una tabla pivot simple?** Una tabla pivot básica solo tendría `product_id` y `user_id`. Pero necesitamos el campo adicional `quantity`, por eso `product_user` es una tabla pivot **enriquecida**.

Ejecuta el siguiente comando para crear la migración:

bash

```
sail artisan make:migration create_product_user_table
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:migration create_product_user_table

   INFO  Migration [database/migrations/2025_01_15_103212_create_product_user_table.php] created successfully.
```

Abre el archivo generado y reemplaza su contenido:

Código PHP

php

```
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('product_user', function (Blueprint $table) {
            $table->id();
            $table->foreignId('product_id')->constrained()->onDelete('cascade');
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->integer('quantity')->default(1);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('product_user');
    }
};
```

Valores por Defecto y Tabla Pivot Enriquecida

* `default(1)`: Si no se especifica cantidad, se asigna 1
* `useCurrent()`: Usa la fecha/hora actual como valor por defecto
* `timestamp()`: Similar a `timestamps()` pero para un solo campo
* `product_id`: Clave foránea que referencia al producto (primero por orden alfabético)
* `user_id`: Clave foránea que identifica el usuario propietario del carrito

### **6. Ejecutar las Migraciones** [​](#_6-ejecutar-las-migraciones)

Ahora que hemos creado todas las migraciones, es el momento de aplicarlas a la base de datos para crear las tablas reales.

Las migraciones se ejecutan en el orden en que fueron creadas (según la fecha en el nombre del archivo). Laravel se encarga de mantener un registro de qué migraciones ya se han ejecutado.

Ejecuta el siguiente comando para aplicar todas las migraciones:

bash

```
sail artisan migrate
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan migrate

   INFO Running migrations.

   2025_10_01_163110_create_categories_table .............................. 215.03ms DONE
   2025_10_01_163209_create_offers_table .................................. 119.43ms DONE
   2025_10_01_163250_create_products_table ................................ 1s DONE
   2025_10_01_081337_create_product_user_table ............................ 307.25ms DONE
```

Verifica que las tablas se hayan creado correctamente:

bash

```
sail artisan migrate:status
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan migrate:status

  Migration name ................................................ Batch / Status
  0001_01_01_000000_create_users_table ........................... [1] Ran
  0001_01_01_000001_create_cache_table ........................... [1] Ran
  0001_01_01_000002_create_jobs_table ............................ [1] Ran
  2025_09_30_140225_create_telescope_entries_table ............... [2] Ran
  2025_10_01_163110_create_categories_table ...................... [3] Ran
  2025_10_01_163209_create_offers_table .......................... [3] Ran
  2025_10_01_163250_create_products_table ........................ [3] Ran
  2025_10_01_081337_create_product_user_table .................... [3] Ran
```

## FASE 3: Crear los Modelos Eloquent [​](#fase-3-crear-los-modelos-eloquent)

### **1. ¿Qué son los Modelos Eloquent?** [​](#_1-¿que-son-los-modelos-eloquent)

Los modelos Eloquent son la capa de abstracción que Laravel proporciona para interactuar con la base de datos. Cada modelo representa una tabla y permite realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) de forma sencilla.

En la Práctica 2, usabas el trait `LoadsMockData` para cargar arrays desde archivos PHP. Ahora, los modelos Eloquent reemplazarán esa funcionalidad, permitiendo trabajar con datos reales de la base de datos.

De Arrays a Modelos

**Antes (Práctica 2)**:

php

```
// Cargar datos mock
$categories = $this->getCategories(); // Array desde archivo PHP
```

**Ahora (Práctica 3)**:

php

```
// Cargar datos reales
$categories = Category::all(); // Consulta a la base de datos
```

### **2. Crear el Modelo User** [​](#_2-crear-el-modelo-user)

El modelo `User` ya existe en Laravel por defecto, pero necesitamos actualizarlo para incluir la relación con el carrito. Este modelo representa a los usuarios de la tienda.

Abre el archivo `app/Models/User.php` y añade la relación con el carrito:

Código PHP

php

```
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Database\Eloquent\Relations\HasMany;

class User extends Authenticatable
{
    use HasFactory, Notifiable;

    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    protected $hidden = [
        'password',
        'remember_token',
    ];

    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
        ];
    }

    /**
     * Get the products in the user's cart (N:M relationship).
     */
      public function products()
      {
          return $this->belongsToMany(Product::class, 'product_user')
              ->withPivot('quantity')
              ->withTimestamps();
      }
}
```

Relaciones del Modelo User

* **`products()`**: Relación N:M con productos a través de la tabla pivot `product_user`
* **`withPivot('quantity')`**: Incluye el campo adicional `quantity` de la tabla pivot
* **`withTimestamps()`**: Incluye los timestamps de la tabla pivot (`created_at`, `updated_at`)

**Acceso al carrito**: `$user->products` devuelve los productos en el carrito del usuario.

### **3. Crear el Modelo Category** [​](#_3-crear-el-modelo-category)

El modelo `Category` representa la tabla `categories` y define la relación con los productos. Este modelo reemplazará el uso del array mock `mock-categories.php` de la Práctica 2.

Ejecuta el siguiente comando para crear el modelo:

bash

```
sail artisan make:model Category
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:model Category

   INFO  Model [app/Models/Category.php] created successfully.
```

Abre el archivo `app/Models/Category.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Category extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'slug',
        'description',
    ];

    /**
     * Get the products for the category.
     */
    public function products(): HasMany
    {
        return $this->hasMany(Product::class);
    }
}
```

Propiedades del Modelo

* **`$fillable`**: Define qué campos pueden ser asignados masivamente (importante para seguridad)
* **`HasFactory`**: Permite usar factories para generar datos de prueba
* **`products()`**: Define la relación "una categoría tiene muchos productos"

**Relación HasMany**: Una categoría puede tener múltiples productos, pero cada producto pertenece a una sola categoría.

### **4. Crear el Modelo Offer** [​](#_4-crear-el-modelo-offer)

El modelo `Offer` representa la tabla `offers` y define la relación con los productos. Este modelo reemplazará el uso del array mock `mock-offers.php` de la Práctica 2.

Ejecuta el siguiente comando para crear el modelo:

bash

```
sail artisan make:model Offer
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:model Offer

   INFO  Model [app/Models/Offer.php] created successfully.
```

Abre el archivo `app/Models/Offer.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Offer extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'slug',
        'discount_percentage',
        'description',
    ];

    /**
     * Get the products that have this offer.
     */
    public function products(): HasMany
    {
        return $this->hasMany(Product::class);
    }
}
```

Relación con Productos

Según las reglas de negocio de la Práctica 2:

* **Una oferta** puede aplicarse a **múltiples productos** (relación 1:N)
* **Un producto** solo puede tener **una oferta activa** a la vez
* Por eso usamos `HasMany` en el modelo `Offer`

### **5. Crear el Modelo Product** [​](#_5-crear-el-modelo-product)

El modelo `Product` es el más importante de nuestra tienda. Representa la tabla `products` y define todas las relaciones con categorías, ofertas y usuarios. Este modelo reemplazará el uso del array mock `mock-products.php` de la Práctica 2.

Ejecuta el siguiente comando para crear el modelo:

bash

```
sail artisan make:model Product
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:model Product

   INFO  Model [app/Models/Product.php] created successfully.
```

Abre el archivo `app/Models/Product.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Product extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'description',
        'price',
        'category_id',
        'offer_id',
    ];

    /**
     * Get the attributes that should be cast.
     */
    protected function casts(): array
    {
        return [
            'price' => 'decimal:2',
        ];
    }

    /**
     * Get the category that owns the product.
     */
    public function category(): BelongsTo
    {
        return $this->belongsTo(Category::class);
    }

    /**
     * Get the offer that applies to this product.
     */
    public function offer(): BelongsTo
    {
        return $this->belongsTo(Offer::class);
    }

    /**
     * Get the users who have this product in their cart (N:M relationship).
     */
      public function users()
    {
          return $this->belongsToMany(User::class, 'product_user')
              ->withPivot('quantity')
              ->withTimestamps();
    }

    /**
     * Get the product's final price after applying discounts.
     */
    protected function finalPrice(): Attribute
    {
        return Attribute::make(
            get: function () {
                if ($this->offer && $this->offer->discount_percentage > 0) {
                    $discount = $this->price * ($this->offer->discount_percentage / 100);
                    return round($this->price - $discount, 2);
                }
                return $this->price;
            },
        );
    }
}
```

Accessor finalPrice()

Hemos añadido un **accessor** `finalPrice()` que calcula automáticamente el precio final del producto aplicando el descuento de la oferta si existe. Esto simplifica enormemente el código en las vistas, eliminando la necesidad de bloques `@php` para calcular precios.

Relaciones del Modelo Product

* **`category()`**: Cada producto pertenece a una categoría (BelongsTo)
* **`offer()`**: Cada producto puede tener una oferta (BelongsTo, nullable)
* **`users()`**: Relación N:M con usuarios a través de la tabla pivot `product_user`

**`$casts`**: Convierte automáticamente el campo `price` a decimal con 2 decimales.

**Acceso a carritos**: `$product->users` devuelve los usuarios que tienen este producto en su carrito.

## FASE 4: Crear los Seeders [​](#fase-4-crear-los-seeders)

### **1. ¿Qué son los Seeders?** [​](#_1-¿que-son-los-seeders)

Los seeders son clases que permiten poblar la base de datos con datos iniciales. En lugar de insertar datos manualmente en MySQL, los seeders automatizan este proceso.

En la Práctica 2 creaste archivos mock con datos de prueba (`mock-categories.php`, `mock-products.php`, `mock-offers.php`, `mock-cart.php`). Ahora vamos a **reutilizar esos mismos datos** en los seeders para poblar la base de datos real.

Reutilizando Datos Mock

En lugar de duplicar los datos en los seeders, reutilizaremos el trait `LoadsMockData` creado en la Práctica 2. Esto mantiene la consistencia de datos y evita duplicación de código.

**Ventajas**:

* **Consistencia**: Los mismos datos en desarrollo y en la base de datos
* **Mantenimiento**: Un solo lugar para modificar los datos
* **DRY**: No se duplica código ni información
* **Migración suave**: Transición transparente de mock a base de datos real

### **2. Crear el Seeder de Usuarios** [​](#_2-crear-el-seeder-de-usuarios)

Como no tenemos datos mock de usuarios en la Práctica 2, crearemos algunos usuarios de prueba para la funcionalidad del carrito usando el sistema de Factories de Laravel.

Ejecuta el siguiente comando para crear el seeder:

bash

```
sail artisan make:seeder UserSeeder
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:seeder UserSeeder

   INFO  Seeder [database/seeders/UserSeeder.php] created successfully.
```

Abre el archivo `database/seeders/UserSeeder.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace Database\Seeders;

use App\Models\User;
use Illuminate\Database\Seeder;

class UserSeeder extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        // Crear un usuario específico con datos conocidos
        User::factory()->create([
            'name' => 'Usuario Demo',
            'email' => 'demo@example.com',
        ]);

        // Crear usuarios adicionales con datos aleatorios
        User::factory(2)->create();
    }
}
```

¿Cómo funciona?

1. **`User::factory()`**: Usa la factory predefinida de Laravel para generar usuarios
2. **`create([...])`**: Crea un usuario con datos específicos (sobrescribe los valores por defecto)
3. **`factory(2)->create()`**: Crea 2 usuarios adicionales con datos aleatorios generados por Faker

**Resultado**: Se crean 3 usuarios en total (1 con email conocido + 2 aleatorios)

#### **Ejemplo de UserFactory (ya incluida en Laravel)** [​](#ejemplo-de-userfactory-ya-incluida-en-laravel)

Laravel incluye por defecto una factory para usuarios en `database/factories/UserFactory.php`:

Código de UserFactory (Referencia)

php

```
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

class UserFactory extends Factory
{
    protected static ?string $password;

    public function definition(): array
    {
        return [
            'name' => fake()->name(),
            'email' => fake()->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => static::$password ??= Hash::make('password'),
            'remember_token' => Str::random(10),
        ];
    }

    public function unverified(): static
    {
        return $this->state(fn (array $attributes) => [
            'email_verified_at' => null,
        ]);
    }
}
```

¿Cómo funciona la UserFactory?

1. **name**: Genera un nombre aleatorio usando Faker (`fake()->name()`).
2. **email**: Genera un email único y seguro con Faker (`fake()->unique()->safeEmail()`).
3. **email\_verified\_at**: Asigna la fecha y hora actual para indicar que el email está verificado (`now()`).
4. **password**: Cifra la contraseña por defecto usando el helper de Laravel `Hash::make('password')`.
5. **remember\_token**: Genera un token aleatorio de 10 caracteres para la funcionalidad de "recordar sesión" (`Str::random(10)`).
6. **unverified()**: Permite crear usuarios con el email sin verificar, sobreescribiendo el campo `email_verified_at` a `null`.

### **3. Crear el Seeder de Categorías** [​](#_3-crear-el-seeder-de-categorias)

El `CategorySeeder` poblará la tabla `categories` con datos iniciales reutilizando los datos del archivo `database/data/mock-categories.php` de la Práctica 2.

Ejecuta el siguiente comando para crear el seeder:

bash

```
sail artisan make:seeder CategorySeeder
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:seeder CategorySeeder

   INFO  Seeder [database/seeders/CategorySeeder.php] created successfully.
```

Abre el archivo `database/seeders/CategorySeeder.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace Database\Seeders;

use App\Models\Category;
use App\Traits\LoadsMockData;
use Illuminate\Database\Seeder;

class CategorySeeder extends Seeder
{
    use LoadsMockData;

    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        $categories = $this->getCategories();

        foreach ($categories as $category) {
            Category::create($category);
        }
    }
}
```

¿Cómo funciona?

1. **`use LoadsMockData`**: Reutiliza el trait de la Práctica 2
2. **`$this->getCategories()`**: Carga los datos desde `database/data/mock-categories.php`
3. **`Category::create($category)`**: Inserta cada categoría en la base de datos

**Resultado**: Las categorías de tu archivo mock se insertan automáticamente en la tabla `categories`.

### **4. Crear el Seeder de Ofertas** [​](#_4-crear-el-seeder-de-ofertas)

El `OfferSeeder` poblará la tabla `offers` con datos iniciales reutilizando los datos del archivo `database/data/mock-offers.php` de la Práctica 2.

Ejecuta el siguiente comando para crear el seeder:

bash

```
sail artisan make:seeder OfferSeeder
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:seeder OfferSeeder

   INFO  Seeder [database/seeders/OfferSeeder.php] created successfully.
```

Abre el archivo `database/seeders/OfferSeeder.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace Database\Seeders;

use App\Models\Offer;
use App\Traits\LoadsMockData;
use Illuminate\Database\Seeder;

class OfferSeeder extends Seeder
{
    use LoadsMockData;

    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        $offers = $this->getOffers();

        foreach ($offers as $offer) {
            Offer::create($offer);
        }
    }
}
```

¿Cómo funciona?

1. **`use LoadsMockData`**: Reutiliza el trait de la Práctica 2
2. **`$this->getOffers()`**: Carga los datos desde `database/data/mock-offers.php`
3. **`Offer::create($offer)`**: Inserta cada oferta en la base de datos

**Resultado**: Las ofertas de tu archivo mock se insertan automáticamente en la tabla `offers`.

### **5. Crear el Seeder de Productos** [​](#_5-crear-el-seeder-de-productos)

El `ProductSeeder` poblará la tabla `products` con datos iniciales reutilizando los datos del archivo `database/data/mock-products.php` de la Práctica 2.

**Importante**: Los productos deben crearse **después** de las categorías y ofertas, ya que tienen claves foráneas que referencian esas tablas.

Ejecuta el siguiente comando para crear el seeder:

bash

```
sail artisan make:seeder ProductSeeder
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:seeder ProductSeeder

   INFO  Seeder [database/seeders/ProductSeeder.php] created successfully.
```

Abre el archivo `database/seeders/ProductSeeder.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace Database\Seeders;

use App\Models\Product;
use App\Traits\LoadsMockData;
use Illuminate\Database\Seeder;

class ProductSeeder extends Seeder
{
    use LoadsMockData;

    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        $products = $this->getProducts();

        foreach ($products as $product) {
            Product::create($product);
        }
    }
}
```

¿Cómo funciona?

1. **`use LoadsMockData`**: Reutiliza el trait de la Práctica 2
2. **`$this->getProducts()`**: Carga los datos desde `database/data/mock-products.php`
3. **`Product::create($product)`**: Inserta cada producto en la base de datos

**Resultado**: Los productos de tu archivo mock se insertan automáticamente en la tabla `products` con sus relaciones a categorías y ofertas.

**Importante**: Laravel maneja automáticamente las claves foráneas (`category_id`, `offer_id`) basándose en los IDs de los datos mock.

### **6. Crear el Seeder del Carrito** [​](#_6-crear-el-seeder-del-carrito)

El `ProductUserSeeder` poblará la tabla `product_user` con datos iniciales reutilizando los datos del archivo `database/data/mock-cart.php` de la Práctica 2, pero adaptándolos para usar la relación N:M entre usuarios y productos.

**Importante**: Los items del carrito deben crearse **después** de los usuarios y productos, ya que la tabla pivot referencia ambas tablas.

Ejecuta el siguiente comando para crear el seeder:

bash

```
sail artisan make:seeder ProductUserSeeder
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan make:seeder ProductUserSeeder

   INFO  Seeder [database/seeders/ProductUserSeeder.php] created successfully.
```

Abre el archivo `database/seeders/ProductUserSeeder.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace Database\Seeders;

use App\Models\User;
use App\Traits\LoadsMockData;
use Illuminate\Database\Seeder;

class ProductUserSeeder extends Seeder
{
    use LoadsMockData;

    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        $cartItems = $this->getCart();

        // Obtener el primer usuario
        $user = User::first();

        foreach ($cartItems as $item) {
            // Usar attach() para añadir productos al carrito del usuario
            $user->products()->attach($item['product_id'], [
                'quantity' => $item['quantity'],
            ]);
        }
    }
}
```

¿Cómo funciona?

1. **`use LoadsMockData`**: Reutiliza el trait de la Práctica 2
2. **`$this->getCart()`**: Carga los datos desde `database/data/mock-cart.php`
3. **`User::first()`**: Obtiene el primer usuario creado
4. **`attach()`**: Método de Laravel para añadir registros a una tabla pivot
5. **Campo adicional**: `quantity` se pasa como segundo parámetro

**Resultado**: Los items del carrito de tu archivo mock se insertan automáticamente en la tabla `product_user` usando la relación N:M.

### **7. Actualiza el Seeder Principal** [​](#_7-actualiza-el-seeder-principal)

El `DatabaseSeeder` es el seeder principal que ejecuta todos los demás seeders en el orden correcto. Es importante ejecutarlos en el orden adecuado para respetar las claves foráneas.

Abre el archivo `database/seeders/DatabaseSeeder.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        $this->call([
            UserSeeder::class,
            CategorySeeder::class,
            OfferSeeder::class,
            ProductSeeder::class,
            ProductUserSeeder::class,
        ]);
    }
}
```

Orden de Ejecución

Los seeders se ejecutan en este orden para respetar las claves foráneas:

1. **UserSeeder**: Crea los usuarios
2. **CategorySeeder**: Crea las categorías
3. **OfferSeeder**: Crea las ofertas
4. **ProductSeeder**: Crea los productos (referencia categorías y ofertas)
5. **ProductUserSeeder**: Puebla la tabla pivot `product_user` (referencia usuarios y productos)

### **8. Ejecutar los Seeders** [​](#_8-ejecutar-los-seeders)

Ahora que tenemos todos los seeders configurados, es el momento de poblar la base de datos con datos iniciales reutilizando los datos mock de la Práctica 2.

Ejecuta el siguiente comando para ejecutar todos los seeders:

bash

```
sail artisan migrate:refresh --seed
```

Ejemplo de respuesta

bash

```
ggarrido@mi-equipo:~/development/laravel/MyShop$ sail artisan db:seed

    INFO  Rolling back migrations.

    2025_10_02_081337_create_product_user_table ............... 70.39ms DONE
    2025_10_01_163250_create_products_table ................... 44.02ms DONE
    2025_10_01_163209_create_offers_table ..................... 46.77ms DONE
    2025_10_01_163110_create_categories_table ................. 40.00ms DONE
    2025_09_30_140225_create_telescope_entries_table .......... 162.68ms DONE
    0001_01_01_000002_create_jobs_table ....................... 126.48ms DONE
    0001_01_01_000001_create_cache_table ...................... 87.49ms DONE
    0001_01_01_000000_create_users_table ...................... 244.69ms DONE

   INFO  Running migrations.

   0001_01_01_000000_create_users_table ........................ 506.17ms DONE
   0001_01_01_000001_create_cache_table ........................ 127.41ms DONE
   0001_01_01_000002_create_jobs_table ......................... 325.37ms DONE
   2025_09_30_140225_create_telescope_entries_table ............ 655.89ms DONE
   2025_10_01_163110_create_categories_table ................... 126.18ms DONE
   2025_10_01_163209_create_offers_table ....................... 115.36ms DONE
   2025_10_01_163250_create_products_table ..................... 384.76ms DONE
   2025_10_02_081337_create_product_user_table ................. 217.65ms DONE

   INFO  Seeding database.

   Database\Seeders\UserSeeder ............................. RUNNING
   Database\Seeders\UserSeeder ............................. 68 ms DONE
   Database\Seeders\CategorySeeder ............................. RUNNING
   Database\Seeders\CategorySeeder ............................. 68 ms DONE
   Database\Seeders\OfferSeeder ................................ RUNNING
   Database\Seeders\OfferSeeder ................................ 38 ms DONE
   Database\Seeders\ProductSeeder .............................. RUNNING
   Database\Seeders\ProductSeeder .............................. 79 ms DONE
   Database\Seeders\ProductUserSeeder .......................... RUNNING
   Database\Seeders\ProductUserSeeder .......................... 50 ms DONE
```

## FASE 5: Actualizar los Controladores [​](#fase-5-actualizar-los-controladores)

### **1. ¿Por qué Actualizar los Controladores?** [​](#_1-¿por-que-actualizar-los-controladores)

En la Práctica 2, los controladores usaban el trait `LoadsMockData` para cargar datos desde archivos PHP. Ahora que tenemos una base de datos real con modelos Eloquent, necesitamos **eliminar completamente** el uso del trait `LoadsMockData` en los controladores y usar consultas a la base de datos.

Eliminación del Trait en Controladores

El trait `LoadsMockData` **SOLO** debe usarse en los seeders para reutilizar los datos mock. Los controladores deben usar **exclusivamente** modelos Eloquent. Elimina `use App\Traits\LoadsMockData;` y `use LoadsMockData;` de los controladores.

### **2. Actualizar ProductController** [​](#_2-actualizar-productcontroller)

El `ProductController` es el controlador más importante de nuestra tienda. Necesitamos reemplazar el uso del trait `LoadsMockData` por consultas Eloquent directas.

Abre el archivo `app/Http/Controllers/ProductController.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace App\Http\Controllers;

use App\Models\Product;
use App\Models\Category;
use App\Models\Offer;
use Illuminate\Http\Request;
use Illuminate\View\View;

class ProductController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index(): View
    {
        $products = Product::with(['category', 'offer'])->get();
        
        return view('products.index', ['products' => $products]);
    }

    /**
     * Display only products that have an active offer
     */
    public function onSale(): View
    {
        $products = Product::with(['category', 'offer'])
            ->whereNotNull('offer_id')
            ->get();
        
        return view('products.index', ['products' => $products]);
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        // En una aplicación real, aquí se mostraría un formulario para crear un nuevo producto.
        // En este ejemplo, simplemente redirigimos a la lista de productos.
        return redirect()->route('products.index')
            ->with('success', 'Formulario de creación de producto (simulado)');
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        // En una aplicación real, aquí se guardaría en la base de datos
        // Por ahora, solo redirigimos a la lista de productos
        return redirect()->route('products.index')
            ->with('success', 'Producto creado exitosamente');
    }

    /**
     * Display the specified resource.
     */
    public function show(string $id): View
    {
        // Validate ID format
        if (!is_numeric($id) || $id < 1) {
            abort(404, 'ID de producto inválido');
        }
        
        $product = Product::with(['category', 'offer'])->find($id);
        
        if (!$product) {
            abort(404, 'Producto no encontrado');
        }
        
        $category = $product->category;
        
        return view('products.show', compact('product', 'category'));
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(string $id)
    {
        // En una aplicación real, aquí se obtendrían los datos del producto correspondiente al id recibido,
        // así como las listas necesarias (por ejemplo, categorías, ofertas, etc.) para mostrarlas en un formulario de edición.
        // En este ejemplo, simplemente redirigimos al detalle del producto.
        return redirect()->route('products.show', $id)
            ->with('success', 'Producto editado');
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, string $id)
    {
        // En una aplicación real, aquí se actualizaría en la base de datos
        // Por ahora, solo redirigimos al detalle del producto
        return redirect()->route('products.show', $id)
            ->with('success', 'Producto actualizado exitosamente');
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(string $id)
    {
        // En una aplicación real, aquí se eliminaría de la base de datos
        // Por ahora, solo redirigimos a la lista de productos
        return redirect()->route('products.index')
            ->with('success', 'Producto eliminado exitosamente');
    }
}
```

Cambios Principales

* **Eliminado**: `use App\Traits\LoadsMockData;` y `use LoadsMockData;` (trait completamente removido)
* **Añadido**: `use App\Models\Product;`, `use App\Models\Category;`, `use App\Models\Offer;`
* **Reemplazado**: `$this->getProducts()` por `Product::with(['category', 'offer'])->get()`
* **Eliminado**: `$this->enrichProductsWithOffers()` (método innecesario con Eloquent)
* **Mantenido**: La misma lógica de negocio y estructura de métodos

**`with(['category', 'offer'])`**: Carga las relaciones de forma eficiente (Eager Loading) para evitar el problema N+1.

### **3. Actualizar CategoryController** [​](#_3-actualizar-categorycontroller)

El `CategoryController` gestiona las categorías de productos. Necesitamos actualizarlo para usar consultas Eloquent en lugar del trait `LoadsMockData`.

Abre el archivo `app/Http/Controllers/CategoryController.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace App\Http\Controllers;

use App\Models\Category;
use App\Models\Product;
use Illuminate\Http\Request;
use Illuminate\View\View;

class CategoryController extends Controller
{
    /**
     * Show all categories
     */
    public function index(): View
    {
        $categories = Category::all();
        
        return view('categories.index', ['categories' => $categories]);
    }

    /**
     * Show products from a specific category
     */
    public function show(string $id): View
    {
        // Validate ID format
        if (!is_numeric($id) || $id < 1) {
            abort(404, 'ID de categoría inválido');
        }
        
        $category = Category::find($id);
        
        if (!$category) {
            abort(404, 'Categoría no encontrada');
        }
        
        $categoryProducts = $category->products()->with(['offer'])->get();
        
        return view('categories.show', compact('category', 'categoryProducts'));
    }
}
```

Cambios Principales

* **Eliminado**: `use App\Traits\LoadsMockData;` y `use LoadsMockData;` (trait completamente removido)
* **Añadido**: `use App\Models\Category;`, `use App\Models\Product;`
* **Reemplazado**: `$this->getCategories()` por `Category::all()`
* **Reemplazado**: `$this->getProducts()` por `$category->products()->with(['offer'])->get()`
* **Mantenido**: La misma lógica de validación y manejo de errores

**`$category->products()`**: Utiliza la relación definida en el modelo `Category` para obtener los productos de esa categoría.

### **4. Actualizar OfferController** [​](#_4-actualizar-offercontroller)

El `OfferController` gestiona las ofertas especiales. Necesitamos actualizarlo para usar consultas Eloquent en lugar del trait `LoadsMockData`.

Abre el archivo `app/Http/Controllers/OfferController.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace App\Http\Controllers;

use App\Models\Offer;
use App\Models\Product;
use Illuminate\Http\Request;
use Illuminate\View\View;

class OfferController extends Controller
{
    /**
     * Show all offers
     */
    public function index(): View
    {
        $offers = Offer::all();
        
        return view('offers.index', ['offers' => $offers]);
    }

    /**
     * Show products with a specific offer
     */
    public function show(string $id): View
    {
        // Validate ID format
        if (!is_numeric($id) || $id < 1) {
            abort(404, 'ID de oferta inválido');
        }
        
        $offer = Offer::find($id);
        
        if (!$offer) {
            abort(404, 'Oferta no encontrada');
        }
        
        $offerProducts = $offer->products()->with(['category'])->get();
        
        return view('offers.show', compact('offer', 'offerProducts'));
    }
}
```

Cambios Principales

* **Eliminado**: `use App\Traits\LoadsMockData;` y `use LoadsMockData;` (trait completamente removido)
* **Añadido**: `use App\Models\Offer;`, `use App\Models\Product;`
* **Reemplazado**: `$this->getOffers()` por `Offer::all()`
* **Reemplazado**: `$this->getProducts()` por `$offer->products()->with(['category'])->get()`
* **Mantenido**: La misma lógica de validación y manejo de errores

**`$offer->products()`**: Utiliza la relación definida en el modelo `Offer` para obtener los productos con esa oferta.

### **5. Actualizar WelcomeController** [​](#_5-actualizar-welcomecontroller)

El `WelcomeController` gestiona la página de inicio. Necesitamos actualizarlo para usar consultas Eloquent en lugar del trait `LoadsMockData`.

Abre el archivo `app/Http/Controllers/WelcomeController.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace App\Http\Controllers;

use App\Models\Product;
use App\Models\Category;
use Illuminate\Http\Request;
use Illuminate\View\View;

class WelcomeController extends Controller
{
    /**
     * Show the welcome page with featured content
     */
    public function index(): View
    {
        // Get featured products (first 3 products with offers for the featured section)
        $featuredProducts = Product::with(['category', 'offer'])
            ->whereNotNull('offer_id')
            ->take(3)
            ->get();

        // Get featured categories (first 4 categories for the categories section)
        $featuredCategories = Category::take(4)->get();
        
        return view('welcome', compact('featuredProducts', 'featuredCategories'));
    }
}
```

Cambios Principales

* **Eliminado**: `use App\Traits\LoadsMockData;` y `use LoadsMockData;` (trait completamente removido)
* **Añadido**: `use App\Models\Product;`, `use App\Models\Category;`
* **Reemplazado**: `$this->getProducts()` por `Product::with(['category', 'offer'])->whereNotNull('offer_id')->take(3)->get()`
* **Reemplazado**: `$this->getCategories()` por `Category::take(4)->get()`
* **Mantenido**: La misma lógica de negocio para mostrar productos destacados y categorías

### **6. Actualizar CartController** [​](#_6-actualizar-cartcontroller)

El `CartController` gestiona el carrito de compras. Necesitamos actualizarlo para usar consultas Eloquent en lugar del trait `LoadsMockData`.

Abre el archivo `app/Http/Controllers/CartController.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\View\View;

class CartController extends Controller
{
    /**
     * Show cart overview
     */
    public function index(): View
    {
        // Por ahora, mostramos el carrito del primer usuario
        // En la Práctica 4 se implementará la autenticación
        $userId = 1; // Usuario por defecto
        
        $user = User::find($userId);
        $cartProducts = $user->products; // Obtiene productos con datos pivot
        
        return view('cart.index', [
            'cartProducts' => $cartProducts
        ]);
    }

    /**
     * Store a newly created cart item
     */
    public function store(Request $request)
    {
        // En una aplicación real, aquí se guardaría el producto en el carrito
        // Por ahora, solo redirigimos al carrito con un mensaje
        return redirect()->route('cart.index')
            ->with('success', 'Producto añadido al carrito exitosamente');
    }

    /**
     * Update the specified cart item
     */
    public function update(Request $request, string $id)
    {
        // En una aplicación real, aquí se actualizaría la cantidad del producto en el carrito
        // Por ahora, solo redirigimos al carrito con un mensaje
        return redirect()->route('cart.index')
            ->with('success', 'Cantidad actualizada exitosamente');
    }
}
```

Cambios Principales

* **Eliminado**: `use App\Traits\LoadsMockData;` y `use LoadsMockData;` (trait completamente removido)
* **Añadido**: `use App\Models\User;`
* **Reemplazado**: `$this->getCart()` por `$user->products` (relación N:M)
* **Simplificado**: Usa directamente la relación `belongsToMany` sin modelo intermedio
* **Mantenido**: La misma lógica de negocio y estructura de métodos

**`$user->products`**: Obtiene los productos del carrito del usuario usando la relación N:M. Los datos pivot (`quantity`) están disponibles en `$product->pivot`.

### **7. Actualizar la Ruta de Contacto** [​](#_7-actualizar-la-ruta-de-contacto)

En la Práctica 2, la ruta de contacto se definió como una función anónima. Para mantener la consistencia, vamos a crear un controlador para la página de contacto.

Crea el controlador de contacto:

bash

```
sail artisan make:controller ContactController
```

Abre el archivo `app/Http/Controllers/ContactController.php` y reemplaza su contenido:

Código PHP

php

```
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\View\View;

class ContactController extends Controller
{
    /**
     * Show the contact page
     */
    public function index(): View
    {
        return view('contact');
    }
}
```

Ahora actualiza la ruta en `routes/web.php`:

Código PHP

php

```
// Contact page
Route::get('/contact', [ContactController::class, 'index'])->name('contact');
```

Cambios en la Ruta de Contacto

* **Antes**: Función anónima `function () { return view('contact'); }`
* **Ahora**: Controlador dedicado `[ContactController::class, 'index']`
* **Ventaja**: Consistencia con el resto de controladores y facilita futuras extensiones

### **8. Limpiar el Trait LoadsMockData** [​](#_8-limpiar-el-trait-loadsmockdata)

Ahora que los controladores ya no usan el trait `LoadsMockData`, debemos limpiarlo para que solo contenga los métodos necesarios para los seeders.

Abre el archivo `app/Traits/LoadsMockData.php` y elimina los métodos innecesarios:

Código PHP actualizado

php

```
<?php

namespace App\Traits;

trait LoadsMockData
{
    /**
     * Load categories from mock file
     */
    protected function getCategories(): array
    {
        return require database_path('data/mock-categories.php');
    }

    /**
     * Load offers from mock file
     */
    protected function getOffers(): array
    {
        return require database_path('data/mock-offers.php');
    }

    /**
     * Load products from mock file
     */
    protected function getProducts(): array
    {
        return require database_path('data/mock-products.php');
    }

    /**
     * Load cart items from mock file
     */
    protected function getCart(): array
    {
        return require database_path('data/mock-cart.php');
    }
}
```

Métodos Eliminados

Se han eliminado los siguientes métodos que ya no son necesarios:

* **`enrichProductsWithOffers()`**: Ya no es necesario porque Eloquent maneja las relaciones automáticamente
* **`getAllMockData()`**: No se usa en los seeders individuales

## FASE 6: Actualizar las Vistas [​](#fase-6-actualizar-las-vistas)

### **1. ¿Por qué Actualizar las Vistas?** [​](#_1-¿por-que-actualizar-las-vistas)

En la Práctica 2, las vistas recibían arrays desde los controladores (datos mock). Ahora que los controladores usan modelos Eloquent, las vistas necesitan adaptarse para trabajar con objetos en lugar de arrays.

De Arrays a Objetos Eloquent

**Antes (Práctica 2)**:

php

```
// En el controlador
$products = $this->getProducts(); // Array
$enrichedProducts = $this->enrichProductsWithOffers($products); // ❌ Método innecesario
return view('products.index', ['products' => $enrichedProducts]);
```

html

```
<!-- En la vista -->
@foreach($products as $product)
    <h4>{{ $product['name'] }}</h4> <!-- ❌ Array access -->
    <p>€{{ $product['final_price'] }}</p> <!-- ❌ Campo calculado manualmente -->
@endforeach
```

**Ahora (Práctica 3)**:

php

```
// En el controlador
$products = Product::with(['category', 'offer'])->get(); // ✅ Collection de objetos
return view('products.index', ['products' => $products]);
```

html

```
<!-- En la vista -->
@foreach($products as $product)
    <h4>{{ $product->name }}</h4> <!-- ✅ Object property -->
    <p>€{{ $product->price }}</p> <!-- ✅ Precio directo del modelo -->
@endforeach
```

### **2. Actualizar la Vista del Carrito** [​](#_2-actualizar-la-vista-del-carrito)

La vista del carrito necesita actualizarse para trabajar con la relación N:M. Ahora `$cartProducts` contiene productos con datos pivot en lugar de un array de items.

Abre el archivo `resources/views/cart/index.blade.php` y actualiza el contenido:

Código HTML actualizado

html

```
@extends('layouts.app')

@section('content')
<div class="container mx-auto px-4 py-8">
    <h1 class="text-3xl font-bold mb-8">🛒 Carrito de Compras</h1>

    @if($cartProducts->isEmpty())
        <div class="bg-white rounded-lg shadow-lg p-8 text-center">
            <div class="text-6xl mb-4">🛒</div>
            <h2 class="text-2xl font-bold text-gray-800 mb-2">Tu carrito está vacío</h2>
            <p class="text-gray-600 mb-6">¡Añade productos para comenzar tu compra!</p>
            <a href="{{ route('products.index') }}" 
               class="inline-block bg-primary-600 text-white px-6 py-3 rounded-lg hover:bg-primary-700 transition">
                Ver Productos
            </a>
</div>
    @else
        <div class="bg-white rounded-lg shadow-lg overflow-hidden">
            <table class="w-full">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-4 text-left text-sm font-semibold text-gray-700">Producto</th>
                        <th class="px-6 py-4 text-left text-sm font-semibold text-gray-700">Precio</th>
                        <th class="px-6 py-4 text-left text-sm font-semibold text-gray-700">Cantidad</th>
                        <th class="px-6 py-4 text-left text-sm font-semibold text-gray-700">Subtotal</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-200">
                    @php
                        $total = 0;
                    @endphp
                    
                    @foreach($cartProducts as $product)
                        @php
                            $subtotal = $product->final_price * $product->pivot->quantity;
                            $total += $subtotal;
                        @endphp
                        
                        <tr class="hover:bg-gray-50">
                            <td class="px-6 py-4">
                                <div class="flex items-center">
                                    <div class="text-3xl mr-4">📦</div>
                                    <div>
                                        <div class="font-semibold text-gray-900">{{ $product->name }}</div>
                                        <div class="text-sm text-gray-600">{{ $product->category->name }}</div>
                                        @if($product->offer)
                                            <span class="inline-block bg-orange-100 text-orange-800 text-xs px-2 py-1 rounded-full mt-1">
                                                🏷️ -{{ $product->offer->discount_percentage }}%
            </span>
                                        @endif
                                    </div>
                                </div>
                            </td>
                            <td class="px-6 py-4">
                                @if($product->offer)
                                    <div>
                                        <span class="text-sm text-gray-400 line-through">€{{ number_format($product->price, 2) }}</span>
                                        <div class="font-semibold text-orange-600">€{{ number_format($product->final_price, 2) }}</div>
                                    </div>
        @else
                                    <div class="font-semibold text-gray-900">€{{ number_format($product->price, 2) }}</div>
        @endif
                            </td>
                            <td class="px-6 py-4">
                                <span class="inline-block bg-gray-100 px-3 py-1 rounded">
                                    {{ $product->pivot->quantity }}
                                </span>
                            </td>
                            <td class="px-6 py-4 font-semibold text-gray-900">
                                €{{ number_format($subtotal, 2) }}
                            </td>
                        </tr>
                    @endforeach
                </tbody>
                <tfoot class="bg-gray-50">
                    <tr>
                        <td colspan="3" class="px-6 py-4 text-right font-semibold text-gray-700">Total:</td>
                        <td class="px-6 py-4 font-bold text-xl text-primary-600">€{{ number_format($total, 2) }}</td>
                    </tr>
                </tfoot>
            </table>
        </div>

        <div class="mt-6 flex justify-between">
            <a href="{{ route('products.index') }}" 
               class="bg-gray-200 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-300 transition">
                ← Seguir Comprando
            </a>
            <button class="bg-primary-600 text-white px-6 py-3 rounded-lg hover:bg-primary-700 transition">
                Proceder al Pago →
            </button>
    </div>
@endif
</div>
@endsection
```

Cambios en la Vista del Carrito

* **`$cartProducts`**: Ahora es una Collection de productos con datos pivot
* **`$product->pivot->quantity`**: Acceso a la cantidad desde la tabla pivot
* **`$product->category->name`**: Acceso directo a la categoría relacionada
* **`$product->offer`**: Acceso directo a la oferta relacionada
* **`$product->final_price`**: Uso del accessor para obtener el precio final con descuentos aplicados automáticamente
* **Cálculo simplificado**: Solo necesitamos calcular el subtotal, el precio final ya viene del accessor

### **3. Actualizar las Clases PHP de los Componentes** [​](#_3-actualizar-las-clases-php-de-los-componentes)

Antes de actualizar las vistas de los componentes, necesitamos actualizar sus **clases PHP** para que acepten objetos Eloquent en lugar de arrays.

#### **3.1. Actualizar la Clase ProductCard** [​](#_3-1-actualizar-la-clase-productcard)

Abre el archivo `app/View/Components/ProductCard.php` y actualiza el tipo de dato:

Código PHP actualizado

php

```
<?php

namespace App\View\Components;

use App\Models\Product;
use Closure;
use Illuminate\Contracts\View\View;
use Illuminate\View\Component;

class ProductCard extends Component
{
    /**
     * Create a new component instance.
     */
    public function __construct(
        public Product $product,
        public string $class = ''
    ) {}

    /**
     * Get the view / contents that represent the component.
     */
    public function render(): View|Closure|string
    {
        return view('components.product-card');
    }
}
```

Cambio Importante

* **Antes**: `public array $product`
* **Ahora**: `public Product $product`
* Se importa el modelo: `use App\Models\Product;`

#### **3.2. Actualizar la Clase CategoryCard** [​](#_3-2-actualizar-la-clase-categorycard)

Abre el archivo `app/View/Components/CategoryCard.php` y actualiza el tipo de dato:

Código PHP actualizado

php

```
<?php

namespace App\View\Components;

use App\Models\Category;
use Closure;
use Illuminate\Contracts\View\View;
use Illuminate\View\Component;

class CategoryCard extends Component
{
    /**
     * Create a new component instance.
     */
    public function __construct(
        public Category $category,
        public string $class = ''
    ) {}

    /**
     * Get the view / contents that represent the component.
     */
    public function render(): View|Closure|string
    {
        return view('components.category-card');
    }
}
```

Cambio Importante

* **Antes**: `public array $category`
* **Ahora**: `public Category $category`
* Se importa el modelo: `use App\Models\Category;`

### **4. Actualizar las Vistas Blade de los Componentes** [​](#_4-actualizar-las-vistas-blade-de-los-componentes)

Ahora que las clases PHP están actualizadas, podemos actualizar las vistas Blade.

#### **4.1. Actualizar la Vista del Componente CategoryCard** [​](#_4-1-actualizar-la-vista-del-componente-categorycard)

El componente `CategoryCard` necesita actualizarse para trabajar con objetos Eloquent en lugar de arrays.

Abre el archivo `resources/views/components/category-card.blade.php` y actualiza el contenido:

Código HTML actualizado

html

```
<div class="bg-white rounded-lg shadow-lg p-6 product-card cursor-pointer {{ $class }}">
    <div class="text-4xl text-primary-500 mb-4">📦</div>
    <h4 class="text-xl font-bold mb-2 text-gray-900">{{ $category->name }}</h4>
    <p class="text-gray-600 mb-4">{{ $category->description }}</p>
    <a href="{{ route('categories.show', $category->id) }}" 
       class="text-primary-600 font-semibold hover:text-primary-700 transition">
        Ver Productos →
    </a>
</div>
```

Cambios en CategoryCard

* **`$category['name']`** → **`$category->name`**: Acceso a propiedades del objeto
* **`$category['description']`** → **`$category->description`**: Propiedad del modelo
* **`$category['id']`** → **`$category->id`**: ID del modelo Eloquent

#### **4.2. Actualizar la Vista del Componente ProductCard** [​](#_4-2-actualizar-la-vista-del-componente-productcard)

El componente `ProductCard` es el más importante ya que se usa en múltiples vistas. Necesitamos actualizarlo para trabajar con objetos Eloquent.

Abre el archivo `resources/views/components/product-card.blade.php` y actualiza las secciones que usan datos:

Código HTML actualizado

html

```
<div class="bg-white rounded-lg shadow-lg overflow-hidden product-card {{ $class }} relative {{ $product->offer ? 'ring-2 ring-orange-400' : '' }}">
    <!-- Badge de oferta destacado (esquina superior derecha) -->
    @if($product->offer)
        <div class="absolute top-0 right-0 bg-gradient-to-r from-orange-500 to-red-500 text-white px-4 py-2 rounded-bl-lg font-bold shadow-lg z-10">
            <span class="text-lg">
                -{{ $product->offer->discount_percentage }}%
            </span>
    </div>
    @endif
    
    <div class="h-48 bg-gray-200 flex items-center justify-center {{ $product->offer ? 'bg-gradient-to-br from-orange-50 to-red-50' : '' }}">
        <span class="text-4xl">📦</span>
</div>
    <div class="p-6">
        <h4 class="text-xl font-bold mb-2 text-gray-900">{{ $product->name }}</h4>
        <p class="text-gray-600 mb-4">{{ $product->description }}</p>
        
        <!-- Badge de oferta adicional (nombre de la oferta) -->
        @if($product->offer)
            <div class="mb-4">
                <span class="inline-block bg-orange-100 text-orange-800 text-xs px-3 py-1 rounded-full font-semibold">
                    🏷️ {{ $product->offer->name }}
                </span>
            </div>
        @endif
        
        <div class="flex items-center justify-between flex-wrap gap-2">
            <div class="flex flex-col">
                @if($product->offer)
                    <span class="text-sm text-gray-400 line-through">€{{ number_format($product->price, 2) }}</span>
                    <span class="text-2xl font-bold text-orange-600">€{{ number_format($product->final_price, 2) }}</span>
                @else
                    <span class="text-2xl font-bold text-primary-600">€{{ number_format($product->price, 2) }}</span>
                @endif
            </div>
            <a href="{{ route('products.show', $product->id) }}" 
               class="bg-primary-600 text-white px-4 py-2 rounded-lg hover:bg-primary-700 transition">
                Ver Detalles
            </a>
        </div>
    </div>
</div>
```

Cambios Principales

* **`$product['name']`** → **`$product->name`**: Acceso a propiedades de objeto
* **`$product['offer']`** → **`$product->offer`**: Acceso a relación Eloquent
* **`$product['offer']['discount_percentage']`** → **`$product->offer->discount_percentage`**: Acceso anidado
* **`$product->final_price`**: Uso del accessor para obtener el precio final con descuentos automáticamente
* **Código más limpio**: Eliminado el bloque `@php` para cálculo de descuentos
* **Mantenido**: La misma lógica visual y estructura del componente

### **5. Actualizar la Vista de Detalle de Producto** [​](#_5-actualizar-la-vista-de-detalle-de-producto)

Esta vista muestra la información completa de un producto y necesita usar objetos Eloquent para acceder a las relaciones.

Abre el archivo `resources/views/products/show.blade.php` y actualiza el contenido:

Código HTML actualizado

html

```
@extends('layouts.app')

@section('title', $product->name . ' - Mi Tienda')

@section('content')
    <div class="container mx-auto px-6 py-8">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Imagen del Producto -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <div class="h-96 bg-gray-200 flex items-center justify-center">
                    <span class="text-8xl">📦</span>
                </div>
            </div>

            <!-- Información del Producto -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h1 class="text-3xl font-bold text-gray-900 mb-4">{{ $product->name }}</h1>
                <p class="text-gray-600 mb-6">{{ $product->description }}</p>
            
                <!-- Precio -->
                <div class="mb-6">
                    @if($product->offer)
                        <div class="flex items-baseline gap-3">
                            <span class="text-2xl text-gray-400 line-through">€{{ number_format($product->price, 2) }}</span>
                            <span class="text-4xl font-bold text-orange-600">€{{ number_format($product->final_price, 2) }}</span>
                        </div>
                        <p class="text-sm text-orange-600 mt-2">
                            ¡Ahorra €{{ number_format($product->price - $product->final_price, 2) }}!
                        </p>
                @else
                        <span class="text-4xl font-bold text-primary-600">€{{ number_format($product->price, 2) }}</span>
                @endif
            </div>
            
                <!-- Categoría -->
                @if($product->category)
                    <div class="mb-6">
                        <span class="text-sm text-gray-500">Categoría:</span>
                        <a href="{{ route('categories.show', $product->category->id) }}" 
                           class="ml-2 bg-primary-100 text-primary-800 px-3 py-1 rounded-full text-sm hover:bg-primary-200 transition">
                            {{ $product->category->name }}
                        </a>
                    </div>
                @endif
            
                <!-- Oferta -->
                @if($product->offer)
                    <div class="mb-6">
                        <span class="text-sm text-gray-500">Oferta activa:</span>
                        <div class="mt-2">
                            <span class="inline-block bg-orange-100 text-orange-800 text-sm px-3 py-1 rounded-full">
                                🏷️ {{ $product->offer->name }} (-{{ $product->offer->discount_percentage }}%)
                            </span>
        </div>
    </div>
@endif

                <!-- Botones de Acción -->
<div class="flex space-x-4">
                    <a href="{{ route('cart.store') }}" 
                       class="bg-primary-600 text-white px-6 py-3 rounded-lg hover:bg-primary-700 transition">
            🛒 Añadir al Carrito
                    </a>
                    <a href="{{ route('products.index') }}" 
                       class="border border-primary-600 text-primary-600 px-6 py-3 rounded-lg hover:bg-primary-50 transition">
                        ← Volver a Productos
                    </a>
                </div>
            </div>
        </div>
    </div>
@endsection
```

Cambios en la Vista de Detalle de Producto

* **`$product->name`**: Acceso directo a las propiedades del modelo
* **`$product->offer`**: Relación cargada con eager loading
* **`$product->category`**: Relación con la categoría
* **`$product->final_price`**: Uso del accessor para obtener el precio final automáticamente
* **`@if($product->offer)`**: Verifica si existe la relación (no si es `!== null`)

### **6. Actualizar la Vista de Productos por Categoría** [​](#_6-actualizar-la-vista-de-productos-por-categoria)

Esta vista muestra todos los productos de una categoría específica.

Abre el archivo `resources/views/categories/show.blade.php` y actualiza el contenido:

Código HTML actualizado

html

```
@extends('layouts.app')

@section('title', $category->name . ' - Mi Tienda')

@section('content')
    <div class="container mx-auto px-6 py-8">
        <div class="mb-8">
            <h1 class="text-3xl font-bold text-gray-900 mb-4">{{ $category->name }}</h1>
            <p class="text-gray-600 mb-4">{{ $category->description }}</p>
            <a href="{{ route('categories.index') }}" 
               class="text-primary-600 hover:text-primary-700 transition">
                ← Volver a Categorías
            </a>
        </div>

        @if($categoryProducts->isNotEmpty())
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                @foreach($categoryProducts as $product)
                    <x-product-card :product="$product" />
                @endforeach
            </div>
    @else
            <div class="text-center py-12">
                <p class="text-gray-500 text-lg">No hay productos en esta categoría.</p>
            </div>
    @endif
</div>
@endsection
```

Cambios en la Vista de Categoría

* **`$category->name`**: Propiedad del modelo Eloquent
* **`$category->description`**: Descripción de la categoría
* **`$categoryProducts->isNotEmpty()`**: Método de Collection en lugar de `!empty()`
* Los productos se pasan directamente al componente `ProductCard`

### **7. Actualizar la Vista de Lista de Ofertas** [​](#_7-actualizar-la-vista-de-lista-de-ofertas)

Esta vista muestra todas las ofertas disponibles en la tienda.

Abre el archivo `resources/views/offers/index.blade.php` y actualiza el contenido:

Código HTML actualizado

html

```
@extends('layouts.app')

@section('title', 'Ofertas - Mi Tienda')

@section('content')
    <div class="container mx-auto px-6 py-8">
        <div class="mb-8">
            <h1 class="text-3xl font-bold text-gray-900 mb-4">Ofertas Especiales</h1>
            <p class="text-gray-600">Descubre nuestras mejores ofertas y descuentos.</p>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            @forelse($offers as $offer)
                <div class="bg-white rounded-lg shadow-lg p-6 border-l-4 border-orange-500">
                    <h3 class="text-xl font-bold text-gray-900 mb-2">{{ $offer->name }}</h3>
                    <p class="text-gray-600 mb-4">{{ $offer->description }}</p>
                    <div class="text-2xl font-bold text-orange-600 mb-4">
                        {{ $offer->discount_percentage }}% de descuento
                    </div>
                    <a href="{{ route('offers.show', $offer->id) }}" 
                       class="bg-orange-600 text-white px-4 py-2 rounded-lg hover:bg-orange-700 transition">
                        Ver Productos
                    </a>
                </div>
            @empty
                <div class="col-span-full text-center py-12">
                    <p class="text-gray-500 text-lg">No hay ofertas disponibles.</p>
                </div>
            @endforelse
        </div>
    </div>
@endsection
```

Cambios en la Vista de Ofertas

* **`$offer->name`**: Propiedad del modelo Offer
* **`$offer->description`**: Descripción de la oferta
* **`$offer->discount_percentage`**: Porcentaje de descuento
* **`$offer->id`**: ID del modelo para la ruta

### **8. Actualizar la Vista de Detalle de Oferta** [​](#_8-actualizar-la-vista-de-detalle-de-oferta)

Esta vista muestra los detalles de una oferta específica y todos los productos que tienen aplicada esa oferta.

Abre el archivo `resources/views/offers/show.blade.php` y actualiza el contenido:

Código HTML actualizado

html

```
@extends('layouts.app')

@section('title', $offer->name . ' - Mi Tienda')

@section('content')
    <div class="container mx-auto px-6 py-8">
        <!-- Header de la Oferta -->
        <div class="bg-gradient-to-r from-orange-500 to-red-500 rounded-lg shadow-lg p-8 mb-8 text-white">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-4xl font-bold mb-2">{{ $offer->name }}</h1>
                    <p class="text-xl">{{ $offer->description }}</p>
                </div>
                <div class="bg-white text-orange-600 rounded-full w-32 h-32 flex items-center justify-center">
                    <div class="text-center">
                        <div class="text-4xl font-bold">{{ $offer->discount_percentage }}%</div>
                        <div class="text-sm">OFF</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Productos con esta oferta -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-900 mb-6">Productos en Oferta</h2>
            
            @if($offerProducts->isNotEmpty())
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    @foreach($offerProducts as $product)
                        <x-product-card :product="$product" />
                    @endforeach
                </div>
            @else
                <div class="text-center py-12 bg-gray-100 rounded-lg">
                    <p class="text-gray-500 text-lg">No hay productos con esta oferta actualmente.</p>
                </div>
            @endif
        </div>

        <!-- Botón volver -->
        <div class="mt-8">
            <a href="{{ route('offers.index') }}" 
               class="inline-block bg-gray-600 text-white px-6 py-3 rounded-lg hover:bg-gray-700 transition">
                ← Volver a Ofertas
            </a>
        </div>
    </div>
@endsection
```

Cambios en la Vista de Detalle de Oferta

* **`$offer->name`**: Nombre de la oferta desde el modelo
* **`$offer->description`**: Descripción de la oferta
* **`$offer->discount_percentage`**: Porcentaje de descuento
* **`$offerProducts->isNotEmpty()`**: Método de Collection en lugar de `!empty()`
* Los productos se pasan al componente `ProductCard` que ya está actualizado

## FASE 7: Probar la Aplicación [​](#fase-7-probar-la-aplicacion)

### **1. Verificar que la Base de Datos Esté Poblada** [​](#_1-verificar-que-la-base-de-datos-este-poblada)

Antes de probar la aplicación en el navegador, es importante verificar que los seeders se ejecutaron correctamente y que la base de datos contiene los datos esperados.

Laravel Tinker es una herramienta interactiva que permite ejecutar código PHP directamente en el contexto de la aplicación, ideal para probar consultas y verificar datos.

Ejecuta el siguiente comando para abrir Tinker:

bash

```
sail artisan tinker
```

En Tinker, ejecuta los siguientes comandos para verificar que los datos se insertaron correctamente:

* Verificar cantidad de registros en cada tabla:

php

```
        App\Models\User::count()
App\Models\Category::count()
        App\Models\Offer::count()
        App\Models\Product::count()
```

Ejemplo de respuesta en Tinker

php

```
> App\Models\User::count()
= 3

> App\Models\Category::count()
= 5

> App\Models\Offer::count()
= 3

> App\Models\Product::count()
= 6
```

* Verificar que las relaciones funcionan

  **Producto con categoria y oferta:**

php

```
$product = App\Models\Product::with(['category', 'offer'])->first();
```

Ejemplo de respuesta en Tinker

php

```
> $product = App\Models\Product::with(['category', 'offer'])->first();
= App\Models\Product {#6158ducts')->first();
    id: 1,
    name: "Producto 1",
    description: "Descripci<C3><B3>n del producto 1",
    price: "29.99",
    category_id: 1,
    offer_id: 1,
    created_at: "2025-10-02 08:54:44",
    updated_at: "2025-10-02 08:54:44",
    category: App\Models\Category {#6192
        id: 1,
        name: "Categor<C3><AD>a 1",
        slug: "categoria-1",
        description: "Descripci<C3><B3>n de la categor<C3><AD>a 1",
        created_at: "2025-10-02 08:54:44",
        updated_at: "2025-10-02 08:54:44",
    },
    offer: App\Models\Offer {#6161
        id: 1,
        name: "Oferta 1",
        slug: "oferta-1",
        discount_percentage: 20,
        description: "Descuento especial del 20%",
        created_at: "2025-10-02 08:54:44",
        updated_at: "2025-10-02 08:54:44",
    },
}
```

**Usuario con producto:**

php

```
$user = App\Models\User::with('products')->first();
```

Ejemplo de respuesta en Tinker

php

```
> $user = App\Models\User::with('products')->first();
= App\Models\User {#6770
    id: 1,
    name: "Usuario Demo",
    email: "demo@example.com",
    email_verified_at: "2025-10-02 08:54:43",
    #password: "$2y$12$eXBoAA87wjdZ2sny/PWTkeOor2Z/SvbYbzIiGepRvXKALWs0cvngu",
    #remember_token: "EdO89iK9Jq",
    created_at: "2025-10-02 08:54:44",
    updated_at: "2025-10-02 08:54:44",
    products: Illuminate\Database\Eloquent\Collection {#6788
    all: [
        App\Models\Product {#6750
        id: 1,
        name: "Producto 1",
        description: "Descripci<C3><B3>n del producto 1",
        price: "29.99",
        category_id: 1,
        offer_id: 1,
        created_at: "2025-10-02 08:54:44",
        updated_at: "2025-10-02 08:54:44",
        pivot: Illuminate\Database\Eloquent\Relations\Pivot {#6742
            user_id: 1,
            product_id: 1,
            quantity: 2,
            added_at: "2025-01-15 10:30:00",
            created_at: "2025-10-02 08:54:44",
            updated_at: "2025-10-02 08:54:44",
        },
        },
        App\Models\Product {#6763
        id: 3,
        name: "Producto 3",
        description: "Descripci<C3><B3>n del producto 3",
        price: "19.99",
        category_id: 2,
        offer_id: 2,
        created_at: "2025-10-02 08:54:44",
        updated_at: "2025-10-02 08:54:44",
        pivot: Illuminate\Database\Eloquent\Relations\Pivot {#6792
            user_id: 1,
            product_id: 3,
            quantity: 1,
            added_at: "2025-01-15 11:15:00",
            created_at: "2025-10-02 08:54:44",
            updated_at: "2025-10-02 08:54:44",
        },
        },
        App\Models\Product {#6752
        id: 5,
        name: "Producto 5",
        description: "Descripci<C3><B3>n del producto 5",
        price: "34.99",
        category_id: 3,
        offer_id: 3,
        created_at: "2025-10-02 08:54:44",
        updated_at: "2025-10-02 08:54:44",
        pivot: Illuminate\Database\Eloquent\Relations\Pivot {#6793
            user_id: 1,
            product_id: 5,
            quantity: 3,
            added_at: "2025-01-15 12:00:00",
            created_at: "2025-10-02 08:54:44",
            updated_at: "2025-10-02 08:54:44",
        },
        },
        App\Models\Product {#6755
        id: 2,
        name: "Producto 2",
        description: "Descripci<C3><B3>n del producto 2",
        price: "39.99",
        category_id: 1,
        offer_id: null,
        created_at: "2025-10-02 08:54:44",
        updated_at: "2025-10-02 08:54:44",
        pivot: Illuminate\Database\Eloquent\Relations\Pivot {#6791
            user_id: 1,
            product_id: 2,
            quantity: 1,
            added_at: "2025-01-15 14:30:00",
            created_at: "2025-10-02 08:54:44",
            updated_at: "2025-10-02 08:54:44",
        },
        },
    ],
    },
}
(END)
```

Nota

Cuando ejecutas comandos o consultas largas en la consola de Tinker, a veces no se muestra todo el contenido de inmediato. Si ves el símbolo `:`, significa que hay más contenido por mostrar. Pulsa `Enter` para seguir viendo el resto hasta llegar a la etiqueta `(END)`, que indica que ya se mostró todo.

Para salir de la visualización y volver a la línea de comandos de Tinker, simplemente pulsa la tecla `q`.

* Verificar los datos de un producto y carrito del usuario:

php

```
$product->name
$product->category->name
$product->offer ? $product->offer->name : 'Sin oferta'
$user->name
$user->products->first()->name
$user->products->first()->pivot->quantity
```

Ejemplo de respuesta en Tinker

php

```
> $product->name
= "Producto 1"

> $product->category->name
= "Categoría 1"

> $product->offer ? $product->offer->name : 'Sin oferta'
= "Oferta 1"

> $user->name
= "Usuario Demo"

> $user->products->first()->name
= "Producto 1"

> $user->products->first()->pivot->quantity
= 2
```

* Verificar la relación N:M completa:

php

```
foreach ($user->products as $product) {
    echo $product->name . " - Cantidad: " . $product->pivot->quantity . "\n";
}
```

Ejemplo de respuesta en Tinker

php

```
> foreach ($user->products as $product) {
    echo $product->name . " - Cantidad: " . $product->pivot->quantity . "\n";
}
Producto 1 - Cantidad: 2
Producto 2 - Cantidad: 1
Producto 3 - Cantidad: 3
```

### **2. Probar las Rutas en el Navegador** [​](#_2-probar-las-rutas-en-el-navegador)

Ahora que hemos verificado que la base de datos está poblada correctamente, es el momento de probar la aplicación en el navegador para asegurarnos de que todo funciona como se espera.

Visita las siguientes URLs y verifica que cada página carga correctamente:

* **Página de inicio**: `http://localhost` (WelcomeController)
* **Lista de productos**: `http://localhost/products`
* **Productos en oferta**: `http://localhost/products-on-sale`
* **Producto específico**: `http://localhost/products/1`
* **Lista de categorías**: `http://localhost/categories`
* **Categoría específica**: `http://localhost/categories/1`
* **Lista de ofertas**: `http://localhost/offers`
* **Oferta específica**: `http://localhost/offers/1`
* **Carrito**: `http://localhost/cart`
* **Contacto**: `http://localhost/contact` (ContactController)

## FASE 8: Introducción a Operaciones CRUD [​](#fase-8-introduccion-a-operaciones-crud)

### **1. ¿Qué son las Operaciones CRUD?** [​](#_1-¿que-son-las-operaciones-crud)

CRUD es un acrónimo que significa **Create, Read, Update, Delete** (Crear, Leer, Actualizar, Eliminar). Estas son las operaciones básicas que se pueden realizar sobre cualquier entidad en una aplicación.

Hasta ahora, en esta práctica solo hemos implementado la operación **Read** (leer datos) en los controladores. Las operaciones de escritura (Create, Update, Delete) se pueden probar usando Tinker.

### **2. Probar Operaciones CRUD con Tinker** [​](#_2-probar-operaciones-crud-con-tinker)

Aunque no implementaremos formularios en esta práctica, puedes probar todas las operaciones CRUD usando Tinker:

bash

```
sail artisan tinker
```

Ejemplos de operaciones CRUD en Tinker

**Crear un producto (Create)**:

php

```
$product = App\Models\Product::create([
    'name' => 'Producto de Prueba',
    'description' => 'Descripción del producto de prueba',
    'price' => 99.99,
    'category_id' => 1,
    'offer_id' => null
]);

echo "Producto creado con ID: " . $product->id;
```

**Leer productos (Read)**:

php

```
// Obtener todos los productos
$products = App\Models\Product::all();

// Obtener un producto específico
$product = App\Models\Product::find(1);
echo $product->name;

// Obtener productos con relaciones
$product = App\Models\Product::with(['category', 'offer'])->first();
echo $product->category->name;
```

**Actualizar un producto (Update)**:

php

```
$product = App\Models\Product::find(1);
$product->update([
    'price' => 89.99,
    'description' => 'Nueva descripción actualizada'
]);

echo "Precio actualizado: €" . $product->price;
```

**Eliminar un producto (Delete)**:

php

```
$product = App\Models\Product::find(1);
$product->delete();

echo "Producto eliminado";
```

Verificar las Operaciones

Después de cada operación, puedes verificar los cambios en la base de datos:

php

```
App\Models\Product::count()  // Ver total de productos
App\Models\Product::find(1)  // Verificar si existe
```

### **3. Eliminación en Cascada** [​](#_3-eliminacion-en-cascada)

Gracias a las claves foráneas definidas en las migraciones con `->onDelete('cascade')`, cuando eliminas una entidad, se eliminan automáticamente las entidades relacionadas:

Ejemplos de eliminación en cascada

php

```
// Si eliminas una categoría, se eliminan todos sus productos
$category = App\Models\Category::find(1);
$category->delete(); // Elimina la categoría y todos sus productos

// Si eliminas un producto, se eliminan sus relaciones en el carrito
$product = App\Models\Product::find(1);
$product->delete(); // Elimina el producto y sus entradas en product_user

// Si eliminas una oferta, los productos quedan sin oferta (set null)
$offer = App\Models\Offer::find(1);
$offer->delete(); // Los productos quedan con offer_id = null
```

Cuidado con las Eliminaciones

La eliminación en cascada es potente pero peligrosa:

* Eliminar una categoría borra TODOS sus productos
* Eliminar un usuario borra TODOS los items de su carrito
* Siempre verifica las relaciones antes de eliminar

## 📋 ENTREGA DE LA PRÁCTICA [​](#📋-entrega-de-la-practica)

### **Requisitos de Entrega** [​](#requisitos-de-entrega)

Para completar esta práctica, debes entregar un **PDF** que incluya las siguientes **13 capturas de pantalla numeradas**:

---

#### **Captura 1: Migraciones y Seeders Ejecutados** [​](#captura-1-migraciones-y-seeders-ejecutados)

Ejecuta el comando para refrescar la base de datos y poblarla:

bash

```
sail artisan migrate:refresh --seed
```

**Requisitos**:

* Terminal mostrando la ejecución completa del comando
* Todas las migraciones siendo revertidas y ejecutadas
* Todos los seeders ejecutándose (UserSeeder, CategorySeeder, OfferSeeder, ProductSeeder, ProductUserSeeder)
* Prompt del terminal `usuario@equipo:~/ruta/proyecto$` visible

---

#### **Captura 2: Verificación de Datos en Tinker** [​](#captura-2-verificacion-de-datos-en-tinker)

Abre Tinker y verifica los datos:

bash

```
sail artisan tinker
```

Ejecuta los siguientes comandos:

php

```
App\Models\User::count()
App\Models\Category::count()
App\Models\Offer::count()
App\Models\Product::count()
```

**Requisitos**:

* Terminal mostrando Tinker abierto
* Los 4 comandos ejecutados con sus resultados
* Cantidades > 0 en todas las tablas
* Prompt visible

---

#### **Captura 3: Página de Inicio con Datos Reales** [​](#captura-3-pagina-de-inicio-con-datos-reales)

Visita `http://localhost` en tu navegador.

**Requisitos**:

* Página de bienvenida funcionando
* Productos destacados con datos de la base de datos
* Categorías destacadas visibles
* Productos con ofertas mostrando badges naranjas y descuentos
* URL visible en la barra del navegador

---

#### **Captura 4: Lista de Todos los Productos** [​](#captura-4-lista-de-todos-los-productos)

Visita `http://localhost/products` en tu navegador.

**Requisitos**:

* Todos los productos de tu tienda
* Productos con oferta mostrando badge de descuento
* Precios originales y con descuento visibles
* Datos adaptados a tu temática elegida
* URL `http://localhost/products` visible

---

#### **Captura 5: Productos en Oferta** [​](#captura-5-productos-en-oferta)

Visita `http://localhost/products-on-sale` en tu navegador.

**Requisitos**:

* **Solo** productos que tienen oferta activa
* Todos los productos con badge naranja de descuento
* Precios tachados y precios finales en naranja
* URL `http://localhost/products-on-sale` visible

---

#### **Captura 6: Detalle de un Producto** [​](#captura-6-detalle-de-un-producto)

Visita `http://localhost/products/1` (o cualquier ID válido) en tu navegador.

**Requisitos**:

* Información completa del producto
* Categoría del producto visible y enlazada
* Si tiene oferta, mostrar información completa de la oferta
* Precios correctos (con o sin descuento)
* URL `http://localhost/products/X` visible

---

#### **Captura 7: Productos por Categoría** [​](#captura-7-productos-por-categoria)

Visita `http://localhost/categories/1` (o cualquier ID válido) en tu navegador.

**Requisitos**:

* Nombre y descripción de la categoría
* Solo productos de esa categoría
* Productos con ofertas mostrando descuentos
* Enlace "Volver a Categorías" visible
* URL `http://localhost/categories/X` visible

---

#### **Captura 8: Lista de Ofertas** [​](#captura-8-lista-de-ofertas)

Visita `http://localhost/offers` en tu navegador.

**Requisitos**:

* Todas las ofertas disponibles
* Nombre, descripción y porcentaje de descuento de cada oferta
* Enlaces "Ver Productos" visibles
* URL `http://localhost/offers` visible

---

#### **Captura 9: Detalle de una Oferta** [​](#captura-9-detalle-de-una-oferta)

Visita `http://localhost/offers/1` (o cualquier ID válido) en tu navegador.

**Requisitos**:

* Header destacado con el porcentaje de descuento
* Productos que tienen esa oferta aplicada
* Información de la oferta visible
* URL `http://localhost/offers/X` visible

---

#### **Captura 10: Carrito de Compras** [​](#captura-10-carrito-de-compras)

Visita `http://localhost/cart` en tu navegador.

**Requisitos**:

* Items del carrito desde la base de datos (tabla `product_user`)
* Información de cada producto (nombre, categoría, precio, cantidad)
* Productos con oferta mostrando descuento aplicado
* Subtotales y total calculados correctamente
* URL `http://localhost/cart` visible

---

#### **Captura 11: Verificación de Relaciones en Tinker** [​](#captura-11-verificacion-de-relaciones-en-tinker)

En Tinker, ejecuta:

php

```
$product = App\Models\Product::with(['category', 'offer'])->first();
$product->name
$product->category->name
$product->offer ? $product->offer->name : 'Sin oferta'
```

**Requisitos**:

* Terminal con Tinker mostrando los comandos ejecutados
* Relaciones funcionando correctamente (sin errores)
* Acceso a `$product->category->name` exitoso
* Verificación de oferta funcionando

---

#### **Captura 12: Verificación de Relación N:M del Carrito** [​](#captura-12-verificacion-de-relacion-n-m-del-carrito)

En Tinker, ejecuta:

php

```
$user = App\Models\User::first();
$user->products->count()
$product = $user->products->first();
$product->pivot->quantity
```

**Requisitos**:

* Terminal con Tinker mostrando los comandos ejecutados
* Relación N:M funcionando (`$user->products`)
* Acceso a datos pivot exitoso (`$product->pivot->quantity`)
* Sin errores

---

#### **Captura 13: Operación CRUD - Crear Producto en Tinker** [​](#captura-13-operacion-crud-crear-producto-en-tinker)

En Tinker, crea un nuevo producto:

php

```
$product = App\Models\Product::create([
    'name' => 'Producto de Prueba CRUD',
    'description' => 'Este producto fue creado para probar CRUD',
    'price' => 49.99,
    'category_id' => 1,
    'offer_id' => null
]);

echo "Producto creado con ID: " . $product->id;
App\Models\Product::count()
```

**Requisitos**:

* Terminal mostrando la creación del producto
* ID del producto creado visible
* Contador de productos incrementado
* Sin errores

### **📤 Instrucciones de Entrega** [​](#📤-instrucciones-de-entrega)

1. **Formato**: Entregar un único archivo PDF con todas las capturas
2. **Organización**: Incluir un título para cada captura explicando qué muestra
3. **Calidad**: Las capturas deben ser claras y legibles
4. **Funcionalidad**: Todas las rutas deben funcionar con la base de datos real
5. **Relaciones**: Verificar que las relaciones entre modelos funcionen correctamente
6. **Terminal**: Todas las capturas deben incluir el prompt del terminal visible
7. **Datos personalizados**: Los productos, categorías y ofertas deben estar adaptados a tu temática específica

### **🔗 Plataforma de Entrega** [​](#🔗-plataforma-de-entrega)

**Entrega en Aules**

Pager

[Anterior5. Seeders y Factories](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/5-seeders-factories.html)

![Autor](/25-26-introduccion-laravel/img/logo-autor.png)

Copyright © 2025