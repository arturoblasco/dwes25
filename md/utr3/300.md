Gestión de Datos con Laravel | Introducción a Laravel


# Gestión de Datos 

Información del curso

**Autores:** Guillermo Garrido

**Año:** 2025

**Centro:** CEFIRE

![Logo CC](/25-26-introduccion-laravel/img/logo-centro.png)

Síntesis de la sesión

En esta sesión se explora la gestión de datos con Laravel, dominando las herramientas más importantes del framework para trabajar con bases de datos de manera profesional. Se aprende a diseñar y gestionar la estructura de la base de datos como código a través de **Migraciones**. Se domina **Eloquent ORM**, el sistema de mapeo objeto-relacional de Laravel, realizando operaciones CRUD (Crear, Leer, Actualizar, Borrar) de manera intuitiva. Se exploran **Seeders** y **Factories** para poblar la base de datos con datos de prueba de forma automatizada. El objetivo es diseñar esquemas de base de datos escalables e interactuar con los datos de manera elegante.

## Contenidos de la Sesión 3

* **1. Migraciones y Estructura de Base de Datos** Se estudian los conceptos fundamentales de las bases de datos relacionales y el sistema de migraciones de Laravel. Se aprende a crear, modificar y eliminar tablas y columnas como código, diseñando esquemas eficientes con relaciones apropiadas.
* **2. Introducción a Eloquent ORM** Se descubre Eloquent, el ORM de Laravel, aprendiendo cómo los modelos representan las tablas de la base de datos y facilitan la interacción con los datos de manera orientada a objetos.
* **3. Operaciones CRUD con Eloquent** Se dominan las operaciones básicas de base de datos: Crear, Leer, Actualizar y Borrar registros usando métodos intuitivos de Eloquent, aprendiendo mejores prácticas y optimizaciones.
* **4. Relaciones en Eloquent** Se implementan relaciones entre modelos (uno a uno, uno a muchos, muchos a muchos), aprendiendo a navegar entre datos relacionados de manera elegante y eficiente.
* **5. Seeders y Factories** Se crean seeders para poblar la base de datos con datos iniciales y se utilizan factories para generar datos de prueba realistas de forma automatizada, facilitando el desarrollo.
* **Diapositivas** Presentación completa de todos los conceptos de la sesión con diagramas, analogías y ejemplos visuales de la gestión de datos con Laravel.

## Objetivos de la Sesión 3

Acceso Rápido a los Objetivos

* **Objetivo 1**: Comprender los conceptos fundamentales de las bases de datos relacionales y dominar el sistema de migraciones de Laravel para gestionar la estructura como código versionado.
* **Objetivo 2**: Dominar Eloquent ORM, comprendiendo cómo los modelos representan las tablas y facilitan la interacción con los datos.
* **Objetivo 3**: Realizar operaciones CRUD completas con Eloquent, aplicando mejores prácticas y optimizaciones de rendimiento.
* **Objetivo 4**: Implementar relaciones entre modelos Eloquent, navegando entre datos relacionados de manera eficiente.
* **Objetivo 5**: Crear seeders y utilizar factories para poblar la base de datos con datos iniciales y de prueba realistas de forma automatizada.

---

| Objetivos de la Sesión 3 | Objetivos Generales del Curso |
| --- | --- |
| **Objetivo 1**: Comprender bases de datos y migraciones | **Objetivo General 2** |
| **Objetivo 2**: Dominar Eloquent ORM | **Objetivo General 2** |
| **Objetivo 3**: Realizar operaciones CRUD | **Objetivo General 2** |
| **Objetivo 4**: Implementar relaciones | **Objetivo General 2** |
| **Objetivo 5**: Crear seeders y factories | **Objetivo General 2** |

## Recursos Adicionales [​](#recursos-adicionales)

Enlaces de interés

### Documentación Oficial

* [Laravel 12.x Documentation](https://laravel.com/docs/12.x) - Documentación oficial completa
* [Laravel Migrations](https://laravel.com/docs/12.x/migrations) - Guía oficial de migraciones
* [Laravel Eloquent ORM](https://laravel.com/docs/12.x/eloquent) - Documentación oficial de Eloquent
* [Laravel Database Seeders](https://laravel.com/docs/12.x/seeding) - Guía oficial de seeders

### Fundamentos de Base de Datos

* [MySQL Documentation](https://dev.mysql.com/doc/) - Documentación oficial de MySQL
* [PostgreSQL Documentation](https://www.postgresql.org/docs/) - Documentación oficial de PostgreSQL
* [SQL Tutorial](https://www.w3schools.com/sql/) - Tutorial completo de SQL
* [Database Design Basics](https://www.lucidchart.com/pages/database-diagram/database-design) - Fundamentos de diseño de bases de datos

### Recursos de Aprendizaje

* [Laracasts](https://laracasts.com) - Tutoriales en video de Laravel
* [Laravel News](https://laravel-news.com) - Noticias y artículos sobre Laravel
* [Eloquent Relationships](https://laravel.com/docs/12.x/eloquent-relationships) - Guía de relaciones en Eloquent
Glosario Técnico

| Término | Definición |
| --- | --- |
| **Base de Datos Relacional** | Sistema de gestión de datos que organiza la información en tablas relacionadas entre sí. |
| **Migración** | Archivo que define cambios en la estructura de la base de datos de manera versionada y reversible. |
| **ORM** | Mapeo Objeto-Relacional que permite interactuar con la base de datos usando objetos en lugar de SQL directo. |
| **Eloquent** | ORM incluido en Laravel que facilita la interacción con la base de datos usando modelos PHP. |
| **Modelo** | Clase PHP que representa una tabla de la base de datos y define cómo interactuar con sus datos. |
| **CRUD** | Acrónimo de Create, Read, Update, Delete - las operaciones básicas de gestión de datos. |
| **Relación** | Conexión lógica entre dos tablas que permite navegar entre datos relacionados. |
| **Seeder** | Clase que define datos iniciales para poblar la base de datos con información de prueba. |
| **Factory** | Clase que genera datos de prueba realistas de forma automatizada para desarrollo y testing. |
| **Esquema** | Estructura completa de la base de datos, incluyendo tablas, columnas, relaciones y restricciones. |

FAQ (Preguntas Frecuentes sobre la Práctica)

* **P: Error "SQLSTATE[42S01]: Base table or view already exists" al ejecutar migraciones**

  + **R:** Verifica los siguientes pasos:

    1. Ejecuta `sail artisan migrate:status` para ver qué migraciones ya se ejecutaron
    2. Si necesitas recrear las tablas, ejecuta `sail artisan migrate:fresh` (elimina todas las tablas y las recrea)
    3. Verifica que no haya migraciones duplicadas en `database/migrations/`
    4. Comprueba que el nombre de las tablas en `Schema::create()` sea único
    5. Si trabajas en equipo, sincroniza las migraciones con Git antes de ejecutarlas
* **P: Error "SQLSTATE[HY000] [1215] Cannot add foreign key constraint" en migraciones**

  + **R:** Verifica los siguientes pasos:

    1. Las migraciones se ejecutan en orden correcto (primero tablas referenciadas, luego las que referencian)
    2. Los tipos de datos coinciden exactamente (`foreignId()` usa BIGINT UNSIGNED)
    3. El nombre de la tabla referenciada existe y es correcto en `constrained('tabla')`
    4. Las claves foráneas apuntan a campos que son PRIMARY KEY o tienen índice UNIQUE
    5. Usa `Schema::enableForeignKeyConstraints()` si es necesario
* **P: Error "Class 'App\Models\NombreModelo' not found" en controladores o seeders**

  + **R:** Verifica los siguientes pasos:

    1. El modelo existe en `app/Models/` con el nombre correcto (sensible a mayúsculas)
    2. El namespace del modelo es correcto (`namespace App\Models;`)
    3. Importaste el modelo en la parte superior del archivo con `use App\Models\NombreModelo;`
    4. El nombre de la clase coincide con el nombre del archivo
    5. Ejecuta `composer dump-autoload` para regenerar el autoloader
* **P: Error "SQLSTATE[23000]: Integrity constraint violation" al ejecutar seeders**

  + **R:** Verifica los siguientes pasos:

    1. Los seeders se ejecutan en el orden correcto respetando claves foráneas
    2. Los IDs en los datos mock coinciden con los IDs reales en la base de datos
    3. No hay valores duplicados en campos `unique()` (como `slug` o `email`)
    4. Los campos `NOT NULL` tienen valores asignados
    5. Ejecuta `sail artisan migrate:fresh --seed` para limpiar y recrear todo
* **P: Los modelos no devuelven datos o devuelven colecciones vacías**

  + **R:** Verifica los siguientes pasos:

    1. Ejecutaste los seeders correctamente con `sail artisan db:seed`
    2. Verifica que hay datos en la tabla con `sail tinker` y `NombreModelo::count()`
    3. El nombre de la tabla en el modelo coincide con la tabla real (Laravel usa pluralización)
    4. Si usas una tabla custom, define `protected $table = 'nombre_tabla';` en el modelo
    5. Verifica la conexión a la base de datos con `sail artisan migrate:status`
* **P: Error "Call to a member function on null" al acceder a relaciones**

  + **R:** Verifica los siguientes pasos:

    1. La relación está correctamente definida en ambos modelos (bidireccional)
    2. Las claves foráneas tienen el nombre correcto (`tabla_id` en singular)
    3. Usa `with()` para cargar las relaciones: `Product::with('category')->find($id)`
    4. Usa operadores null-safe: `$product->offer?->name` para relaciones opcionales
    5. Verifica que existen datos relacionados en la base de datos
* **P: El problema N+1: muchas consultas SQL al listar productos con categorías/ofertas**

  + **R:** Solución con Eager Loading:

    1. Usa `with()` para cargar relaciones anticipadamente: `Product::with(['category', 'offer'])->get()`
    2. Para múltiples relaciones: `Product::with(['category', 'offer', 'users'])->get()`
    3. En el controlador, reemplaza `Product::all()` por `Product::with(['category', 'offer'])->get()`
    4. Verifica las consultas con Laravel Telescope o `DB::enableQueryLog()`
    5. Usa `load()` para cargar relaciones después: `$products->load('category')`
* **P: Error "Mass assignment" al crear registros con `Model::create()`**

  + **R:** Verifica los siguientes pasos:

    1. Define `$fillable` en el modelo con los campos que se pueden asignar masivamente
    2. O usa `$guarded = []` para permitir todos los campos (menos seguro)
    3. Alternativamente, crea el modelo y asigna campos manualmente: `$model = new Model(); $model->campo = $valor;`
    4. Verifica que los nombres de campos en `$fillable` coinciden con los de la tabla
    5. Usa `unguard()` temporalmente en seeders si es necesario
* **P: Los seeders no insertan datos o fallan silenciosamente**

  + **R:** Verifica los siguientes pasos:

    1. El seeder está registrado en `DatabaseSeeder.php` con `$this->call(NombreSeeder::class)`
    2. El orden de ejecución respeta las claves foráneas (primero tablas referenciadas)
    3. Los datos del trait `LoadsMockData` tienen la estructura correcta
    4. Ejecuta con `sail artisan db:seed --class=NombreSeeder` para ver errores específicos
    5. Revisa los logs en `storage/logs/laravel.log` para ver errores detallados
* **P: Error al usar `attach()` para tabla pivot: "Column not found"**

  + **R:** Verifica los siguientes pasos:

    1. La tabla pivot sigue la convención: orden alfabético singular (`product_user`, no `user_product`)
    2. Los campos adicionales se pasan en el segundo parámetro: `attach($id, ['quantity' => 2])`
    3. Define `withPivot('quantity')` en la relación del modelo
    4. La tabla pivot tiene `withTimestamps()` si usas `created_at`/`updated_at`
    5. Usa `sync()` en lugar de `attach()` si quieres reemplazar relaciones existentes
* **P: ¿Cómo verifico si las relaciones funcionan correctamente?**

  + **R:** Usa Tinker para probar:

    1. Abre Tinker: `sail artisan tinker`
    2. Obtén un producto: `$product = Product::first()`
    3. Accede a la categoría: `$product->category`
    4. Accede a la oferta: `$product->offer`
    5. Lista usuarios: `$product->users` (debería devolver una colección)
* **P: Error "Too few arguments to function" en métodos de relación**

  + **R:** Verifica los siguientes pasos:

    1. Los métodos de relación NO llevan paréntesis al definirlos: `public function category()`
    2. Al acceder como propiedad, NO uses paréntesis: `$product->category`
    3. Al acceder como método (para query builder), SÍ usa paréntesis: `$product->category()->where(...)`
    4. Verifica que el método devuelve un objeto de relación: `return $this->belongsTo(Category::class)`
    5. No confundas accessor/mutators con relaciones
* **P: Los timestamps (`created_at`, `updated_at`) no se actualizan automáticamente**

  + **R:** Verifica los siguientes pasos:

    1. La migración incluye `$table->timestamps()` para crear los campos
    2. El modelo NO tiene `public $timestamps = false;`
    3. Usa métodos Eloquent (`create()`, `update()`) en lugar de SQL directo
    4. Para tabla pivot, usa `withTimestamps()` en la definición de la relación
    5. Verifica que los campos en la base de datos son tipo `TIMESTAMP`
* **P: ¿Cómo depuro qué consultas SQL está ejecutando Eloquent?**

  + **R:** Usa estas técnicas:

    1. Laravel Telescope: `sail artisan telescope:install` y revisa la pestaña Queries
    2. Query Log: `DB::enableQueryLog()` antes, y `dd(DB::getQueryLog())` después
    3. En Tinker: `DB::connection()->enableQueryLog()` y luego ejecuta consultas
    4. Método `toSql()`: `Product::with('category')->toSql()` muestra la SQL sin ejecutar
    5. Dump del modelo: `Product::first()->toArray()` para ver estructura de datos

## 🏆 Hitos Conseguir

> Se diseña e implementa un esquema de base de datos completo con migraciones, se crean modelos Eloquent con relaciones, se implementan operaciones CRUD completas y se puebla la base de datos con seeders y factories, demostrando el dominio de la gestión de datos con Laravel.
