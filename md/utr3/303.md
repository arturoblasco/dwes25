3. CRUD con Eloquent: Las Cuatro Operaciones Maestras de los Datos | Introducci√≥n a Laravel



[Skip to content](#VPContent)

[![](/25-26-introduccion-laravel/img/logo.png)Introducci√≥n a  
Laravel](/25-26-introduccion-laravel/)

Appearance

Menu

Return to top

 Sidebar Navigation 

## Sesi√≥n 3: Gesti√≥n de Datos

[Inicio](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/)

[1. Migraciones y Estructura de Base de Datos](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/1-migraciones-estructura-bd.html)

[2. Introducci√≥n a Eloquent ORM](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/2-introduccion-eloquent-orm.html)

[3. Operaciones CRUD con Eloquent](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/3-operaciones-crud-eloquent.html)

[4. Relaciones en Eloquent](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/4-relaciones-eloquent.html)

[5. Seeders y Factories](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/5-seeders-factories.html)

## Ejercicios Pr√°cticos

[P3. Persistencia de Datos](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/p3-persistencia-de-datos.html)

![](/25-26-introduccion-laravel/img/logo-autor.png)

![](/25-26-introduccion-laravel/img/logo-gva.png)

![](/25-26-introduccion-laravel/img/logo-centro.png)

En esta p√°gina

# **3. CRUD con Eloquent: Las Cuatro Operaciones Maestras de los Datos** [‚Äã](#_3-crud-con-eloquent-las-cuatro-operaciones-maestras-de-los-datos)

Para gestionar los datos en una aplicaci√≥n, es fundamental dominar las operaciones CRUD: Crear (Create), Leer (Read), Actualizar (Update) y Eliminar (Delete). Eloquent ORM de Laravel simplifica enormemente estas operaciones, proporcionando m√©todos intuitivos y potentes para interactuar con la base de datos.

## 3.1. ¬øQu√© son las Operaciones CRUD? [‚Äã](#_3-1-¬øque-son-las-operaciones-crud)

Como se vio en la sesi√≥n 2, con los controladores de tipo resource, Laravel ya proporciona una estructura b√°sica para manejar las operaciones CRUD. Sin embargo, Eloquent lleva esto al siguiente nivel al ofrecer m√©todos espec√≠ficos y optimizados para cada operaci√≥n.

Los modelos cuentan con m√©todos integrados que facilitan la interacci√≥n con la base de datos, permitiendo realizar operaciones CRUD de manera sencilla y elegante.

Algunas de las operaciones CRUD m√°s comunes incluyen:

| Operaci√≥n | M√©todo Eloquent | SQL Equivalente |
| --- | --- | --- |
| **Create** | `Model::create()` | `INSERT INTO` |
| **Read** | `Model::find()`, `Model::all()` | `SELECT` |
| **Update** | `Model::update()` | `UPDATE` |
| **Delete** | `Model::delete()` | `DELETE` |

mermaid

```
flowchart TB
    RESULT[Modelo Eloquent]
    subgraph "üéØ CRUD con Eloquent"
        direction TB
        
        CREATE[üìù CREATE<br/>Model::create]
        READ[üîç READ<br/>Model::find/all/where]
        UPDATE[‚úèÔ∏è UPDATE<br/>Model::update]
        DELETE[üóëÔ∏è DELETE<br/>Model::delete]
        
        CREATE --> DB[(üóÑÔ∏è Base de Datos<br/>products)]
        READ --> DB
        UPDATE --> DB
        DELETE --> DB
        
        DB --> RESULT
        RESULT --> CREATE
        RESULT --> READ
        RESULT --> UPDATE
        RESULT --> DELETE
    end

    USER[üë§ Controlador] --> |Usa| RESULT

    USER --> | Envia el modelo a | VIEW[üñºÔ∏è Vista Blade]

    style CREATE fill:#4ade80
    style READ fill:#60a5fa
    style UPDATE fill:#fbbf24
    style DELETE fill:#f87171
    style DB fill:#a78bfa
    style RESULT fill:#34d399
```

Interpretaci√≥n del Diagrama

Este diagrama muestra el flujo completo de las operaciones CRUD:

1. **Controlador** ‚Üí Utiliza el modelo para iniciar una operaci√≥n (CREATE, READ, UPDATE o DELETE)
2. **Eloquent** ‚Üí Traduce la operaci√≥n a SQL y la ejecuta en la base de datos
3. **Base de Datos** ‚Üí Procesa la operaci√≥n y devuelve el resultado
4. **Modelo Eloquent** ‚Üí Convierte el resultado en un objeto PHP
5. **Vista Blade** ‚Üí Muestra los datos del objeto PHP al usuario

**Todo el proceso ocurre de forma transparente** sin una sola l√≠nea de SQL.

## 3.2. Operaci√≥n CREATE (Crear) [‚Äã](#_3-2-operacion-create-crear)

La operaci√≥n CREATE permite insertar nuevos registros en la base de datos. Para esto, Eloquent proporciona varios m√©todos que facilitan la creaci√≥n de nuevos registros.

### 3.2.1. M√©todos para Crear Registros [‚Äã](#_3-2-1-metodos-para-crear-registros)

Si solo se necesita crear un registro, se pueden usar los siguientes m√©todos:

php

```
// M√©todo 1: Crear y guardar manualmente
$product = new Product();
$product->name = 'iPhone 15';
$product->description = '√öltimo modelo de iPhone';
$product->price = 999.99;
$product->category_id = 1;
$product->save(); // Hasta que no se llame a save(), no se guarda en la base de datos

// M√©todo 2: Crear directamente y guardar (create)
$product = Product::create([
    'name' => 'iPhone 15',
    'description' => '√öltimo modelo de iPhone',
    'price' => 999.99,
    'category_id' => 1
]);

// M√©todo 3: Crear sin guardar (make)
$product = Product::make([
    'name' => 'iPhone 15',
    'description' => '√öltimo modelo de iPhone',
    'price' => 999.99,
    'category_id' => 1
]);
$product->save(); // Guardar cuando sea necesario
```

Asignaci√≥n Masiva y Seguridad

Se debe asegurar que el modelo tenga la propiedad `$fillable` o `$guarded` correctamente configurada para permitir la asignaci√≥n masiva cuando se usa `create()` o `make()`.

### 3.2.2. Crear M√∫ltiples Registros [‚Äã](#_3-2-2-crear-multiples-registros)

Tambi√©n es posible crear m√∫ltiples registros a la vez. Para ello se puede usar un array de arrays:

php

```
// Crear m√∫ltiples productos
$products = Product::create([
    [
        'name' => 'iPhone 15',
        'price' => 999.99,
        'category_id' => 1
    ],
    [
        'name' => 'Samsung Galaxy',
        'price' => 899.99,
        'category_id' => 1
    ],
    [
        'name' => 'iPad Pro',
        'price' => 1099.99,
        'category_id' => 1
    ]
]);
```

## 3.3. Operaci√≥n READ (Leer) [‚Äã](#_3-3-operacion-read-leer)

Para leer datos de la base de datos, Eloquent ofrece una variedad de m√©todos para recuperar registros de manera eficiente.

### 3.3.1. Consultas B√°sicas [‚Äã](#_3-3-1-consultas-basicas)

Algunas de las consultas m√°s comunes incluyen:

php

```
// Obtener todos los registros
$products = Product::all();

// Obtener un registro por ID
$product = Product::find(1);

// Obtener un registro o fallar. Lanza una excepci√≥n si no existe
$product = Product::findOrFail(1);

// Obtener el primer registro
$product = Product::first();

// Se posiciona en el √∫ltimo registro y lo obtiene
$product = Product::latest()->first();

// Contar registros
$count = Product::count();
```

### 3.3.2. Consultas con Condiciones [‚Äã](#_3-3-2-consultas-con-condiciones)

Lo m√°s habitual en las consultas es filtrar los resultados con condiciones. Eloquent tambi√©n proporciona m√©todos intuitivos para esto:

php

```
// WHERE b√°sico
$products = Product::where('category_id', 1)->get();

// WHERE con m√∫ltiples condiciones con AND
$products = Product::where('category_id', 1)
                   ->where('price', '>', 100)
                   ->get();

// WHERE con OR
$products = Product::where('category_id', 1)
                   ->orWhere('category_id', 2)
                   ->get();

// WHERE IN
$products = Product::whereIn('category_id', [1, 2, 3])->get();

// WHERE LIKE
$products = Product::where('name', 'like', '%iPhone%')->get();

// WHERE BETWEEN
$products = Product::whereBetween('price', [100, 500])->get();

// WHERE NULL
$products = Product::whereNull('deleted_at')->get();

// Verificar si existe
$exists = Product::where('name', 'iPhone 15')->exists();
```

### 3.3.3. Ordenamiento y Limitaci√≥n [‚Äã](#_3-3-3-ordenamiento-y-limitacion)

Por otro lado, es com√∫n ordenar y limitar los resultados:

php

```
// Ordenar por un campo
$products = Product::orderBy('price', 'desc')->get();
$products = Product::orderBy('name', 'asc')->get();

// Ordenar por m√∫ltiples campos
$products = Product::orderBy('category_id')
                   ->orderBy('price', 'desc')
                   ->get();

// Devolver un n√∫mero limitado de registros
$products = Product::take(10)->get();

// Saltar un n√∫mero de registros (offset)
$products = Product::skip(10)->get();
```

Encadenamiento de M√©todos

Eloquent permite encadenar m√∫ltiples m√©todos para construir consultas complejas de manera legible y fluida.

php

```
$products = Product::where('category_id', 1)
                   ->where('price', '>', 100)
                   ->orderBy('price', 'desc')
                   ->take(10)
                   ->get();
```

### 3.3.4 Paginaci√≥n simple y avanzada [‚Äã](#_3-3-4-paginacion-simple-y-avanzada)

Laravel ofrece dos m√©todos de paginaci√≥n para manejar grandes conjuntos de datos. La diferencia reside en la cantidad de informaci√≥n que se obtiene seg√∫n el m√©todo utilizado.

php

```
// Paginaci√≥n completa con enlaces (anterior, siguiente, n√∫meros de p√°gina)
$products = Product::paginate(15);

// Paginaci√≥n simple (solo anterior/siguiente, m√°s r√°pida)
$products = Product::simplePaginate(15);
```

| Caracter√≠stica | `paginate()` | `simplePaginate()` |
| --- | --- | --- |
| **N√∫meros de p√°gina** | ‚úÖ Todos los n√∫meros | ‚ùå Solo anterior/siguiente |
| **Conteo total** | ‚úÖ Muestra total de registros | ‚ùå No cuenta |
| **Rendimiento** | M√°s lento (cuenta registros) | M√°s r√°pido |
| **Uso recomendado** | Listados completos | Feeds infinitos, m√≥viles |

Para mostrar los enlaces de paginaci√≥n en la vista Blade, se utiliza el m√©todo `links()`:

php

```
@foreach($products as $product)
    {{-- Contenido --}}
@endforeach

{{ $products->links() }} {{-- Genera los enlaces autom√°ticamente --}}
```

### 3.4. Consultas Avanzadas [‚Äã](#_3-4-consultas-avanzadas)

Eloquent tambi√©n soporta consultas m√°s avanzadas como selecciones espec√≠ficas, agrupamientos, uniones y subconsultas. Aunque estas son menos comunes, son muy √∫tiles en casos espec√≠ficos.

php

```
// SELECT espec√≠fico
$products = Product::select('name', 'price')->get();

// GROUP BY
$products = Product::groupBy('category_id')
                   ->selectRaw('category_id, count(*) as total')
                   ->get();

// HAVING
$products = Product::groupBy('category_id')
                   ->having('count', '>', 5)
                   ->get();

// JOIN
$products = Product::join('categories', 'products.category_id', '=', 'categories.id')
                   ->select('products.*', 'categories.name as category_name')
                   ->get();

// Subconsultas
$products = Product::where('price', '>', function($query) {
    $query->selectRaw('AVG(price)')
          ->from('products');
})->get();
```

## 3.4. Operaci√≥n UPDATE (Actualizar) [‚Äã](#_3-4-operacion-update-actualizar)

Para actualizar registros existentes, Eloquent proporciona m√©todos que permiten modificar uno o varios registros de manera sencilla.

Basicamente, es muy similar a la operaci√≥n CREATE, pero en este caso se trabaja con registros ya existentes. La principal diferencia al llamar al m√©todo `save()` es que Eloquent detecta si el modelo ya existe en la base de datos (tiene un ID) y realiza una operaci√≥n `UPDATE` en lugar de `INSERT`.

### 3.4.1. Actualizar Registros Individuales [‚Äã](#_3-4-1-actualizar-registros-individuales)

php

```
// M√©todo 1: Actualizar por instancia
$product = Product::find(1);
$product->name = 'iPhone 15 Pro';
$product->price = 1099.99;
$product->save();

// M√©todo 2: Actualizar directamente
Product::where('id', 1)->update([
    'name' => 'iPhone 15 Pro',
    'price' => 1099.99
]);

// M√©todo 3: Actualizar o crear
$product = Product::updateOrCreate(
    ['name' => 'iPhone 15'],
    ['price' => 999.99]
);
```

### 3.4.2. Actualizar M√∫ltiples Registros [‚Äã](#_3-4-2-actualizar-multiples-registros)

php

```
// Actualizar m√∫ltiples registros
Product::where('category_id', 1)->update([
    'is_active' => true
]);

// Actualizar con incremento/decremento
Product::where('category_id', 1)->increment('price', 10);
Product::where('category_id', 1)->decrement('price', 5);

// Actualizar con condiciones
Product::where('price', '<', 100)->update([
    'is_discounted' => true
]);
```

### 3.4.3. Crear o Actualizar (Upsert) [‚Äã](#_3-4-3-crear-o-actualizar-upsert)

Esta funci√≥n combina la creaci√≥n y actualizaci√≥n en una sola operaci√≥n. Si el registro existe (basado en condiciones), se actualiza; si no, se crea uno nuevo.

php

```
// Crear o actualizar basado en condiciones
$product = Product::updateOrCreate(
    ['name' => 'iPhone 15'], // Condiciones para buscar
    [
        'price' => 999.99,
        'category_id' => 1
    ] // Datos para crear o actualizar
);

// Crear o actualizar m√∫ltiples registros
Product::upsert([
    ['name' => 'iPhone 15', 'price' => 999.99],
    ['name' => 'Samsung Galaxy', 'price' => 899.99]
], ['name'], ['price']); // name es la clave √∫nica, price se actualiza
```

## 3.5. Operaci√≥n DELETE (Eliminar) [‚Äã](#_3-5-operacion-delete-eliminar)

La ultima operaci√≥n CRUD es eliminar registros. Eloquent ofrece m√©todos para eliminar uno o varios registros de manera segura.

### 3.5.1. Eliminar Registros Individuales [‚Äã](#_3-5-1-eliminar-registros-individuales)

php

```
// M√©todo 1: Eliminar por instancia
$product = Product::find(1);
$product->delete();

// M√©todo 2: Eliminar directamente
Product::destroy(1);

// M√©todo 3: Eliminar m√∫ltiples por ID
Product::destroy([1, 2, 3]);

// M√©todo 4: Eliminar con condiciones
Product::where('price', '<', 50)->delete();
```

Soft Deletes (Eliminaci√≥n Suave)

Los **Soft Deletes** permiten "eliminar" registros sin borrarlos f√≠sicamente (se marcan con `deleted_at`). Esto es √∫til para mantener un historial y poder restaurar datos si es necesario. Para usar Soft Deletes, se debe agregar el trait `SoftDeletes` al modelo y asegurarse de que la tabla tenga una columna `deleted_at`.

### 3.5.2. Eliminar con Relaciones [‚Äã](#_3-5-2-eliminar-con-relaciones)

Cuando se trabaja con relaciones, es importante manejar las eliminaciones de manera adecuada para mantener la integridad referencial.

Se debe definir el comportamiento de las relaciones en los modelos (por ejemplo, `onDelete('cascade')` en las migraciones) para que al eliminar un registro, se eliminen o actualicen los registros relacionados seg√∫n sea necesario.

php

```
// Eliminar en cascada (definido en migraci√≥n)
$category = Category::find(1);
$category->delete(); // Elimina todos los productos relacionados

// Eliminar con verificaci√≥n
$product = Product::find(1);
if ($product->orders()->count() == 0) {
    $product->delete();
} else {
    // No se puede eliminar, tiene pedidos
}
```

## 3.6. Mejores Pr√°cticas [‚Äã](#_3-6-mejores-practicas)

### 3.6.1. Optimizaci√≥n de Consultas [‚Äã](#_3-6-1-optimizacion-de-consultas)

En ocasiones, las consultas pueden volverse ineficientes si no se optimizan correctamente. Por ejemplo, el problema N+1 ocurre cuando se realizan m√∫ltiples consultas adicionales para cargar relaciones.

En este se est√°n recogiendo todos los productos y luego, para cada producto, se hace una consulta adicional para obtener su categor√≠a. Esto puede generar muchas consultas innecesarias.

La soluci√≥n es usar **Eager Loading** con el m√©todo `with()` para cargar las relaciones de manera anticipada en una sola consulta. En este caso, se carga la categor√≠a de todos los productos en una sola consulta adicional.

Ademas se puede optimizar a√∫n m√°s seleccionando solo los campos necesarios en lugar de cargar todos los datos ya que esto reduce la cantidad de datos transferidos, mejora el rendimiento y asegura la privacidad de los datos.

php

```
// ‚ùå Malo: Problema N+1
$products = Product::all();
foreach ($products as $product) {
    echo $product->category->name; // Consulta adicional por cada producto
}

// ‚úÖ Bueno: Eager Loading
$products = Product::with('category')->get();
foreach ($products as $product) {
    echo $product->category->name; // Sin consultas adicionales
}

// ‚úÖ Mejor: Seleccionar solo campos necesarios
$products = Product::with('category:id,name')
                   ->select('id', 'name', 'category_id')
                   ->get();
```

## 3.7. Trabajando con Collections [‚Äã](#_3-7-trabajando-con-collections)

Cuando se realizan consultas con Eloquent, el resultado no es un array simple, sino una **Collection** (colecci√≥n). Las Collections son objetos potentes que ofrecen m√©todos √∫tiles para manipular y verificar datos.

Analog√≠a: La Bandeja de Pr√©stamo Inteligente

**¬°Imagina que el bibliotecario te entrega los libros en dos tipos de bandejas diferentes!**

* ÔøΩ **Array normal = Una pila de libros sin m√°s** Solo puedes ver cu√°ntos hay cont√°ndolos uno por uno Para saber si hay alguno, tienes que mirar la pila manualmente Para encontrar un libro espec√≠fico, debes revisarlos todos
* ‚ú® **Collection = La Bandeja Inteligente de la Biblioteca**

  + Le preguntas: *"¬øEst√°s vac√≠a?"* ‚Üí `isEmpty()` ‚Üí La bandeja responde al instante
  + Le dices: *"¬øTienes libros?"* ‚Üí `isNotEmpty()` ‚Üí Verifica autom√°ticamente
  + Le pides: *"¬øCu√°ntos libros hay?"* ‚Üí `count()` ‚Üí Cuenta por ti al momento
  + Le ordenas: *"Dame el primer libro"* ‚Üí `first()` ‚Üí Te lo entrega sin buscar
  + Le indicas: *"Filtra solo los de 2020"* ‚Üí `filter()` ‚Üí Selecciona autom√°ticamente
  + Le solicitas: *"Organ√≠zalos por t√≠tulo"* ‚Üí `sortBy('title')` ‚Üí Los ordena al instante.

**¬°Las Collections son como bandejas m√°gicas que conocen todo sobre los libros que contienen!**

### 3.7.2. M√©todos Esenciales de Collection [‚Äã](#_3-7-2-metodos-esenciales-de-collection)

php

```
// Obtener productos (devuelve una Collection)
$products = Product::all();

// Verificar si la colecci√≥n est√° vac√≠a
if ($products->isEmpty()) {
    echo "No hay productos";
}

// Verificar si la colecci√≥n tiene elementos (MUY USADO EN VISTAS)
if ($products->isNotEmpty()) {
    echo "Hay productos disponibles";
}

// Contar elementos
$total = $products->count();

// Obtener el primer elemento
$firstProduct = $products->first();

// Obtener el √∫ltimo elemento
$lastProduct = $products->last();

// Filtrar elementos
$expensiveProducts = $products->filter(function($product) {
    return $product->price > 100;
});

// Mapear/transformar elementos
$productNames = $products->map(function($product) {
    return $product->name;
});

// Verificar si contiene un elemento
$hasProduct = $products->contains('id', 1);

// Sumar valores
$totalPrice = $products->sum('price');

// Obtener valores √∫nicos
$uniqueCategories = $products->pluck('category_id')->unique();
```

### 3.7.3. Uso en Controladores y Vistas [‚Äã](#_3-7-3-uso-en-controladores-y-vistas)

**En el Controlador:**

php

```
public function index()
{
    $products = Product::with('category')->get(); // Devuelve Collection
    
    return view('products.index', [
        'products' => $products
    ]);
}
```

**En las Vistas Blade:**

html

```
{{-- Verificar si hay productos usando Collection --}}
@if($products->isNotEmpty())
    <div class="grid">
        @foreach($products as $product)
            <x-product-card :product="$product" />
        @endforeach
    </div>
@else
    <p>No hay productos disponibles</p>
@endif

{{-- Mostrar contador --}}
<p>Total de productos: {{ $products->count() }}</p>

{{-- Verificar si est√° vac√≠o --}}
@if($products->isEmpty())
    <div class="alert">
        No se encontraron productos
    </div>
@endif
```

Pager

[Anterior2. Introducci√≥n a Eloquent ORM](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/2-introduccion-eloquent-orm.html)

[Siguiente4. Relaciones en Eloquent](/25-26-introduccion-laravel/contenidos/s3-BFVkvq2UDCCz/4-relaciones-eloquent.html)

![Autor](/25-26-introduccion-laravel/img/logo-autor.png)

Copyright ¬© 2025