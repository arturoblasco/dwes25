# 2.2. Mapa de la aplicaci√≥n

Cuando un usuario accede a una URL en una aplicaci√≥n Laravel, el framework necesita saber exactamente qu√© hacer con esa solicitud. Esta responsabilidad recae en dos pilares fundamentales: el **Sistema de Rutas** y los **Controladores**.

En esta secci√≥n se explorar√° el sistema de enrutamiento de Laravel, aprendiendo a definir rutas, manejar par√°metros din√°micos y crear controladores profesionales siguiendo el patr√≥n MVC. Se comprender√° c√≥mo separar claramente la l√≥gica de negocio de la presentaci√≥n, siguiendo las mejores pr√°cticas del framework.


## 2.1. Convenci√≥n fundamental: programa en ingl√©s

**Laravel est√° dise√±ado para funcionar en ingl√©s.** Todos los nombres de archivos, clases, m√©todos, variables y rutas deben estar en **ingl√©s**, siguiendo las convenciones del idioma.

Laravel deduce autom√°ticamente nombres usando reglas del ingl√©s.

- `ProductController` ‚Üí busca en `resources/views/products/`
- Modelo `Product` ‚Üí busca tabla `products`

```php
<?php
// Controladores (singular, PascalCase)
ProductController, CategoryController, UserController, OfferController

// Rutas (plural, kebab-case)
/products, /categories, /users, /offers

// M√©todos (verbos en ingl√©s, camelCase)
index(), show(), create(), store(), edit(), update(), destroy()

// Variables (descriptivas en ingl√©s, camelCase)
$product, $category, $totalPrice, $isActive
```

* **Controladores**: Singular + "Controller" ‚Üí `ProductController`, `CategoryController`
* **Rutas**: Plural en kebab-case ‚Üí `/products`, `/categories`, `/user-profiles`
* **Vistas**: Plural como carpeta ‚Üí `resources/views/products/index.blade.php`
* **M√©todos**: Verbos en ingl√©s ‚Üí `index()`, `show()`, `create()`, `store()`
* **Variables**: camelCase descriptivo ‚Üí `$product`, `$totalPrice`, `$isActive`

> üéØ A partir de ahora, todo el c√≥digo de este curso seguir√° estas convenciones.

## 2. El sistema de enrutamiento

Las rutas son las encargadas de dirigir cada solicitud HTTP a la parte correspondiente de la aplicaci√≥n. Laravel utiliza un sistema de enrutamiento que permite definir rutas de manera clara y mantenible.

### 2.1. Archivos de rutas

Las rutas que responden a peticiones del navegador se definen principalmente en estos archivos:

* **`routes/web.php`**: Es el archivo de rutas de la aplicaci√≥n web. Estas rutas gestionan sesiones, cookies y protecci√≥n CSRF, lo que las hace ideales para cualquier interfaz con la que un usuario interact√∫e.
* **`routes/api.php`**: Se utiliza para definir las rutas de las API RESTful de la aplicaci√≥n. Estas rutas no incluyen middleware de sesi√≥n ni CSRF por defecto.
* **`routes/console.php`**: Para definir comandos de Artisan personalizados.

> üéØ Este curso se enfocar√° en **`routes/web.php`**, que es donde se definir√°n la mayor√≠a de las rutas para la interfaz web.

### 2.2. Tipos de rutas seg√∫n el verbo HTTP

Como se vi√≥ en la *unidad 1*, la web funciona con diferentes m√©todos o "verbos" HTTP para distintas acciones. Laravel permite registrar rutas para cada uno de ellos de forma muy sencilla. 

Los m√°s comunes son:

* **`Route::get($uri, $callback)`**: para solicitar y mostrar datos (*ej. ver productos, categor√≠as*).
* **`Route::post($uri, $callback)`**: para enviar y crear datos nuevos (*ej. crear un producto*).
* **`Route::put($uri, $callback)`**: para actualizar un recurso completo (*ej. actualizar un producto*).
* **`Route::patch($uri, $callback)`**: para actualizar parcialmente un recurso (*ej. cambiar solo el precio*).
* **`Route::delete($uri, $callback)`**: para eliminar un recurso (*ej. eliminar un producto*).

Las rutas definen las p√°ginas que los usuarios pueden visitar relacionadas con productos. 

???+examplelaravel "Ejemplo de c√≥mo se podr√≠an definir estas rutas en `routes/web.php`"

    ```php
    <?php
    // Fichero: routes/web.php

    use Illuminate\Support\Facades\Route;
    use App\Http\Controllers\ProductController;

    // P√°gina de lista de productos - muestra todos los productos
    Route::get('/products', [ProductController::class, 'index'])->name('home');

    // P√°gina de detalle de un producto
    Route::get('/products/{id}', [ProductController::class, 'show'])->name('products.show');

    // P√°gina de creaci√≥n de un nuevo producto
    Route::get('/products/create', [ProductController::class, 'create'])->name('products.create');
    Route::post('/products', [ProductController::class, 'store'])->name('products.store');

    // P√°gina de edici√≥n de un producto existente
    Route::get('/products/{id}/edit', [ProductController::class, 'edit'])->name('products.edit');
    Route::put('/products/{id}', [ProductController::class, 'update'])->name('products.update');

    // Eliminar un producto
    Route::delete('/products/{id}', [ProductController::class, 'destroy'])->name('products.destroy');
    ```

### 2.3. Rutas con m√∫ltiples verbos HTTP

Laravel tambi√©n permite definir rutas que respondan a m√∫ltiples verbos HTTP:

```php
<?php
// Responde a GET, POST y ambos se dirigen al mismo m√©todo
Route::match(['get', 'post'], '/products/search', [ProductController::class, 'search']);

// Responde a cualquier verbo HTTP y todas las rutas se dirigen al mismo m√©todo
Route::any('/tags', [ProductController::class, 'handle']);
```

### 2.4. Rutas que solo muestran vistas

Para casos muy simples donde una ruta solo debe mostrar una vista sin ninguna l√≥gica adicional, se puede usar un atajo. Las permiten definir una funci√≥n an√≥nima (o closure) que devuelve una vista directamente:



```php
<?php
// Fichero: routes/web.php


// En lugar de esto:
Route::get('/about', function () {
    return view('about');
});

Route::get('/contact', function () {
    return view('contact');
});


// Puedes usar esto:
Route::view('/about', 'about');
Route::view('/contact', 'contact');
```

### 2.5. Rutas con par√°metros

A menudo, se necesitar√° enviar y capturar par√°metros por la URL. Por ejemplo, para mostrar un producto espec√≠fico se puede enviar el identificador del producto: `/products/123` donde `123` es el ID del producto. Laravel facilita la definici√≥n y captura de estos par√°metros.

#### Par√°metros obligatorios

Se definen encerrando el nombre del par√°metro entre llaves **`{}`**. Este valor se pasar√° autom√°ticamente como argumento a la funci√≥n del controlador.



```php
<?php
// En routes/web.php
use App\Http\Controllers\ProductController;

// Definir una ruta con un par√°metro obligatorio {id}
Route::get('/products/{id}', [ProductController::class, 'show']);
```



```php
<?php
// En app/Http/Controllers/ProductController.php

// El m√©todo show recibe el ID del producto como argumento
public function show(string $id): View
{
    // Implementaci√≥n del m√©todo
}
```

#### Par√°metros opcionales

Para que un par√°metro sea opcional, se a√±ade un signo de interrogaci√≥n **`?`** despu√©s de su nombre y se proporciona un valor por defecto en el m√©todo del controlador.



```php
<?php
// En routes/web.php

// Definir una ruta con un par√°metro opcional {category?}
Route::get('/products/{category?}', [ProductController::class, 'index']);
```



```php
<?php
// En app/Http/Controllers/ProductController.php

// El par√°metro $category es opcional y puede ser null
public function index(string $category = null): View
{
    // Si no se especifica categor√≠a, mostrar todos los productos
    return view('products.index', ['category' => $category]);
}
```


```html
<!-- En el fichero blade (vista): -->

<h1>
  @if ($category)
      Mostrando productos de {{ $category }}
  @else
      Mostrando todos los productos
  @endif
</h1>

```

Seg√∫n si llega o no la categor√≠a:

* `/products/electronics` mostrar√° productos de electr√≥nica
* `/products` mostrar√° todos los productos

#### Restricciones con expresiones regulares

Se puede asegurar que un par√°metro de ruta tenga un formato espec√≠fico usando el m√©todo **`where()`**. Esto es especialmente √∫til para validar que los par√°metros cumplan con el formato esperado.



```php
<?php
// Solo acepta IDs num√©ricos para los productos
Route::get('/products/{id}', [ProductController::class, 'show'])->where('id', '[0-9]+');

// Solo aceptar√° categor√≠as con letras y guiones
Route::get('/category/{slug}', [CategoryController::class, 'show'])->where('slug', '[A-Za-z-]+');

// M√∫ltiples restricciones
Route::get('/products/{id}/offer/{offerId}', [ProductController::class, 'showOffer'])
    ->where(['id' => '[0-9]+', 'offerId' => '[0-9]+']);
```

#### Par√°metros con Model Binding

Laravel tambi√©n permite el **model binding**, donde autom√°ticamente resuelve un modelo Eloquent basado en el par√°metro de la ruta:



```php
<?php
// Laravel autom√°ticamente busca el modelo Product con el ID proporcionado
Route::get('/products/{product}', [ProductController::class, 'show']);
```

```php
<?php
// En el controlador, recibir√°s directamente el modelo
public function show(Product $product): View
{
    // $product ya est√° resuelto autom√°ticamente
    return view('products.show', ['product' => $product]);
}
```

> **Avance: Modelos**
> 
> Para entender completamente el *model binding*, es necesario conocer los **modelos Eloquent**, que se ver√°n en detalle m√°s adelante en el curso.

### 2.6. Rutas con nombre

Asignar un nombre a una ruta es una de las mejores pr√°cticas en Laravel. En lugar de "hardcodear" (escribir directamente) las URLs en las vistas y redirecciones, se llama a las rutas por un nombre. Si en el futuro se cambia la URL, no se tendr√° que modificar nada m√°s en el c√≥digo.

Se definen encadenando el m√©todo **`name()`** y es habitual poner un prefijo que indique el recurso (como `products`) y la acci√≥n (como `index`):



```php
<?php
// En routes/web.php
Route::get('/products', [ProductController::class, 'index'])->name('products.index');

Route::get('/products/{id}', [ProductController::class, 'show'])->name('products.show');
```

Luego, en las vistas de Blade, se puede generar la URL f√°cilmente con a√±adiendo la funci√≥n `route()` en la referencia de los enlaces y en lugar de escribir la URL directamente se usa el nombre de la ruta:

```html
<!-- Enlace a todos los productos: -->
<a href="{{ route('products.index') }}">Todos los productos</a>

<!-- Enlace a un producto espec√≠fico: -->
<a href="{{ route('products.show', ['id' => $product->id]) }}">Ver detalles</a>
```

### 2.7. Agrupaci√≥n de rutas

Cuando varias rutas comparten caracter√≠sticas comunes, se pueden agrupar para mantener el archivo de rutas limpio y organizado:

```php
<?php
// Agrupar rutas con un prefijo com√∫n
Route::prefix('admin')->group(function () {
       Route::get('/dashboard', [AdminController::class, 'dashboard']);
       Route::get('/users', [AdminController::class, 'users']);
       Route::get('/settings', [AdminController::class, 'settings']);
});

// Agrupar rutas con middleware com√∫n
Route::middleware(['auth'])->group(function () {
       Route::get('/profile', [UserController::class, 'profile']);
       Route::get('/settings', [UserController::class, 'settings']);
});

// Agrupar rutas con un namespace com√∫n
Route::namespace('Admin')->group(function () {
       Route::get('/admin/users', 'UserController@index');
       Route::get('/admin/posts', 'PostController@index');
});
```

### 2.8. Funcionalidades en las rutas

Hasta ahora se ha visto c√≥mo definir rutas en Laravel y en estas a√±adir l√≥gica directamente en el archivo de rutas usando funciones an√≥nimas (*closures*), pero esto se convierte r√°pidamente en un problema:

```php
<?php
Route::get('/products/{id}', function (string $id) {
    // Implementaci√≥n de la l√≥gica aqu√≠
    return view('products.show', ['product' => $products[$id]]);
});

// ... y as√≠ con cada ruta
```

#### **Problemas de este enfoque:**

* ‚ö†Ô∏è**Archivo enorme**: `routes/web.php` se vuelve inmanejable con cientos de l√≠neas
* ‚ö†Ô∏è**C√≥digo duplicado**: Se repite la carga de datos en cada ruta
* ‚ö†Ô∏è**Dif√≠cil de testear**: No se puede probar la l√≥gica de forma aislada
* ‚ö†Ô∏è**Mezcla de responsabilidades**: Las rutas definen URLs Y contienen l√≥gica de negocio
* ‚ö†Ô∏è**Dif√≠cil de mantener**: Encontrar y modificar funcionalidad espec√≠fica es un caos

#### **La soluci√≥n profesional: Controladores**

Los **controladores** resuelven todos estos problemas organizando la l√≥gica en clases especializadas, separando claramente las responsabilidades y facilitando el mantenimiento del c√≥digo.

## 3. Controladores profesionales

Un **controlador** es una clase de PHP cuya responsabilidad es agrupar la l√≥gica relacionada con las peticiones HTTP. Act√∫a como un intermediario que recibe la petici√≥n desde la ruta, interact√∫a con otras partes de la aplicaci√≥n (como los modelos, que se ver√°n m√°s adelante) y finalmente prepara y devuelve una respuesta, que normalmente es una vista.

Los controladores permiten separar la l√≥gica de negocio de la presentaci√≥n, siguiendo el patr√≥n **MVC (Modelo-Vista-Controlador)**.


### 3.1. Tipos de controladores

Existen varios tipos de controladores en Laravel, cada uno con su prop√≥sito espec√≠fico.

#### Controladores de acci√≥n √∫nica (invokable)

Son controladores dise√±ados para hacer una sola cosa. Son muy √∫tiles para tareas simples y espec√≠ficas. 

Se crean con el flag **`--invokable`**.

```bash
php artisan make:controller HomeController --invokable
```

Este controlador solo tendr√° un m√©todo: `__invoke()`. Para registrarlo en las rutas, no se necesita especificar el m√©todo.



```php
<?php
// En routes/web.php
use App\Http\Controllers\HomeController;

Route::get('/', HomeController::class)->name('home');
```

#### Controladores de recursos (resource)

Este es el tipo de controlador m√°s potente y com√∫n para gestionar entidades de la aplicaci√≥n (como usuarios, productos, posts, etc.). Un controlador de recursos agrupa toda la l√≥gica **CRUD** (Crear, Leer, Actualizar, Borrar) para un modelo.

Se crean con el flag **`--resource`**:



```bash
php artisan make:controller ProductController --resource
```

Este comando genera un controlador con 7 m√©todos predefinidos, cada uno mapeado a una acci√≥n CRUD espec√≠fica:

* `index()`: mostrar una lista de todos los recursos (ej. todos los productos).
* `create()`: mostrar el formulario para crear un nuevo recurso.
* `store(Request $request)`: guardar el nuevo recurso en la base de datos.
* `show($id)`: mostrar un recurso espec√≠fico.
* `edit($id)`: mostrar el formulario para editar un recurso existente.
* `update(Request $request, $id)`: actualizar el recurso en la base de datos.
* `destroy($id)`: eliminar el recurso de la base de datos.

Lo mejor es que no se tiene que registrar una ruta para cada uno de estos m√©todos. Laravel da un atajo m√°gico con `Route::resource()`:

```php
<?php
// En routes/web.php
use App\Http\Controllers\ProductController;

Route::resource('products', ProductController::class);
```

Esa sola l√≠nea de c√≥digo crea autom√°ticamente las 7 rutas necesarias para todo el flujo CRUD, con sus verbos HTTP y nombres de ruta correctos:

* `GET /products` ‚Üí `ProductController@index` (listar productos)
* `GET /products/create` ‚Üí `ProductController@create` (formulario crear producto)
* `POST /products` ‚Üí `ProductController@store` (guardar nuevo producto)
* `GET /products/{id}` ‚Üí `ProductController@show` (mostrar producto)
* `GET /products/{id}/edit` ‚Üí `ProductController@edit` (formulario editar)
* `PUT /products/{id}` ‚Üí `ProductController@update` (actualizar producto)
* `DELETE /products/{id}` ‚Üí `ProductController@destroy` (eliminar producto)

### 3.2. Rutas adicionales en controladores resource

Aunque las rutas resource son muy convenientes, a veces se necesitan rutas adicionales espec√≠ficas para funcionalidades que no encajan en el patr√≥n CRUD est√°ndar. Cuando se combina `Route::resource()` con rutas personalizadas adicionales, el orden de declaraci√≥n se vuelve crucial.

> **El orden es importante**
> 
> Las rutas custom **DEBEN definirse ANTES** de la ruta resource. Laravel procesa las rutas en el orden en que aparecen en el archivo, y la primera que coincida con la URL ser√° la que se ejecute.
> 
> ```php
> <?php
> // ‚ùå INCORRECTO
> // La ruta resource captura "on-sale" como un {id} de la ruta show
> 
> Route::resource('products', ProductController::class);
> Route::get('/products/on-sale', [ProductController::class, 'onSale']); // ¬°Nunca se ejecuta!
> ```
> 
> 1. Usuario visita `/products/on-sale`
> 2. Laravel comprueba las primeras rutas creadas con resource: `Route::resource('products', ...)`
> 3. Las rutas resource tienen `GET /products/{id}`, donde `{id}` puede ser cualquier cosa
> 4. Laravel interpreta "on-sale" como un ID y ejecuta `show('on-sale')`
> 5. El controlador busca un producto con ID "on-sale" y falla
> 6. La ruta custom nunca se alcanza
> 
> ```php
> <?php
> // ‚úÖ CORRECTO
> // La ruta custom se define primero
> 
> Route::get('/products/on-sale', [ProductController::class, 'onSale'])->name('products.on-sale');
> Route::resource('products', ProductController::class);
> ```

## 4. Creando nuestra primera conexi√≥n (paso a paso)

Se va a definir la primera ruta y asociarla a un m√©todo en un controlador. Se reemplazar√° la ruta de bienvenida por defecto para que sea gestionada por el propio controlador.

### Paso 1: Crear el controlador

Se usar√° **Artisan**, la herramienta de l√≠nea de comandos de Laravel, para crear el controlador. Se abre el terminal en la ra√≠z del proyecto y se ejecuta:

```bash
php artisan make:controller HomeController
```

Este comando crear√° un nuevo archivo en `app/Http/Controllers/HomeController.php`.

### Paso 2: A√±adir un m√©todo al controlador

Ahora, se abre el archivo `app/Http/Controllers/HomeController.php` y se a√±ade un m√©todo p√∫blico, que se llamar√° `index`. Este m√©todo se encargar√° de la l√≥gica para la p√°gina de inicio. Por ahora, simplemente devolver√° la vista de bienvenida.

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\View\View; // Es buena pr√°ctica importar la clase View

class HomeController extends Controller
{
    /**
     * Muestra la p√°gina de inicio del blog.
     */
    public function index(): View
    {
        return view('welcome');
    }
}
```

> **Nota de PHP 8.4:** 
> 
> Observa que hemos a√±adido **`: View`** al m√©todo. Esto se llama **tipado de retorno** y le indica a PHP que esta funci√≥n siempre debe devolver un objeto de tipo `View`. Es una pr√°ctica moderna que hace el c√≥digo m√°s robusto y f√°cil de entender.

### Paso 3: Conectar la ruta con el controlador

Finalmente, se vuelve al archivo `routes/web.php` y se modifica la ruta ra√≠z para que, en lugar de usar una funci√≥n, "llame" al m√©todo `index` del nuevo `HomeController` (adem√°s, se ha creado un nombre a la ruta para una posterior utilizaci√≥n en vistas).



```php
<?php
// Fichero: routes/web.php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\HomeController; // ¬°No olvides importar el controlador!

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
*/

// La sintaxis es: Route::verbo('url', [Controlador::class, 'metodo']);
Route::get('/', [HomeController::class, 'index'])->name('home');
```

## 5. Helpers comunes

Laravel incluye una gran cantidad de funciones auxiliares (helpers) que hacen el desarrollo m√°s eficiente y seguro. Estas funciones est√°n **disponibles globalmente** en toda la aplicaci√≥n y son especialmente √∫tiles en controladores y vistas.

### Manejo de errores HTTP con `abort()`

La funci√≥n **`abort()`** permite detener la ejecuci√≥n de la aplicaci√≥n y devolver una respuesta HTTP de error de forma inmediata. Es muy √∫til para validaciones de seguridad y manejo de casos edge.



```php
<?php
// En un controlador
public function show(string $id): View
{
    $product = $this->find($id);
    
    // Si el producto no existe, devolver error 404
    if (!$product) {
        abort(404, 'Producto no encontrado');
    }
    
    // Si el usuario no tiene permisos, devolver error 403
    if (!$this->userCanView($product)) {
        abort(403, 'No tienes permisos para ver este producto');
    }
    
    return view('products.show', ['product' => $product]);
}
```

**¬øPor qu√© usar `abort()`?** 

En aplicaciones reales, se necesita manejar situaciones donde algo sale mal: un usuario intenta acceder a un producto que no existe, o alguien sin permisos intenta ver contenido privado. `abort()` permite manejar estos casos de forma elegante y consistente.

### Depuraci√≥n y desarrollo con `dd()`

La funci√≥n **`dd()`** (*dump and die*) es una herramienta de depuraci√≥n que imprime informaci√≥n sobre variables y detiene la ejecuci√≥n del script. Es extremadamente √∫til durante el desarrollo para inspeccionar datos.

```php
<?php
public function index(): View
{
    $products = $this->all();
    
    // Durante el desarrollo, puedes inspeccionar los datos
    dd($products); // Esto mostrar√° el contenido y detendr√° la ejecuci√≥n
    
    return view('products.index', ['products' => $products]);
}
```

**¬øPor qu√© es importante `dd()`?** 

Durante el desarrollo, se necesita verificar que los datos tienen la estructura correcta antes de pasarlos a las vistas. `dd()` permite inspeccionar arrays, objetos, y cualquier variable de forma clara y estructurada, evitando errores en tiempo de ejecuci√≥n.

### Helpers de rutas de archivos

Laravel proporciona funciones helper para construir rutas de archivos de forma segura y consistente, independientemente del sistema operativo.

#### `database_path()`

Esta funci√≥n devuelve la ruta completa al directorio `database` de la aplicaci√≥n Laravel.



```php
<?php
// Cargar datos mock desde la carpeta database
$products = require database_path('data/mock-products.php');

// Acceder a un archivo de migraci√≥n
$migrationFile = database_path('migrations/2025_01_15_create_products_table.php');
```

#### `base_path()`

Esta funci√≥n devuelve la ruta completa al directorio ra√≠z de la aplicaci√≥n Laravel.



```php
<?php
// Acceder a archivos en la ra√≠z del proyecto
$configFile = base_path('config/app.php');

// Acceder a archivos en subdirectorios
$envFile = base_path('.env');
$composerFile = base_path('composer.json');
```

**¬øPor qu√© usar estos helpers?** 

En lugar de escribir rutas como `'../database/data/mock-products.php'` o `__DIR__ . '/../../database/data/mock-products.php'`, estos helpers dan rutas absolutas y seguras. Esto es especialmente importante cuando la aplicaci√≥n se despliega en diferentes entornos (desarrollo, producci√≥n) donde las rutas relativas pueden fallar.

