# 2.6. Datos mock

En el desarrollo de aplicaciones web, especialmente durante las fases iniciales de un proyecto, es una pr谩ctica profesional trabajar con **datos mock** (datos de prueba simulados) en lugar de depender inmediatamente de una base de datos real. Los datos mock permiten desarrollar y probar funcionalidades de forma 谩gil, sin la complejidad inicial de configurar y mantener una base de datos completa.

Los datos mock ofrecen m煤ltiples beneficios durante el desarrollo:

**Desarrollo r谩pido**: No requiere configuraci贸n de base de datos.

**Datos consistentes**: Mismos datos para todos los desarrolladores del equipo.

**F谩cil testing**: Datos predecibles para pruebas.

**Simplicidad**: Estructura simple y f谩cil de entender.

**Versionado**: Los datos mock se pueden versionar con Git.

**Centralizaci贸n**: Un solo lugar para modificar los datos de toda la aplicaci贸n.

**Sin duplicaci贸n**: Evita repetir datos en cada controlador.


 Cuando varios desarrolladores **trabajan en el mismo proyecto**:

* **Sin datos mock centralizados**: Cada desarrollador crea sus propios datos de prueba. *Ana tiene 5 productos, Carlos tiene 8, y Mar铆a tiene 3*. Caos total cuando intentan integrar su c贸digo.
* **Con datos mock centralizados**: Todos comparten `mock-products.php` con los mismos 10 productos. El c贸digo de Ana funciona en el ordenador de Carlos sin cambios.
* **Cambios coordinados**: Si Ana actualiza el precio de un producto en el mock, autom谩ticamente Carlos y Mar铆a ven ese cambio en su pr贸ximo `git pull`.
* **Testing consistente**: Las pruebas funcionan igual para todos porque usan los mismos datos base.

隆Los datos mock centralizados son como tener un "idioma com煤n" para todo el equipo!

## 1. Estructura de Datos Mock

En Laravel, los datos mock se organizan t铆picamente en el directorio **`database/data/`**. Aqu铆 es donde se almacenan los archivos PHP que devuelven arrays con los datos simulados.

Cada archivo mock devuelve un array PHP con la estructura de datos correspondiente. A veces puede ser 煤til tener un array asociativo con IDs como claves para facilitar b煤squedas r谩pidas.

* Array de elementos simples:

  ```php
  <?php

  return [
      [
          'id' => 1,
          'name' => 'Categor铆a 1',
          'description' => 'Descripci贸n de la categor铆a 1'
      ],
      [
          'id' => 2,
          'name' => 'Categor铆a 2',
          'description' => 'Descripci贸n de la categor铆a 2'
      ],
  ];
  ```
* Array asociativo con IDs como claves:

  ```php
  <?php

  return [
      1 => [
          'name' => 'Producto 1',
          'description' => 'Descripci贸n del producto 1'
          'category_id' => 1
      ],
      2 => [
          'name' => 'Producto 2',
          'description' => 'Descripci贸n del producto 2'
          'category_id' => 1
      ],
  ];
  ```

Dependiendo de las necesidades, puedes elegir el formato que mejor se adapte a tu caso.

**Helper `database\_path()`**

Laravel proporciona el helper **`database_path()`** que devuelve la ruta completa al directorio `database/` de la aplicaci贸n. Esto permite cargar archivos de forma segura independientemente del sistema operativo.

## 2. Traits: reutilizando c贸digo entre controladores

### 2.1. 驴Qu茅 es un Trait?

Un **trait** es un mecanismo de reutilizaci贸n de c贸digo en PHP que permite compartir m茅todos entre m煤ltiples clases. Es especialmente 煤til cuando varias clases necesitan la misma funcionalidad pero no pueden heredar de una clase com煤n.

Los traits ofrecen m煤ltiples ventajas cuando se trabaja con datos mock:

**DRY (Don't Repeat Yourself)**: Elimina la duplicaci贸n de c贸digo.

**Mantenimiento centralizado**: Un solo lugar para modificar la l贸gica de carga.

**Consistencia**: Todos los controladores usan los mismos m茅todos.

**Escalabilidad**: F谩cil a帽adir nuevos m茅todos al trait.

**Legibilidad**: Los controladores se enfocan en su l贸gica espec铆fica.

**Testing**: M谩s f谩cil probar la l贸gica de carga de datos.


### 2.2. Crear el Trait para Datos mock

Los traits son ideales para centralizar los m茅todos de carga de datos mock que varios controladores necesitan.

Si varios controladores necesitan cargar datos desde archivos mock, en lugar de repetir los mismos m茅todos en cada controlador, se puede crear un trait **`LoadsMockData`** que contenga todos estos m茅todos.

```php
<?php
// Fichero: app/Traits/LoadsMockData.php

namespace App\Traits;

trait LoadsMockData
{
    /**
     * Load categories from mock file
     */
    protected function getCategories(): array
    {
        return require database_path('data/mock-categories.php');
    }


    /**
     * Load products from mock file
     */
    protected function getProducts(): array
    {
        return require database_path('data/mock-products.php');
    }

    /**
     * Load all mock data at once
     */
    protected function getAllMockData(): array
    {
        return [
            'categories' => $this->getCategories(),
            'offers' => $this->getOffers(),
            'cart' => $this->getCart(),
            'products' => $this->getProducts(),
        ];
    }
}
```

### 2.3. Uso de Traits

Los traits se incluyen en una clase usando la palabra clave **`use`**. Esto hace que todos los m茅todos del trait est茅n disponibles en la clase.

```php
<?php

namespace App\Http\Controllers;

use App\Traits\LoadsMockData;
use Illuminate\Http\Request;
use Illuminate\View\View;

class ProductController extends Controller
{
    use LoadsMockData; // 隆Una l铆nea da acceso a todos los m茅todos!

    
    public function index(): View
    {
       // Implementaci贸n para listar productos
       $products = $this->getProducts(); // M茅todo del trait
       // ... l贸gica adicional ...
    }

    // Otros m茅todos del controlador...
}
```

## 3. Funciones avanzadas con datos mock

### 3.1. Filtrado de datos con array\_filter()

La funci贸n **`array_filter()`** de PHP permite filtrar elementos de un array seg煤n una condici贸n.

```php
$products = $this->getProducts();
$filtered = array_filter($products, function($product) {
    return $product['price'] > 50;  // Filtra productos con precio mayor a 50
});
```

### 3.2 Transformaci贸n de datos con array\_map()

La funci贸n **`array_map()`** de PHP permite transformar cada elemento de un array aplicando una funci贸n a cada uno.

```php
$products = $this->getProducts();
$categories = $this->getCategories();
$enrichedProducts = array_map(function($product) use ($categories) {
    $product['category'] = $categories[$product['category_id']] ?? null;    
    return $product;
}, $products);


// Retorna productos enriquecidos con datos de categor铆a

[
    1 => [
        'name' => 'Producto 1',
        'description' => 'Descripci贸n del producto 1'
        'category_id' => 1,
        'category' => [
            'name' => 'Categor铆a 1',
            'description' => 'Descripci贸n de la categor铆a 1'
        ]
    ],
    2 => [
        'name' => 'Producto 2',
        'description' => 'Descripci贸n del producto 2',
        'category_id' => 1,
        'category' => [
            'name' => 'Categor铆a 1',
            'description' => 'Descripci贸n de la categor铆a 1'
        ]
    ],
]
```

### 3.3. B煤squeda por ID con operador ??

El operador **`??`** (null coalescing) es perfecto para buscar elementos por ID:

```php
// Buscar producto con ID 5
$product = $products[3] ?? null;

// Si existe: $product tiene los datos
// Si no existe: $product es null

// Luego validar
if (!$product) {
    abort(404, 'Producto no encontrado');
}
```
