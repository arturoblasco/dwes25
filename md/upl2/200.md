# Introducción

## Síntesis de la sesión

En esta sesión se exploran los **fundamentos arquitectónicos de Laravel**. Se estudia el **ciclo de vida completo de las peticiones HTTP**, desde `index.php` hasta la respuesta final, pasando por el Service Container, middleware y el flujo de procesamiento. Se domina el **sistema de rutas y controladores RESTful**, aplicando el principio de Separación de Responsabilidades.

Se construyen **interfaces dinámicas con Blade**: el motor de plantillas de Laravel, layouts maestros reutilizables, herencia de plantillas con directivas avanzadas (`@parent`, `@show`, `@append`), y stacks para acumulación de contenido. Se aprende a **integrar datos en vistas** usando múltiples métodos (`compact()`, `with()`, View Composers), manejar datos flash, y aplicar operadores null-safe para vistas robustas.

Finalmente, se trabaja con **datos mock organizados** usando traits reutilizables (`LoadsMockData`), transformando datos con `array_map()` y `array_filter()`, y preparando la transición a base de datos real (Sesión 3). El objetivo es comprender el flujo completo request-response, crear aplicaciones MVC profesionales y dominar el patrón de ejemplos progresivos (Layout → Vista → HTML final).

## Contenidos de la Sesión 2

* **1. Ciclo de Vida de las Peticiones HTTP**: Se estudia el viaje completo de una petición HTTP en Laravel: desde `index.php` hasta la respuesta final. Se explora el rol del middleware, el Service Container, y cómo cada componente procesa la petición en el framework.
* **2. Sistema de Rutas y Controladores**: Se domina el enrutamiento de Laravel para gestionar las peticiones web. Se aprende a definir rutas (`web.php`, `api.php`), manejar parámetros dinámicos, crear controladores resource, aplicar middleware y organizar código profesionalmente.
* **3. Introducción a Blade**: Se descubre el motor de plantillas Blade de Laravel para generar HTML dinámico. Se aprende sintaxis de escapado ( vs `{!! !!}`), directivas de control de flujo (`@if`, `@foreach`, `@empty`), la variable `$loop`, directivas de autenticación y formularios para crear vistas dinámicas seguras.
* **4. Layouts y Herencia en Blade**: Se construyen layouts maestros reutilizables para estructurar las aplicaciones. Se domina la herencia con `@extends`, `@section`, `@yield`, directivas avanzadas (`@parent`, `@show`, `@append`), stacks para acumulación de contenido (`@push`/`@stack`), y layouts anidados para arquitecturas complejas.
* **5. Integración de Datos con Vistas**: Se conectan controladores con vistas para crear interfaces dinámicas. Se aprenden métodos de paso de datos (`view([])`, `with()`, `compact()`), redirección con datos flash, ejemplos completos controlador→vista→HTML, View Composers para datos compartidos, y buenas prácticas de separación de responsabilidades.
* **6. Datos Mock para Desarrollo**: Se aprende a trabajar con datos mock para desarrollo sin base de datos real. Se organizan datos en `database/data/`, se crean traits reutilizables (`LoadsMockData`), se transforman datos con `array_map()` y `array_filter()`, y se prepara la transición a base de datos real en Sesión 3.
* **Diapositivas**: Presentación visual completa con diagramas de flujo Mermaid, ejemplos de código progresivos y conceptos clave de la arquitectura de Laravel.

## Objetivos de la Sesión 2

Acceso Rápido a los Objetivos

* **Objetivo 1**: Comprender el ciclo de vida completo de las peticiones HTTP en Laravel: desde `index.php`, pasando por el Service Container y middleware, hasta la respuesta final renderizada.
* **Objetivo 2**: Dominar el sistema de rutas y controladores RESTful, organizando código con el principio de Separación de Responsabilidades, aplicando middleware y creando controladores resource profesionales.
* **Objetivo 3**: Dominar el motor de plantillas Blade con sintaxis de escapado seguro ( vs `{!! !!}`), directivas de control de flujo, autenticación, formularios y la variable `$loop` para HTML dinámico.
* **Objetivo 4**: Construir layouts maestros reutilizables con herencia de plantillas (`@extends`, `@section`, `@yield`), directivas avanzadas (`@parent`, `@show`, `@append`), stacks y layouts anidados.
* **Objetivo 5**: Integrar datos en vistas usando múltiples métodos (`view([])`, `with()`, `compact()`), manejar datos flash, implementar View Composers para datos compartidos y aplicar operadores null-safe.
* **Objetivo 6**: Trabajar con datos mock organizados usando traits reutilizables (`LoadsMockData`), transformar datos con `array_map()` y `array_filter()`, y preparar la transición a base de datos real.
* **Objetivo 7**: Aplicar el patrón de ejemplos progresivos (Layout → Vista → HTML final) para comprender la integración completa de componentes Blade.
* **Objetivo 8**: Seguir buenas prácticas Laravel: separación de responsabilidades, nomenclatura consistente, seguridad CSRF, validación y preparación para escalabilidad.

---

|Objetivos Generales del Curso | Objetivos de la Sesión 2 |
| --- | --- |
| **Objetivo General 2** | **Objetivo 1**: Comprender el ciclo de vida de peticiones HTTP |
| **Objetivo General 2** | **Objetivo 2**: Dominar enrutamiento y controladores RESTful |
| **Objetivo General 2** | **Objetivo 3**: Dominar el motor Blade con directivas completas |
| **Objetivo General 2** | **Objetivo 4**: Construir layouts y directivas avanzadas |
| **Objetivo General 2** | **Objetivo 5**: Integrar datos con View Composers y buenas prácticas |
| **Objetivo General 2** | **Objetivo 6**: Trabajar con datos mock y traits reutilizables |
| **Objetivo General 2** | **Objetivo 7**: Aplicar patrón de ejemplos progresivos |
| **Objetivo General 2** | **Objetivo 8**: Seguir buenas prácticas Laravel |

## Recursos Adicionales

### **Documentación Oficial**

* [Laravel 12.x Documentation](https://laravel.com/docs/12.x){:target="_blank"} - Documentación oficial completa
* [Laravel Routing](https://laravel.com/docs/12.x/routing){:target="_blank"} - Guía oficial de enrutamiento
* [Laravel Blade Templates](https://laravel.com/docs/12.x/blade){:target="_blank"} - Documentación oficial de Blade

### **Fundamentos Web**

* [MDN Web Docs - HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP){:target="_blank"} - Documentación completa sobre HTTP
* [PHP.net - Controllers](https://www.php.net/manual/en/language.oop5.php){:target="_blank"} - Conceptos de controladores en PHP
* [Blade Template Engine](https://laravel.com/docs/12.x/blade){:target="_blank"} - Motor de plantillas Blade

### **Recursos de Aprendizaje**

* [Laracasts](https://laracasts.com){:target="_blank"} - Tutoriales en video de Laravel
* [Laravel News](https://laravel-news.com){:target="_blank"} - Noticias y artículos sobre Laravel
* [Laravel Daily](https://laraveldaily.com){:target="_blank"} - Tips y tutoriales diarios de Laravel


???examplelaravel "Glosario Técnico"
	| Término | Definición |
	| --- | --- |
	| **array\_filter()** | Función PHP que filtra elementos de un array según una condición booleana y devuelve solo los que cumplen. |
	| **array\_map()** | Función PHP que aplica una transformación a cada elemento de un array y devuelve un nuevo array transformado. |
	| **Blade** | Motor de plantillas de Laravel con sintaxis elegante (, `@if`, `@foreach`) que compila a PHP puro. |
	| **compact()** | Función PHP que convierte variables en array asociativo para pasarlas a vistas (`compact('productos', 'usuario')`). |
	| **Controlador** | Clase que maneja la lógica de negocio y coordina entre modelos y vistas, devolviendo respuestas HTTP. |
	| **Controlador Resource** | Controlador que implementa las 7 acciones RESTful estándar (index, create, store, show, edit, update, destroy). |
	| **Datos Mock** | Datos de prueba simulados en archivos PHP (`database/data/`) para desarrollo sin base de datos real. |
	| **Directiva Blade** | Instrucción especial de Blade (`@if`, `@foreach`, `@auth`, `@csrf`, etc.) que controla el flujo y la lógica en plantillas. |
	| **Herencia de Plantillas** | Mecanismo Blade (`@extends`, `@section`, `@yield`) que permite que vistas hijas extiendan layouts padres. |
	| **Layout** | Plantilla maestra que define la estructura común (header, footer, scripts) de múltiples páginas de una aplicación. |
	| **Middleware** | Capa de software que filtra/procesa las peticiones HTTP antes de llegar a los controladores (autenticación, CORS, etc.). |
	| **Operador Null-Safe** | Operador `?.` de PHP que evita errores al acceder a propiedades/métodos de objetos potencialmente nulos. |
	| **Ruta** | Definición en `web.php` o `api.php` que especifica cómo una URL debe ser manejada por la aplicación Laravel. |
	| **Sección** | Área definida con `@section`/`@yield` en un layout que puede ser sobrescrita (`@show`), añadida (`@append`) o modificada por vistas hijas. |
	| **Service Container** | Contenedor de dependencias que gestiona la creación y resolución automática de objetos en Laravel (IoC Container). |
	| **Stack** | Mecanismo Blade (`@push`, `@stack`) para acumular contenido (scripts, estilos) desde múltiples vistas en un layout. |
	| **Trait** | Mecanismo PHP de reutilización de código horizontal que permite compartir métodos entre clases sin herencia. |
	| **View Composer** | Clase que inyecta datos automáticamente en vistas específicas sin repetir código en controladores. |
	| **View::share()** | Método para compartir datos globalmente con todas las vistas de la aplicación. |



???examplelaravel "FAQ (Preguntas Frecuentes sobre la Práctica)"
	- **P: Error "Target class [NombreController] does not exist" al acceder a una ruta**
		+ **R:** Verifica los siguientes pasos:
			1. El controlador existe en `app/Http/Controllers/`
			2. El nombre del archivo y la clase coinciden exactamente (sensible a mayúsculas)
			3. El namespace es correcto (`namespace App\Http\Controllers;`)
			4. Ejecuta `sail artisan route:clear` para limpiar caché de rutas
			5. Verifica que importaste el controlador en `web.php` con `use App\Http\Controllers\NombreController;`
	- **P: Error "View [nombre-vista] not found" al cargar una página**
		+ **R:** Verifica los siguientes pasos:
			1. El archivo existe en `resources/views/` con extensión `.blade.php`
			2. La ruta es correcta (Laravel usa punto para subdirectorios: `categories.show` = `resources/views/categories/show.blade.php`)
			3. El nombre del archivo no tiene mayúsculas (Laravel es case-sensitive en Linux/Docker
			4. Ejecuta `sail artisan view:clear` para limpiar caché
	- **P: Los datos mock devuelven "Undefined array key" o valores nulos**
		+ **R:** Verifica los siguientes pasos:
			1. Los archivos mock existen en `database/data/` y devuelven un array con `return [...]`
			2. Las claves del array coinciden con los IDs que buscas
			3. En el Trait `LoadsMockData` la ruta del `require` es correcta (`database_path('data/mock-products.php')`)
			4. El método `enrichProductsWithOffers()` se llama antes de pasar datos a la vista
	- **P: El método `enrichProductsWithOffers()` no funciona o muestra datos incorrectos**
		+ **R:** Este método debe cumplir los siguientes pasos:
			1. Cargar ofertas primero con `$this->loadOffers()`
			2. Usar `array_map()` para transformar cada producto
			3. Buscar la oferta en el array de ofertas por `$product['offer_id']`
			4. Calcular `final_price` correctamente: `price * (1 - discount_percentage / 100)`
			5. Verifica que los `offer_id` en productos coincidan con IDs reales en `mock-offers.php`
	- **P: Error "Call to undefined method" al usar el Trait LoadsMockData**
		+ **R:** Verifica los siguientes pasos:
			1. El Trait está declarado en el controlador con `use LoadsMockData;` (dentro de la clase)
			2. El namespace del Trait es correcto (`namespace App\Traits;`)
			3. Importaste el Trait en el controlador con `use App\Traits\LoadsMockData;` (fuera de la clase)
			4. El método que llamas existe en el Trait (revisa mayúsculas/minúsculas)
	- **P: Los componentes Blade (`ProductCard`, `CategoryCard`) no se muestran o dan error**
		+ **R:** Verifica los siguientes pasos:
			1. Creaste ambos archivos: clase en `app/View/Components/` y vista en `resources/views/components/`
			2. Los nombres coinciden (PascalCase en clase, kebab-case en vista: `ProductCard.php` → `product-card.blade.php`)
			3. La clase extiende `Component` y tiene el método `render()`
			4. Las props (`$product`, `$category`) están definidas en el constructor
			5. Ejecuta `sail artisan view:clear` para limpiar caché
	- **P: El layout `app.blade.php` no carga los partials (header, footer, navigation)**
		+ **R:** Verifica los siguientes pasos:
			1. Los partials existen en `resources/views/partials/` con extensión `.blade.php`
			2. La sintaxis de inclusión es correcta: `@include('partials.header')` (punto, no barra)
			3. No hay errores de sintaxis en los partials (un error en un partial rompe toda la página)
			4. Los partials devuelven HTML válido
	- **P: Error 404 "Page not found" al acceder a rutas que definí en `web.php`**
		+ **R:** Verifica los siguientes pasos:
			1. La ruta está correctamente definida en `routes/web.php`
			2. La URL coincide exactamente (revisa parámetros: `/products/{id}` requiere un ID numérico)
			3. Ejecuta `sail artisan route:list` para ver todas las rutas disponibles
			4. El nombre de la ruta es correcto si usas `route('nombre')`
			5. Limpia caché con `sail artisan route:clear`
	- **P: Los estilos de Tailwind no se aplican en las nuevas vistas**
		+ **R:** Verifica los siguientes pasos:
			1. El layout `app.blade.php` incluye `@vite(['resources/css/app.css'])`
			2. Las vistas hijas extienden el layout con `@extends('layouts.app')`
			3. Ejecutaste `sail npm run build` o `sail npm run dev` después de crear nuevas vistas
			4. Las clases de Tailwind están escritas correctamente (sin espacios: `bg-blue-500`, no `bg-blue - 500`)
	- **P: Error "Trying to access array offset on value of type null" en las vistas**
		+ **R:** Usa operadores null-safe siguiendo estos pasos:
			1. Para arrays: `$product['offer'] ?? null`
			2. Para objetos: `$user?->name`
			3. En Blade: `@isset($variable)` antes de usarla
			4. Verifica que el controlador está pasando todos los datos necesarios con `dd($datos)`
	- **P: La navegación no resalta el enlace activo correctamente**
		+ **R:** Verifica los siguientes pasos:
			1. Las rutas tienen nombres asignados con `->name('nombre.ruta')`
			2. En `navigation.blade.php` usas `Route::is('nombre.ruta')` o `request()->routeIs('nombre.ruta')`
			3. Los nombres de ruta coinciden exactamente (sensible a mayúsculas)
			4. Para rutas con parámetros usa wildcards: `Route::is('products.*')`
	- **P: Error "Route [nombre.ruta] not defined" al usar `route()` en vistas**
		+ **R:** Verifica los siguientes pasos:
			1. La ruta tiene nombre asignado en `web.php` con `->name('nombre.ruta')`
			2. El nombre no tiene errores tipográficos
			3. Ejecuta `sail artisan route:list` para ver todas las rutas con nombres
			4. Limpia caché con `sail artisan route:clear` y `sail artisan config:clear`
	- **P: Los productos no muestran el precio con descuento aplicado**
		+ **R:** Verifica los siguientes pasos:
			1. Estás llamando `enrichProductsWithOffers()` en el controlador ANTES de pasar datos a la vista
			2. El producto tiene un `offer_id` válido en `mock-products.php`
			3. La oferta existe en `mock-offers.php` con ese ID
			4. El cálculo es correcto: `final_price = price * (1 - discount_percentage / 100)`
			5. Usas `$product['final_price']` en la vista, no calculas allí
	- **P: ¿Cómo depuro qué datos está recibiendo mi vista?**
		+ **R:** Usa estas técnicas de depuración:
			1. En el controlador: `dd($productos)` antes de `return view()` para ver datos
			2. En la vista: `{{ dd($productos) }}` o `@dump($productos)` para inspeccionar
			3. Laravel Telescope → Requests → Ver datos pasados a la vista
			4. Navegador → Ver código fuente para verificar HTML generado

## 🏆 Hitos a Conseguir

> Al completar esta sesión, habrás creado una **aplicación web dinámica con Laravel** que incluya:
>
> * Sistema de rutas RESTful organizadas en `web.php` y `api.php`
> * Controladores resource profesionales con separación de responsabilidades
> * Layouts maestros Blade con herencia, directivas avanzadas y stacks
> * Integración de datos usando View Composers y múltiples métodos
> * Datos mock organizados con traits reutilizables
> * Aplicación completa del patrón MVC
> * Comprensión profunda del ciclo de vida de peticiones HTTP
> * Buenas prácticas de seguridad (CSRF, escapado, validación)
>
> **Resultado:** Una aplicación web funcional lista para escalar a base de datos real en Sesión 3.
