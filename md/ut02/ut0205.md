---
title: 2.5. Funciones
---
# 2.5. Funciones

Al no declararse los tipos de datos, los parámetros de las funciones no tienen tipo ni se indica el tipo de dato que devuelven. 

El **paso de parámetros** se realiza **por valor**, es decir, se realiza una copia de la variable.

```php
<?php
  function nombreFuncion($par1, $par2, ...) {
      // código
      return $valor;
  }

  $resultado = nombreFuncion($arg1, $arg2, …);
?>
```


=== "Ejemplo función"
    ```php
    <?php
      function diaSemana() {
          $semana = [ "lunes", "martes", "miércoles",
                      "jueves", "viernes", "sábado", "domingo" ];
          $dia = $semana[rand(0, 6)];
          return $dia;
      }

      $diaCine = diaSemana();
      echo "El próximo $diaCine voy al cine.";
    ?>
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova251.png" alt="prova 251" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>


## 1. Parámetros por referencia

Si queremos pasar un parámetro por referencia, en la declaración de la función, indicaremos los parámetros mediante el operador **`&`** para indicar la dirección de memoria de la variable.

=== "Ejemplo argumentos por referencia"
    ```php
    <?php
          function duplicarPorValor($argumento) {
                $argumento = $argumento * 2;
                echo "Dentro de la función: $argumento.<br>";
          }
          function duplicarPorReferencia(&$argumento) {
                $argumento = $argumento * 2;
                echo "Dentro de la función: $argumento.<br>";
          }

          $numero1 = 5;
          echo "Paso de parámetros por valor:<br/>";
          echo "Antes de llamar: $numero1.<br>";
          duplicarPorValor($numero1);
          echo "Después de llamar: $numero1.<br>";
          echo "<br>";
    
          $numero2 = 7;
          echo "Paso de parámetros por referencia:<br/>";
          echo "Antes de llamar: $numero2.<br>";
          duplicarPorReferencia($numero2);
          echo "Después de llamar: $numero2.<br>";
    ?>
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova252.png" alt="prova 252" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>


## 2. Parámetros por defecto / opcionales

Permiten asignar valores en la declaración, y posteriormente, dejar el argumento en blanco.

=== "Ejemplo argumentos por defecto"
    ```php
    <?php
       function obtenerCapital($pais = "todos") {
             $capitales = array("Italia" => "Roma",
                                "Francia" => "Paris",
                                "Portugal" => "Lisboa");

             if ($pais == "todos") {
                  return array_values($capitales);
             } else {
                  return $capitales[$pais];
             }
       }
    
       print_r(obtenerCapital());
       echo "<br/>";
       echo obtenerCapital("Francia");
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova253.png" alt="prova 253" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

En el caso de convivir con otro tipo de parámetros, los parámetros que tienen el valor asignado por defecto siempre se colocan al final.

=== "Ejemplo orden argumentos"
    ```php
    <?php
       function saluda($nombre, $prefijo = "Sr") {
            echo "Hola ".$prefijo." ".$nombre."<br/>";
       }

       saluda("Aitor", "Mr");
       saluda("Aitor");
       saluda("Marina", "Srta");
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova254.png" alt="prova 254" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

## 3. Parámetros variables

Podemos tener funciones donde en la declaración no indiquemos la cantidad de datos de entrada.

- `$cantidad` = **`func_num_args();`** → Obtiene la cantidad de parámetros recibidos.
- `$arrayArgs` = **`func_get_args();`** → Obtiene un array con los parámetros.
- `$valor` = **`func_get_arg(numArgumento);`** → Obtiene el parámetro que ocupa la posición `numArgumento`.

Estas funciones no se pueden pasar como parámetro a otra función (como funciones variable, que veremos más adelante). Para ello, debemos guardar previamente la función en una variable.


=== "Ejemplo argumentos variables"
    ```php
    <?php
        function sumaParametros() {
            if (func_num_args() == 0) {
                return false;
            } else {
                $suma = 0;

                for ($i = 0; $i < func_num_args(); $i++) {
                    $suma += func_get_arg($i);
                }
    
                return $suma;
            }
        }
    
        echo sumaParametros(1, 5, 9); // 15
    ?>
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova255.png" alt="prova 255" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

### Variadics

Desde PHP 5.6, se puede utilizar el operador **`...`** (**variadics**) el cual "*disfraza*" los parámetros como un array. Este operador se coloca delante de un parámetro en la definición de la función, y dicho parámetro se convertirá en un **array** que contendrá todos los argumentos adicionales pasados a la función:

=== "Ejemplo *variadics*"

    ```php
    <?php
        function sumaParametrosMejor(...$numeros) {
            if (count($numeros) == 0) {
                return false;
            } else {
                $suma = 0;
                foreach ($numeros as $num) {
                	$suma += $num;
            	}
    
            return $suma;
            }
        }
    
        echo sumaParametrosMejor(1, 5, 9); // 15
    ?>
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova256.png" alt="prova 256" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

> **Más usos de `...`**
> 
> También se puede utilizar para dividir un array en variables separadas para proporcionar argumentos:
> === "Php"
>     ```Php
>     <?php
>     function suma($a, $b) {
>       return $a + $b;
>     }
>     
>     echo suma(...[1, 5])."<br />";
>     
>     $a = [1, 5];
>     echo suma(...$a);
>     ?>
>     ```
> === "Resultado"
>     <div style="text-align: center;"><img src="../../img/ut02/ut02_prova257.png" alt="prova 257" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

???questionphp "Ejercicio de función de parámetros variables y variadics"
	Realiza un ejercicio en el que:
    
	- Se genere un array de 31 elementos (de nombre *lluvias*) en el que se recoja la cantidad de agua de cada día del mes.<br />
	- Cada valor de cantidad se deberá crear, de forma aleatoria, a partir de un número comprendido entre `0` y `100`.<br />
	- Se deberá crear una función (de nombre *suma de precipitaciones*) para sumar todas las cantidades del array lluvias (que se le pasará como parámetro).<br />
	- El resultado mostrará la precipitación total y la precipitación media.


## 4. Argumentos con nombre

Desde PHP 8.0 podemos pasar los argumentos con el nombre (además de por posición, como hemos hecho hasta ahora). Los argumentos con nombre se pasan poniendo el nombre como prefijo del parámetro separado por dos puntos: `$resultado = funcion( arg1 : valor1, arg2 : valor2 );`

Esta característica complementa los parámetros opcionales permitiéndonos saltar su valor:


=== "Ejemplo argumentos por nombre"
    ```php
    <?php
        function funcionArgumentosNombre($a, $b = 2, $c = 4) {
            echo "$a $b $c";
        }

        funcionArgumentosNombre(c: 3, a: 1); // "1 2 3"
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova258.png" alt="prova 258" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

Tanto los parámetros opcionales como los obligatorios pueden tener nombre, pero los argumentos con nombre se tienen que poner después de los que no lo tienen.

=== "Ejemplo orden argumentos"
    ```php
    <?php
        funcionArgumentosNombre(1, c: 3); // "1 2 3"
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova258.png" alt="prova 258" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

## 5. Funciones tipadas

Desde PHP7 en las funciones, tanto los **parámetros** como su **valor de retorno**, permiten la definición de tipos. Esto se conoce como `strict_types` (tipificación estricta) y hay que definirlo en la primera línea de cada archivo `.php` para que el propio interprete PHP compruebe los tipos y lance errores si los tipos son incorrectos, mediante la sentencia:

```php
<?php
 	declare(strict_types=1);
```

Así pues, vamos a definir los tipos de los parámetros y de los valores devueltos mediante los tipos: `int`, `float`, `string`, `bool`, `object` y `array`.

Si una función no devuelve nada se indica mediante el tipo `void`.

=== "Ejemplo función tipada"
    ```php
    <?php
        declare(strict_types=1);

        function suma(int $a, int $b) : int {
            return $a + $b ;
        }
    
        $num = 33;
        echo suma(10, 30). "<br />";
        echo suma(10, $num). "<br />";
        echo suma("10", 30); // error por tipificación estricta, si no daría 40
    ?>
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova259.png" alt="prova 259" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

???questionphp "Ejemplo 1"
    ¿Qué ocurre si enviamos un número y una cadena sin utilizar `strict`:
    ```php
    <?php
    declare(strict_types=1);

    function sumaNumeros(int $a, int $b) {
        return $a + $b;
    }

    // como `strict` no está habilitado la cadena "2 tablas" se convierte en int(2)
    // y el resultado devolverá 5
    echo sumaNumeros(3, "2 tablas");

    ?>
    ```
    
???questionphp "Ejemplo 2"
    Si queremos retornar un valor de un tipo diferente al de los argumentos, deberemos asegurarnos que retorna el tipo correcto (en este ejemplo haciendo un *cast*):
    ```php
    <?php
    declare(strict_types=1);

    function sumaNumeros(float $a, float $b) : int {
        return (int) ($a + $b);
    }

    // el resultado devolverá 5
    echo sumaNumeros(3.3, 2.5);

    ?>
    ```

## 6. Alcance

Las variables definidas fuera de las funciones tienen alcance **global**: accesibles desde cualquier función.

Los parámetros de una función y las variables declaradas dentro de una función (se conocen como variables **locales**) sólo son accesibles desde dentro de la misma función → alcance de **función**.

En caso de conflicto, tienen prioridad las variables locales. Para evitar el conflicto, dentro de la función, podemos declarar la variable como `global`.

=== "Ejemplo alcance local"
    ```php
    <?php
        function miCiudad() {
            $ciudad = "Elche";
            echo "Dentro de la función: $ciudad.<br>";
        }

        $ciudad = "Alicante";
        echo "Antes de la función: $ciudad.<br>";
        miCiudad();
        echo "Después de la función: $ciudad.<br>"
    ?>
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova25a.png" alt="prova 25a" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>
<br/>
=== "Ejemplo alcance global"
    ```php
    <?php
        function miCiudad() {
            global $ciudad;
            $ciudad = "Elche";
            echo "Dentro de la función: $ciudad.<br>";
        }

        $ciudad = "Alicante";
        echo "Antes de llamar: $ciudad.<br>";
        miCiudad();
        echo "Después de llamar: $ciudad.<br>"
    ?>
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova25b.png" alt="prova 25b" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

!!!warning "No globales"
 	Hay que evitar el uso de variables globales dentro de las funciones. En el caso de necesitarlas, es mejor pasarlas como parámetro a las funciones.

### 6.1. Uso de tipos `nullables` (PHP 7.1+)
Si necesitas que un parámetro o valor de retorno acepte *null*, puedes usar el operador **`?`** delante del tipo. Esto indica que el valor puede ser del tipo especificado o *null*.
=== "Ejemplo tipos *nullables*"
    ```php
    <?php
    function obtenerNombre(?string $nombre): string {
        return $nombre ? $nombre : "Invitado";
    }

    echo obtenerNombre(null); // Imprime "Invitado"
    echo obtenerNombre("Juan"); // Imprime "Juan"
    ```
=== "Resultado"
	En este caso, el parámetro `$nombre` puede ser un `string` o `null`. Si es null, la función retorna "Invitado".

### 6.2. Tipos union (PHP 8.0+)
PHP 8.0 introdujo los **tipos unión**, que permiten que un parámetro o valor de retorno pueda ser de varios tipos a la vez.
=== "Ejemplos unión de tipos"
    ```php
    <?php
        function obtenerValor(int|string $valor): string {
        	return (string) $valor;
    	}
	
    	echo obtenerValor(10);     // Imprime "10"
    	echo obtenerValor("diez"); // Imprime "diez"
    ```
=== "Resultado"
	En este caso, el parámetro `$valor` puede ser un `int` o un `string`.

## 7. Funciones variable

- Permite asignar una función a una variable.
- Nombre de la función entre comillas.
- Si una variable va seguida de paréntesis, PHP buscará una función con su valor.

=== "Sintaxis"
    ```php
    <?php
        $nombreFuncion = 'nombreDeLaFuncion';
		$nombreFuncion(); // Llama a nombreDeLaFuncion()
    ```
=== "Ejemplo"
	```php
    <?php
    	function sumar ($a, $b){
    		return $a + $b;
    	}
        $funcion = "sumar";
        echo $funcion(3,4); // invoca a la función suma
    ?>
    ```
=== "Resultado"
	Aquí, la variable `$operacion` almacena el nombre de la función `sumar`, y al llamarla con los argumentos (3, 4), realiza la operación y devuelve el resultado.

!!!note "Funciones anónimas"
 	PHP permite la definición y uso de funciones anónimas, es decir, funciones que no tienen nombre, y se utilizan principalmente para gestionar los *callbacks*. Este tipo de funciones se utiliza mucho en **Javascript** para gestionar los eventos y promesas.
 	
    === "Ejemplo función anónima"
        ```php
        <?php
            $anonima = function() {
                echo "Hola"."<br/>";
            };
            $anonima();
    
            $anonimaConParametro = function($nombre) {
                echo "Hola ".$nombre."<br/>";
            };
            $anonimaConParametro("Aitor");
    
            // Uso de variables externas a la función anónima --> `use`
            $mensaje = "Hola";
            $miClosure = function() use ($mensaje) {
                echo $mensaje."<br/>";;
            };
            $miClosure();
    
            // Uso de parámetros
            $holaPHP = function($arg) use ($mensaje) {
                echo $mensaje." ".$arg;
            };
            $holaPHP("PHP");
        ?>
        ```
    === "Resultado"
        <div style="text-align: center;"><img src="../../img/ut02/ut02_prova25c.png" alt="prova 25c" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>


 	Desde PHP 7.4 se han introducido las funciones flecha (*arrow functions*) para simplificar su definición y uso.
 	
 	Tenéis más información sobre funciones anónimas y flecha en el siguiente artículo (en inglés): [Funciones anónimas y flecha en PHP](https://code.tutsplus.com/anonymous-and-arrow-functions-in-php--cms-36725t).

## 8. Biblioteca de funciones

Podemos agrupar un conjunto de funciones en un archivo, para permitir su reutilización. Posteriormente, se incluye con:

- **`include(archivo);`**   |   **`include_once(archivo);`**
- **`require(archivo);`**   |   **`require_once(archivo);`**

Si no encuentra el archivo, `require` lanza un error fatal, `include` lo ignora. 

Las funciones `_once` sólo se cargan una vez, si ya ha sido incluida previamente, no lo vuelve a hacer, evitando bucles.

Por ejemplo, colocamos las funciones en el archivo `biblioteca.php` y posteriormente en otro archivo se referencian:

=== "`biblioteca.php`"
    ```php
    <?php
        function suma(int $a, int $b) : int {
            return $a + $b;
        }

        function resta(int $a, int $b) : int {
            return $a - $b;
        }
    ?>
    ```
=== "Php"
    ```php
    <?php
        include_once("biblioteca.php");
        echo suma(10,20);
        echo resta(40,20);
    ?>
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova25d.png" alt="prova 25d" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>

## 9. Plantillas mediante include

Mediante el uso de la instrucción `include` también podemos separar fragmentos de código PHP/HTML que queramos reutilizar en nuestros sitios web y crear un sistema muy sencillo de plantillas. 

Por ejemplo, vamos a separar una página en tres partes:

=== "Parte superior en `header.php`"
    ```php
    <!DOCTYPE html>
    <html lang="es">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title><?= $titulo ?></title>
    </head>
    <body>
    ```
=== "Parte inferior en `footer.html`"
    ```html
        <footer>Profesor/a X</footer>
    </body>
    </html>
    ```
=== "Página utilizando *include*"
    Y luego nos centramos únicamente en el contenido que cambia en `pagina.php`:

    ```php
    <?php
        $titulo = "Página con includes";
        include("header.php");
    ?>

    <h1><?= $titulo ?></h1>
    
    <?php
        include("footer.html");
    ?>
    ```
=== "Resultado"
	<div style="text-align: center;"><img src="../../img/ut02/ut02_prova25e.png" alt="prova 25e" style="zoom:100%; border: 2px solid #fff2c9;" /></figure></div>
	
	
??? ies "Ejercicios a realizar"
	- Ejercicio 241
	- Ejercicio 242
	- Ejercicio 243
	- Ejercicio 244
	- Ejercicio 245
	- Ejercicio 246
	- Ejercicio 247
	- Ejercicio 248
