---
title: 2.7. Expresiones regulares
---
# 2.7. Expresiones regulares


## 1. Qué son y cómo se usan

En PHP, las expresiones regulares (PCRE) se utilizan con las funciones `preg_*`.

**Siempre** se indica un **delimitador** alrededor del patrón (habitualmente `/`). 

Estructura general:

```
/<patrón>/<modificadores>
```

!!!examplephp "Ejemplo mínimo:"
	```php
	<?php
	$patron = '/\d+/';           // uno o más dígitos
	$texto  = 'Tengo 12 perros';

	if (preg_match($patron, $texto, $m)) {
		echo "Hay un número: {$m[0]}";   // "12"
	}
	?>
	```


## 2. Funciones `preg_*` principales

| Función | Qué hace | Devuelve |
|---|---|---|
| `preg_match($patrón, $texto, &$coinc)` | Devuelve solo la **primera** coincidencia | `1` si hay match, `0` si no |
| `preg_match_all($patrón, $texto, &$coinc)` | Devuelve todas las coincidencias en un **array** |
| `preg_replace($patrón, $reemplazo, $texto, $lim=-1, &$count=null)` | Reemplaza por patrón.<br/> `-1` → sin límite de reemplazos (si pones `1`, solo cambia la primera coincidencia). | String |
| `preg_replace_callback($patrón, $callback, $texto)` | Permite aplicar una función de callback a cada coincidencia del patrón. De esta forma puedes transformar dinámicamente el valor encontrado. | String |
| `preg_split($patrón, $texto, $lim=-1)` | Divide string por patrón.<br/>`-1` significa que no hay límite de divisiones. | Array |
| `preg_grep($patrón, $array)` | Filtra un array por regex | Array |
| `preg_last_error()` | Útil tras `preg_*`.<br/>Devuelve un código numérico que indica el último error producido por una función de expresiones regulares.<br/>`PREG_NO_ERROR` → 0,<br/> `PREG_INTERNAL_ERROR` → 1,<br/> `PREG_BACKTRACK_LIMIT_ERROR` → 2,<br/> `PREG_RECURSION_LIMIT_ERROR` → 3,<br/> `PREG_BAD_UTF8_ERROR` → 4,<br/> `PREG_BAD_UTF8_OFFSET_ERROR` → 5,<br/> `PREG_JIT_STACKLIMIT_ERROR` → 6| Constante numérica. |

!!!examplephp "Ejemplos:"
	=== "preg_match"
		```php
		<?php
		$patron = '/\d+/';           // uno o más dígitos
		$texto  = 'Tengo 12 perros';

		if (preg_match($patron, $texto, $m)) {
			echo "Hay un número: {$m[0]}";   // "12"
		}
		?>
		```
	=== "preg_match_all"
		```php
		<?php
		$patron = '/\d+/';           // uno o más dígitos
		$texto  = 'Tengo 12 perros, 4 gatos y 7 periquitos';

		if (preg_match_all($patron, $texto, $coincidencias)) {
			echo "Números encontrados:<br>";
			foreach ($coincidencias[0] as $num) {
				echo $num . "<br>";
			}
		}
		?>
		```
	=== "preg_replace"
		```php
		<?php
		$patron  = '/\d+/';             // uno o más dígitos
		$reemplazo = '#';               // sustituir números por #
		$texto   = 'Tengo 12 perros y 4 gatos';

		$nuevoTexto = preg_replace($patron, $reemplazo, $texto, -1, $count);

		echo "Texto original: $texto<br>";
		echo "Texto modificado: $nuevoTexto<br>";
		echo "Reemplazos realizados: $count";
		?>
		```
	=== "preg_replace_callback"
		```php
		<?php
		$patron = '/\d+/';   // uno o más dígitos
		$texto  = 'Tengo 12 perros y 4 gatos';

		// Callback: recibe cada coincidencia y devuelve el nuevo valor
		$nuevoTexto = preg_replace_callback($patron, function($coincidencia) {
			// $coincidencia es un array, el índice [0] es el valor encontrado
			$numero = (int)$coincidencia[0];
			return $numero * 2;   // multiplicamos por 2 cada número encontrado
		}, $texto);

		echo "Texto original: $texto<br>";
		echo "Texto modificado: $nuevoTexto";
		?>
		```
	=== "preg_split"
		```php
		<?php
		$patron = '/\d+/';   // dividir por uno o más dígitos
		$texto  = 'Tengo 12 perros y 4 gatos';

		// dividimos el texto por los números
		$partes = preg_split($patron, $texto, -1);

		echo "Texto original: $texto<br>";
		echo "Partes obtenidas:<br>";
		foreach ($partes as $p) {
			echo "- $p<br>";
		}
		?>
		```
	=== "preg_grep"
		```php
		<?php
		$patron = '/^A/';   // elementos que empiezan por "A"
		$array  = ["Ana", "Pedro", "Andrés", "Lucía", "Alba", "Juan"];

		$resultado = preg_grep($patron, $array);

		echo "Elementos originales:<br>";
		print_r($array);

		echo "<br><br>Coincidencias:<br>";
		print_r($resultado);
		?>
		```
	=== "preg_last_error"
		```php
		<?php
		$patron = '/[a-z/';   // patrón incorrecto (falta cerrar corchete)
		$texto  = 'Hola Mundo';

		preg_match($patron, $texto);

		echo preg_last_error();
		?>
		```

## 3. Delimitadores y escapado

- Delimitador más común: `/`.
- Si tu patrón contiene muchas barras `/`, usa otros: `#patrón#`, `~patrón~`, `~https?://~`.
- Los **delimitadores deben cerrarse** y los **modificadores** van al final: `/\d+/u`.
- Si el propio delimitador aparece dentro del patrón, **escápalo** o cambia de delimitador.



## 4. Modificadores útiles

| Mod | Significado | Efecto |
|---|---|---|
| `i` | Case-insensitive | `'/hola/i'` empareja `Hola` |
| `m` | Multilínea | `^`/`$` funcionan por *línea* |
| `s` | Dotall | `.` también empareja saltos de línea |
| `u` | Unicode (UTF-8) | Recomendado para tildes/ñ |
| `U` | Ungreedy | Cuantificadores perezosos por defecto |
| `x` | Extended | Permite espacios/comentarios en el patrón |
| `A` | Ancla inicio | El patrón debe empezar en índice 0 |
| `D` | `$` solo al final real | Evita casar antes de `\n` final |
| `J` | Duplicar nombres de grupos | Casos avanzados |

**Ejemplo Unicode:** `'/^\p{L}+$/u'` coincide **solo letras** (incluye tildes y ñ).



## 5. Sintaxis del patrón (chuleta)

### Clases y metacaracteres
| Expresión | Significa |
|---|---|
| `.` | Cualquier carácter (excepto `\n` si no hay `s`) |
| `\d` / `\D` | Dígito / no dígito |
| `\w` / `\W` | “Word char” (letra, dígito, `_`) / lo contrario |
| `\s` / `\S` | Espacio en blanco / no espacio |
| `[abc]` | a o b o c |
| `[^abc]` | cualquiera excepto a, b, c |
| `[a-z]` | rango |
| `\p{L}` | letra Unicode |
| `\p{N}` | número Unicode |

### Anclas
| Expresión | Significa |
|---|---|
| `^` | Inicio de cadena (o línea con `m`) |
| `$` | Fin de cadena (o línea con `m`) |
| `\b` / `\B` | Límite / no límite de palabra |

### Cuantificadores
| Expresión | Significa | Codicioso / Perezoso |
|---|---|---|
| `a?` | 0 o 1 | `?` / `??` |
| `a*` | 0 o más | `*` / `*?` |
| `a+` | 1 o más | `+` / `+?` |
| `a{n}` | exactamente n | — |
| `a{n,}` | al menos n | `,` / `,?` |
| `a{n,m}` | entre n y m | `}` / `}?` |

### Grupos, backreferences, lookarounds
| Expresión | Significa |
|---|---|
| `( ... )` | Grupo capturante |
| `(?: ... )` | Grupo **no** capturante |
| `(?P<nombre> ... )` | Grupo con **nombre** |
| `\1`, `\2` | Backreferences por índice |
| `(?= ... )` | Lookahead positivo (afirmación hacia delante) |
| `(?! ... )` | Lookahead negativo |
| `(?<= ... )` | Lookbehind positivo |
| `(?<! ... )` | Lookbehind negativo |



## 6. Ejemplos prácticos

### `preg_match` (extraer dato)
```php
<?php
$texto = 'Pedido #A-2025-0098 listo';
if (preg_match('/#([A-Z]-\d{4}-\d{4})/', $texto, $m)) {
	echo $m[1]; // A-2025-0098
}
?>
```

### `preg_match_all` (todas las coincidencias)
```php
<?php
$html = '<a href="https://site.com">x</a> y <a href="http://ejemplo.es">y</a>';
preg_match_all('/href="([^"]+)"/', $html, $m);
print_r($m[1]); // ["https://site.com", "http://ejemplo.es"]
?>
```

### `preg_replace` (limpieza normalizada)
```php
<?php
$nombre = "  María   López  ";
$limpio = preg_replace('/\s+/', ' ', trim($nombre));
// "María López"
?>
```

### `preg_replace_callback` (transformación con lógica)
```php
<?php
$texto = "IVA: 21%, Precio: 123.45€";
$salida = preg_replace_callback('/\d+(\.\d+)?/', function($m) {
	// formatear con coma decimal
	return number_format((float)$m[0], 2, ',', '.');
}, $texto);
// "IVA: 21,00%, Precio: 123,45€"
?>
```

### `preg_split` (CSV “simple”: comas con espacios)
```php
<?php
$csv = 'manzana, pera ,  uva';
$partes = preg_split('/\s*,\s*/', trim($csv));
// ["manzana","pera","uva"]
?>
```

### Grupos con nombre y backreferences
```php
<?php
$fecha = '2025-09-18';
if (preg_match('/(?P<y>\d{4})-(?P<m>\d{2})-(?P<d>\d{2})/', $fecha, $m)) {
	echo "{$m['d']}/{$m['m']}/{$m['y']}"; // 18/09/2025
}
?>
```

### Aserciones (lookahead) para validar password (simple)
```php
<?php
$pwd = 'Abcde1!';
$patron = '/^(?=.*[A-Z])(?=.*[a-z])(?=.*\d).{6,}$/';
echo preg_match($patron, $pwd) ? 'OK' : 'KO';
?>
```

### Español/Unicode: palabras con tildes y ñ
```php
<?php
$texto = 'camión acción año café';
preg_match_all('/\b\p{L}+\b/u', $texto, $m);
print_r($m[0]); // reconoce bien tildes y ñ (¡usa 'u'!)
?>
```

### Reemplazar solo fuera de etiquetas `<code>` (avanzado)
> Para HTML real, mejor un parser (DOMDocument). Ejemplo didáctico:
```php
<?php
$txt = 'Esto es <code>hola</code> y hola fuera';
$pat = '~(<code>.*?</code>)|hola~s';
$out = preg_replace_callback($pat, function($m){
	if (!empty($m[1])) return $m[1]; // bloque code intacto
	return 'HOLA';
}, $txt);
// "Esto es <code>hola</code> y HOLA fuera"
?>
```



## 7. Patrones típicos de referencia

| Caso | Patrón | Nota |
|---|---|---|
| Email (simple) | `/^[\w.+-]+@[\w.-]+\.\w{2,}$/i` | Básico; para producción usar validación adicional |
| URL http/https | `~^https?://[^\s/$.?#].[^\s]*$~i` | Aproximado |
| DNI (simple) | `/^\d{8}[A-Za-z]$/` | Letra se calcula aparte |
| NIF/NIE (básico) | `/^[XYZ]?\d{7,8}[A-Za-z]$/` | Comprobar letra por código |
| Fecha `YYYY-MM-DD` | `/^\d{4}-\d{2}-\d{2}$/` | Valida formato, no calendario |
| Teléfono ES (flex) | `/^\+?34?\s?(\d[\s-]?){9}$/` | Ajustar a formato deseado |
| Solo letras Unicode | `/^\p{L}+$/u` | Incluye acentos/ñ |



## 8. Consejos y “gotchas”

- Con tildes/ñ: **usa el modificador `u`** (`/…/u`) para modo UTF-8.
- En HTML real, **mejor un parser** que regex pura (DOMDocument).
- Evita patrones excesivamente **codiciosos** (`.*`). Prefiere anclar (`^...$`) o usar `?` perezoso.
- Si algo falla, revisa **delimitadores** y el **escapado**.
- Para problemas raros/rendimiento, inspecciona `preg_last_error()` y simplifica alternancias.



## 9. Recetas rápidas

**A) Extraer dominio de un email**
```php
<?php
$email = 'alguien@iesmre.es';
preg_match('/@([^@]+)$/', $email, $m);
echo $m[1]; // iesmre.es
?>
```

**B) Convertir `==>` por flecha `→` salvo dentro de comillas**
```php
<?php
$txt = 'a ==> b, "x ==> y"';
$pat = '/"[^"]*"(*SKIP)(*F)|==>/'; // PCRE verbs
$out = preg_replace($pat, '→', $txt);
// 'a → b, "x ==> y"'
?>
```

**C) Normalizar espacios y guiones**
```php
<?php
$s = "Gestión   de   Contenidos--- WordPress";
$s = preg_replace('/\s+/', ' ', $s);
$s = preg_replace('/-{2,}/', '-', $s);
// "Gestión de Contenidos- WordPress"
?>
```

**D) Partir por líneas vacías (párrafos)**
```php
<?php
$bloques = preg_split("/\R{2,}/", $texto); // \R = cualquier salto
?>
```

???question "Aprender expresiones regulares"
 	¿Qué cadenas de texto encontrarían las siguientes regexp?

 	&nbsp;&nbsp;a) `hola`<br />
 	&nbsp;&nbsp;b) `h.?a`<br />
 	&nbsp;&nbsp;c) `h+b.`<br />
 	&nbsp;&nbsp;d) `[2-4]?[3-9ag]`<br />
 	&nbsp;&nbsp;e) `aju{2,8}m[-.]z`<br />
 	&nbsp;&nbsp;f) `(ad)+juju.[0-9]?-`<br />
 	&nbsp;&nbsp;g) `(ho|la)?[4-7zu]`<br />
 	&nbsp;&nbsp;h) `[([0-4][0-9]|5[0-2])[0-9]{3}` . Códigos Postales España<br />
 	&nbsp;&nbsp;i) `^.{3,32}#[0-9]{4}$` . Usuario Discord<br />
 	&nbsp;&nbsp;j) `(b25[0-5]|b2[0-4][0-9]|b[01]?[0-9][0-9]?)(.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}` . Dirección ipv4. b es un delimitador de palabra «boundary».<br />